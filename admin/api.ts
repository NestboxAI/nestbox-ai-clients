/* tslint:disable */
/* eslint-disable */
/**
 * Nestbox API Admin
 * API for Nestbox Admin, control your resources
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface AddProjectMemberData
 */
export interface AddProjectMemberData {
    /**
     * 
     * @type {string}
     * @memberof AddProjectMemberData
     */
    'message': string;
    /**
     * 
     * @type {object}
     * @memberof AddProjectMemberData
     */
    'project': object;
}
/**
 * 
 * @export
 * @interface AddProjectMemberDto
 */
export interface AddProjectMemberDto {
    /**
     * 
     * @type {string}
     * @memberof AddProjectMemberDto
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof AddProjectMemberDto
     */
    'lastName': string;
    /**
     * 
     * @type {string}
     * @memberof AddProjectMemberDto
     */
    'email': string;
    /**
     * 
     * @type {number}
     * @memberof AddProjectMemberDto
     */
    'roleId': number;
}
/**
 * 
 * @export
 * @interface AddProjectMemberResponseDTO
 */
export interface AddProjectMemberResponseDTO {
    /**
     * 
     * @type {AddProjectMemberData}
     * @memberof AddProjectMemberResponseDTO
     */
    'data': AddProjectMemberData;
}
/**
 * 
 * @export
 * @interface AllProjectResponse
 */
export interface AllProjectResponse {
    /**
     * 
     * @type {string}
     * @memberof AllProjectResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof AllProjectResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof AllProjectResponse
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof AllProjectResponse
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof AllProjectResponse
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof AllProjectResponse
     */
    'deletedAt': string;
}
/**
 * 
 * @export
 * @interface AllProjectResponseModel
 */
export interface AllProjectResponseModel {
    /**
     * 
     * @type {Array<AllProjectResponse>}
     * @memberof AllProjectResponseModel
     */
    'projects': Array<AllProjectResponse>;
    /**
     * 
     * @type {number}
     * @memberof AllProjectResponseModel
     */
    'totalCount': number;
}
/**
 * 
 * @export
 * @interface BadRequestExceptionResponse
 */
export interface BadRequestExceptionResponse {
    /**
     * 
     * @type {string}
     * @memberof BadRequestExceptionResponse
     */
    'message': string;
    /**
     * 
     * @type {object}
     * @memberof BadRequestExceptionResponse
     */
    'errors': object | null;
}
/**
 * 
 * @export
 * @interface BenchmarkingDatapointDto
 */
export interface BenchmarkingDatapointDto {
    /**
     * Combined content of all benchmarking lines
     * @type {string}
     * @memberof BenchmarkingDatapointDto
     */
    'lines': string;
    /**
     * Total number of lines found
     * @type {number}
     * @memberof BenchmarkingDatapointDto
     */
    'totalLines': number;
}
/**
 * 
 * @export
 * @interface BenchmarkingReportsDto
 */
export interface BenchmarkingReportsDto {
    /**
     * Combined markdown content of all benchmarking reports
     * @type {string}
     * @memberof BenchmarkingReportsDto
     */
    'content': string;
    /**
     * Total number of reports found
     * @type {number}
     * @memberof BenchmarkingReportsDto
     */
    'totalReports': number;
}
/**
 * 
 * @export
 * @interface BooleanResponseDTO
 */
export interface BooleanResponseDTO {
    /**
     * 
     * @type {boolean}
     * @memberof BooleanResponseDTO
     */
    'data': boolean;
}
/**
 * 
 * @export
 * @interface ChunkFileRequestDTO
 */
export interface ChunkFileRequestDTO {
    /**
     * 
     * @type {string}
     * @memberof ChunkFileRequestDTO
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof ChunkFileRequestDTO
     */
    'url': string;
    /**
     * 
     * @type {object}
     * @memberof ChunkFileRequestDTO
     */
    'options': object;
}
/**
 * 
 * @export
 * @interface CreateCollectionRequestDTO
 */
export interface CreateCollectionRequestDTO {
    /**
     * 
     * @type {string}
     * @memberof CreateCollectionRequestDTO
     */
    'name': string;
    /**
     * 
     * @type {object}
     * @memberof CreateCollectionRequestDTO
     */
    'metadata': object;
}
/**
 * 
 * @export
 * @interface CreateDocumentRequestDTO
 */
export interface CreateDocumentRequestDTO {
    /**
     * 
     * @type {string}
     * @memberof CreateDocumentRequestDTO
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof CreateDocumentRequestDTO
     */
    'document': string;
    /**
     * 
     * @type {object}
     * @memberof CreateDocumentRequestDTO
     */
    'metadata': object;
}
/**
 * 
 * @export
 * @interface CreateMachineAgentDto
 */
export interface CreateMachineAgentDto {
    /**
     * 
     * @type {string}
     * @memberof CreateMachineAgentDto
     */
    'agentName': string;
    /**
     * 
     * @type {string}
     * @memberof CreateMachineAgentDto
     */
    'goal': string;
    /**
     * 
     * @type {string}
     * @memberof CreateMachineAgentDto
     */
    'modelBaseId': string;
    /**
     * 
     * @type {string}
     * @memberof CreateMachineAgentDto
     */
    'machineName': string;
    /**
     * 
     * @type {number}
     * @memberof CreateMachineAgentDto
     */
    'machineInstanceId': number;
    /**
     * 
     * @type {string}
     * @memberof CreateMachineAgentDto
     */
    'instanceIP': string;
    /**
     * 
     * @type {string}
     * @memberof CreateMachineAgentDto
     */
    'entryFunctionName': string;
    /**
     * 
     * @type {string}
     * @memberof CreateMachineAgentDto
     */
    'machineManifestId': string;
    /**
     * 
     * @type {string}
     * @memberof CreateMachineAgentDto
     */
    'type': string;
    /**
     * 
     * @type {Array<object>}
     * @memberof CreateMachineAgentDto
     */
    'parameters': Array<object>;
    /**
     * 
     * @type {string}
     * @memberof CreateMachineAgentDto
     */
    'projectId': string;
    /**
     * 
     * @type {number}
     * @memberof CreateMachineAgentDto
     */
    'userId': number;
    /**
     * Optional Input Schema JSON for agent.
     * @type {object}
     * @memberof CreateMachineAgentDto
     */
    'inputSchema'?: object;
}
/**
 * 
 * @export
 * @interface CreatePermissionDto
 */
export interface CreatePermissionDto {
    /**
     * 
     * @type {boolean}
     * @memberof CreatePermissionDto
     */
    'read': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CreatePermissionDto
     */
    'write': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CreatePermissionDto
     */
    'update': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CreatePermissionDto
     */
    'delete': boolean;
}
/**
 * 
 * @export
 * @interface CreateProjectDTO
 */
export interface CreateProjectDTO {
    /**
     * 
     * @type {string}
     * @memberof CreateProjectDTO
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateProjectDTO
     */
    'description': string;
}
/**
 * 
 * @export
 * @interface CreateProjectResponseDTO
 */
export interface CreateProjectResponseDTO {
    /**
     * 
     * @type {ProjectResponseModel}
     * @memberof CreateProjectResponseDTO
     */
    'data': ProjectResponseModel;
}
/**
 * 
 * @export
 * @interface CreateProjectRoleResponseDto
 */
export interface CreateProjectRoleResponseDto {
    /**
     * 
     * @type {CreateRoleDTO}
     * @memberof CreateProjectRoleResponseDto
     */
    'data': CreateRoleDTO;
}
/**
 * 
 * @export
 * @interface CreateResourceDto
 */
export interface CreateResourceDto {
    /**
     * 
     * @type {string}
     * @memberof CreateResourceDto
     */
    'name': string;
    /**
     * 
     * @type {Array<CreatePermissionDto>}
     * @memberof CreateResourceDto
     */
    'permissions': Array<CreatePermissionDto>;
}
/**
 * 
 * @export
 * @interface CreateRoleDTO
 */
export interface CreateRoleDTO {
    /**
     * 
     * @type {number}
     * @memberof CreateRoleDTO
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof CreateRoleDTO
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateRoleDTO
     */
    'description': string;
    /**
     * 
     * @type {Array<ResourceDTO>}
     * @memberof CreateRoleDTO
     */
    'resources': Array<ResourceDTO>;
}
/**
 * 
 * @export
 * @interface CreateRoleDto
 */
export interface CreateRoleDto {
    /**
     * 
     * @type {string}
     * @memberof CreateRoleDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateRoleDto
     */
    'description': string;
    /**
     * 
     * @type {Array<CreateResourceDto>}
     * @memberof CreateRoleDto
     */
    'resources': Array<CreateResourceDto>;
}
/**
 * 
 * @export
 * @interface CreateWebhookDto
 */
export interface CreateWebhookDto {
    /**
     * The URL for the webhook
     * @type {string}
     * @memberof CreateWebhookDto
     */
    'url': string;
    /**
     * Comma-separated notifications. Valid values: QUERY_CREATED, QUERY_COMPLETED, QUERY_FAILED, EVENT_CREATED, EVENT_UPDATED
     * @type {string}
     * @memberof CreateWebhookDto
     */
    'notifications': string;
}
/**
 * 
 * @export
 * @interface DeleteProjectDto
 */
export interface DeleteProjectDto {
    /**
     * 
     * @type {string}
     * @memberof DeleteProjectDto
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface DeleteProjectResponseDTO
 */
export interface DeleteProjectResponseDTO {
    /**
     * 
     * @type {string}
     * @memberof DeleteProjectResponseDTO
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface DeleteProjectRoleByIdResponseDto
 */
export interface DeleteProjectRoleByIdResponseDto {
    /**
     * 
     * @type {DeleteProjectDto}
     * @memberof DeleteProjectRoleByIdResponseDto
     */
    'data': DeleteProjectDto;
}
/**
 * 
 * @export
 * @interface FatalErrorExceptionResponse
 */
export interface FatalErrorExceptionResponse {
    /**
     * 
     * @type {string}
     * @memberof FatalErrorExceptionResponse
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface ForbiddenExceptionResponse
 */
export interface ForbiddenExceptionResponse {
    /**
     * 
     * @type {string}
     * @memberof ForbiddenExceptionResponse
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface ForgetPasswordRequestDTO
 */
export interface ForgetPasswordRequestDTO {
    /**
     * 
     * @type {string}
     * @memberof ForgetPasswordRequestDTO
     */
    'email': string;
}
/**
 * 
 * @export
 * @interface ForgetPasswordResponseDTO
 */
export interface ForgetPasswordResponseDTO {
    /**
     * 
     * @type {string}
     * @memberof ForgetPasswordResponseDTO
     */
    'token': string;
}
/**
 * 
 * @export
 * @interface ForgetPasswordVerificationRequestDTO
 */
export interface ForgetPasswordVerificationRequestDTO {
    /**
     * 
     * @type {string}
     * @memberof ForgetPasswordVerificationRequestDTO
     */
    'token': string;
}
/**
 * 
 * @export
 * @interface ForgetPasswordVerificationResponseDTO
 */
export interface ForgetPasswordVerificationResponseDTO {
    /**
     * 
     * @type {string}
     * @memberof ForgetPasswordVerificationResponseDTO
     */
    'token': string;
}
/**
 * 
 * @export
 * @interface GetAllProjectDto
 */
export interface GetAllProjectDto {
    /**
     * 
     * @type {Array<GetAllRoleDTO>}
     * @memberof GetAllProjectDto
     */
    'roles': Array<GetAllRoleDTO>;
    /**
     * 
     * @type {number}
     * @memberof GetAllProjectDto
     */
    'totalCount': number;
}
/**
 * 
 * @export
 * @interface GetAllProjectMemberResponse
 */
export interface GetAllProjectMemberResponse {
    /**
     * 
     * @type {Array<TeamMemberDto>}
     * @memberof GetAllProjectMemberResponse
     */
    'teamMembers': Array<TeamMemberDto>;
    /**
     * 
     * @type {number}
     * @memberof GetAllProjectMemberResponse
     */
    'totalCount': number;
}
/**
 * 
 * @export
 * @interface GetAllProjectMemberResponseDto
 */
export interface GetAllProjectMemberResponseDto {
    /**
     * 
     * @type {GetAllProjectMemberResponse}
     * @memberof GetAllProjectMemberResponseDto
     */
    'data': GetAllProjectMemberResponse;
}
/**
 * 
 * @export
 * @interface GetAllProjectRoleResponseDto
 */
export interface GetAllProjectRoleResponseDto {
    /**
     * 
     * @type {GetAllProjectDto}
     * @memberof GetAllProjectRoleResponseDto
     */
    'data': GetAllProjectDto;
}
/**
 * 
 * @export
 * @interface GetAllProjectsResponseDTO
 */
export interface GetAllProjectsResponseDTO {
    /**
     * 
     * @type {AllProjectResponseModel}
     * @memberof GetAllProjectsResponseDTO
     */
    'data': AllProjectResponseModel;
}
/**
 * 
 * @export
 * @interface GetAllRoleDTO
 */
export interface GetAllRoleDTO {
    /**
     * 
     * @type {number}
     * @memberof GetAllRoleDTO
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof GetAllRoleDTO
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof GetAllRoleDTO
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof GetAllRoleDTO
     */
    'projectId': string;
    /**
     * 
     * @type {string}
     * @memberof GetAllRoleDTO
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof GetAllRoleDTO
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof GetAllRoleDTO
     */
    'deletedAt': string;
}
/**
 * 
 * @export
 * @interface GetProjectByIDResponseDTO
 */
export interface GetProjectByIDResponseDTO {
    /**
     * 
     * @type {ProjectResponseModel}
     * @memberof GetProjectByIDResponseDTO
     */
    'data': ProjectResponseModel;
}
/**
 * 
 * @export
 * @interface GetProjectRoleByIdResponseDto
 */
export interface GetProjectRoleByIdResponseDto {
    /**
     * 
     * @type {GetRoleDTO}
     * @memberof GetProjectRoleByIdResponseDto
     */
    'data': GetRoleDTO;
}
/**
 * 
 * @export
 * @interface GetRoleDTO
 */
export interface GetRoleDTO {
    /**
     * 
     * @type {number}
     * @memberof GetRoleDTO
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof GetRoleDTO
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof GetRoleDTO
     */
    'description': string;
    /**
     * 
     * @type {Array<ResourceDTO>}
     * @memberof GetRoleDTO
     */
    'resources': Array<ResourceDTO>;
}
/**
 * 
 * @export
 * @interface GetUserProjectRoleByRoleIdResponseDto
 */
export interface GetUserProjectRoleByRoleIdResponseDto {
    /**
     * 
     * @type {GetRoleDTO}
     * @memberof GetUserProjectRoleByRoleIdResponseDto
     */
    'data': GetRoleDTO;
}
/**
 * 
 * @export
 * @interface LoginRequestDTO
 */
export interface LoginRequestDTO {
    /**
     * Email
     * @type {string}
     * @memberof LoginRequestDTO
     */
    'email': string;
    /**
     * Password
     * @type {string}
     * @memberof LoginRequestDTO
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface LoginResponseDTO
 */
export interface LoginResponseDTO {
    /**
     * Token
     * @type {string}
     * @memberof LoginResponseDTO
     */
    'token': string;
}
/**
 * 
 * @export
 * @interface MachineStatusDto
 */
export interface MachineStatusDto {
    /**
     * Current status of the machine instance
     * @type {string}
     * @memberof MachineStatusDto
     */
    'status': string;
    /**
     * Logs from the machine instance execution
     * @type {string}
     * @memberof MachineStatusDto
     */
    'logs': string;
    /**
     * Timestamp of the status update
     * @type {string}
     * @memberof MachineStatusDto
     */
    'timeStamp': string;
}
/**
 * 
 * @export
 * @interface MessageResponseDTO
 */
export interface MessageResponseDTO {
    /**
     * 
     * @type {string}
     * @memberof MessageResponseDTO
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface NotFoundExceptionResponse
 */
export interface NotFoundExceptionResponse {
    /**
     * 
     * @type {string}
     * @memberof NotFoundExceptionResponse
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface OAuthLoginRequestDTO
 */
export interface OAuthLoginRequestDTO {
    /**
     * 
     * @type {string}
     * @memberof OAuthLoginRequestDTO
     */
    'providerId': string;
    /**
     * 
     * @type {string}
     * @memberof OAuthLoginRequestDTO
     */
    'type': OAuthLoginRequestDTOTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof OAuthLoginRequestDTO
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof OAuthLoginRequestDTO
     */
    'profilePictureUrl': string;
}

export const OAuthLoginRequestDTOTypeEnum = {
    Google: 'GOOGLE',
    Apple: 'APPLE'
} as const;

export type OAuthLoginRequestDTOTypeEnum = typeof OAuthLoginRequestDTOTypeEnum[keyof typeof OAuthLoginRequestDTOTypeEnum];

/**
 * 
 * @export
 * @interface PermissionsDTO
 */
export interface PermissionsDTO {
    /**
     * 
     * @type {number}
     * @memberof PermissionsDTO
     */
    'id': number;
    /**
     * 
     * @type {boolean}
     * @memberof PermissionsDTO
     */
    'read': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PermissionsDTO
     */
    'write': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PermissionsDTO
     */
    'update': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PermissionsDTO
     */
    'delete': boolean;
}
/**
 * 
 * @export
 * @interface ProjectResponseModel
 */
export interface ProjectResponseModel {
    /**
     * 
     * @type {string}
     * @memberof ProjectResponseModel
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ProjectResponseModel
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ProjectResponseModel
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof ProjectResponseModel
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof ProjectResponseModel
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof ProjectResponseModel
     */
    'deletedAt': string;
}
/**
 * 
 * @export
 * @interface ResetPasswordRequestDTO
 */
export interface ResetPasswordRequestDTO {
    /**
     * 
     * @type {string}
     * @memberof ResetPasswordRequestDTO
     */
    'token': string;
    /**
     * 
     * @type {string}
     * @memberof ResetPasswordRequestDTO
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface ResourceDTO
 */
export interface ResourceDTO {
    /**
     * 
     * @type {number}
     * @memberof ResourceDTO
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof ResourceDTO
     */
    'name': string;
    /**
     * 
     * @type {Array<PermissionsDTO>}
     * @memberof ResourceDTO
     */
    'permissions': Array<PermissionsDTO>;
}
/**
 * 
 * @export
 * @interface RoleDto
 */
export interface RoleDto {
    /**
     * 
     * @type {number}
     * @memberof RoleDto
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof RoleDto
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface SignupRequestDTO
 */
export interface SignupRequestDTO {
    /**
     * 
     * @type {string}
     * @memberof SignupRequestDTO
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof SignupRequestDTO
     */
    'password'?: string;
    /**
     * 
     * @type {string}
     * @memberof SignupRequestDTO
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof SignupRequestDTO
     */
    'lastName': string;
    /**
     * 
     * @type {string}
     * @memberof SignupRequestDTO
     */
    'phone': string;
    /**
     * 
     * @type {string}
     * @memberof SignupRequestDTO
     */
    'providerId'?: string;
    /**
     * 
     * @type {string}
     * @memberof SignupRequestDTO
     */
    'providerType'?: SignupRequestDTOProviderTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof SignupRequestDTO
     */
    'image'?: string;
    /**
     * 
     * @type {string}
     * @memberof SignupRequestDTO
     */
    'profilePictureUrl': string;
}

export const SignupRequestDTOProviderTypeEnum = {
    Google: 'GOOGLE',
    Apple: 'APPLE'
} as const;

export type SignupRequestDTOProviderTypeEnum = typeof SignupRequestDTOProviderTypeEnum[keyof typeof SignupRequestDTOProviderTypeEnum];

/**
 * 
 * @export
 * @interface SignupResponseDTO
 */
export interface SignupResponseDTO {
    /**
     * Token
     * @type {string}
     * @memberof SignupResponseDTO
     */
    'token': string;
}
/**
 * 
 * @export
 * @interface SimilaritySearchQueryDTO
 */
export interface SimilaritySearchQueryDTO {
    /**
     * 
     * @type {string}
     * @memberof SimilaritySearchQueryDTO
     */
    'query': string;
    /**
     * 
     * @type {object}
     * @memberof SimilaritySearchQueryDTO
     */
    'params': object;
    /**
     * 
     * @type {object}
     * @memberof SimilaritySearchQueryDTO
     */
    'filter': object;
    /**
     * 
     * @type {Array<string>}
     * @memberof SimilaritySearchQueryDTO
     */
    'include': Array<string>;
}
/**
 * 
 * @export
 * @interface TeamMemberDto
 */
export interface TeamMemberDto {
    /**
     * 
     * @type {number}
     * @memberof TeamMemberDto
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof TeamMemberDto
     */
    'status': string;
    /**
     * 
     * @type {UserDto}
     * @memberof TeamMemberDto
     */
    'user': UserDto;
    /**
     * 
     * @type {RoleDto}
     * @memberof TeamMemberDto
     */
    'role': RoleDto;
}
/**
 * 
 * @export
 * @interface UnauthorizedExceptionResponse
 */
export interface UnauthorizedExceptionResponse {
    /**
     * 
     * @type {string}
     * @memberof UnauthorizedExceptionResponse
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface UpdateDocumentRequestDTO
 */
export interface UpdateDocumentRequestDTO {
    /**
     * 
     * @type {string}
     * @memberof UpdateDocumentRequestDTO
     */
    'document': string;
    /**
     * 
     * @type {object}
     * @memberof UpdateDocumentRequestDTO
     */
    'metadata': object;
}
/**
 * 
 * @export
 * @interface UpdatePermissionDto
 */
export interface UpdatePermissionDto {
    /**
     * 
     * @type {number}
     * @memberof UpdatePermissionDto
     */
    'id': number;
    /**
     * 
     * @type {boolean}
     * @memberof UpdatePermissionDto
     */
    'read': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UpdatePermissionDto
     */
    'write': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UpdatePermissionDto
     */
    'update': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UpdatePermissionDto
     */
    'delete': boolean;
}
/**
 * 
 * @export
 * @interface UpdateProjectByIDResponseDTO
 */
export interface UpdateProjectByIDResponseDTO {
    /**
     * 
     * @type {ProjectResponseModel}
     * @memberof UpdateProjectByIDResponseDTO
     */
    'data': ProjectResponseModel;
}
/**
 * 
 * @export
 * @interface UpdateProjectByIdRequest
 */
export interface UpdateProjectByIdRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateProjectByIdRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateProjectByIdRequest
     */
    'description': string;
}
/**
 * 
 * @export
 * @interface UpdateProjectRoleResponseDto
 */
export interface UpdateProjectRoleResponseDto {
    /**
     * 
     * @type {UpdateRoleDTO}
     * @memberof UpdateProjectRoleResponseDto
     */
    'data': UpdateRoleDTO;
}
/**
 * 
 * @export
 * @interface UpdateResourceDto
 */
export interface UpdateResourceDto {
    /**
     * 
     * @type {number}
     * @memberof UpdateResourceDto
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof UpdateResourceDto
     */
    'name': string;
    /**
     * 
     * @type {Array<UpdatePermissionDto>}
     * @memberof UpdateResourceDto
     */
    'permissions': Array<UpdatePermissionDto>;
}
/**
 * 
 * @export
 * @interface UpdateRoleByIdDto
 */
export interface UpdateRoleByIdDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateRoleByIdDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateRoleByIdDto
     */
    'description': string;
    /**
     * 
     * @type {Array<UpdateResourceDto>}
     * @memberof UpdateRoleByIdDto
     */
    'resources': Array<UpdateResourceDto>;
}
/**
 * 
 * @export
 * @interface UpdateRoleDTO
 */
export interface UpdateRoleDTO {
    /**
     * 
     * @type {number}
     * @memberof UpdateRoleDTO
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof UpdateRoleDTO
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateRoleDTO
     */
    'description': string;
    /**
     * 
     * @type {Array<ResourceDTO>}
     * @memberof UpdateRoleDTO
     */
    'resources': Array<ResourceDTO>;
}
/**
 * 
 * @export
 * @interface UpdateTeamMemberRequestDTO
 */
export interface UpdateTeamMemberRequestDTO {
    /**
     * 
     * @type {number}
     * @memberof UpdateTeamMemberRequestDTO
     */
    'roleId': number;
}
/**
 * 
 * @export
 * @interface UpdateTeamMemberStatusRequestDTO
 */
export interface UpdateTeamMemberStatusRequestDTO {
    /**
     * 
     * @type {string}
     * @memberof UpdateTeamMemberStatusRequestDTO
     */
    'status': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateTeamMemberStatusRequestDTO
     */
    'token': string;
}
/**
 * 
 * @export
 * @interface UserDto
 */
export interface UserDto {
    /**
     * 
     * @type {number}
     * @memberof UserDto
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof UserDto
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof UserDto
     */
    'lastName': string;
    /**
     * 
     * @type {string}
     * @memberof UserDto
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof UserDto
     */
    'status': string;
    /**
     * 
     * @type {string}
     * @memberof UserDto
     */
    'profilePicture': string;
    /**
     * 
     * @type {string}
     * @memberof UserDto
     */
    'bio': string;
}

/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Exchange token
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerExchangeToken: async (token: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('authControllerExchangeToken', 'token', token)
            const localVarPath = `/auth/google/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Forget password initiate
         * @param {ForgetPasswordRequestDTO} forgetPasswordRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerForgetPassword: async (forgetPasswordRequestDTO: ForgetPasswordRequestDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'forgetPasswordRequestDTO' is not null or undefined
            assertParamExists('authControllerForgetPassword', 'forgetPasswordRequestDTO', forgetPasswordRequestDTO)
            const localVarPath = `/auth/forget-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(forgetPasswordRequestDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Forget password verification
         * @param {ForgetPasswordVerificationRequestDTO} forgetPasswordVerificationRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerForgetPasswordVerification: async (forgetPasswordVerificationRequestDTO: ForgetPasswordVerificationRequestDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'forgetPasswordVerificationRequestDTO' is not null or undefined
            assertParamExists('authControllerForgetPasswordVerification', 'forgetPasswordVerificationRequestDTO', forgetPasswordVerificationRequestDTO)
            const localVarPath = `/auth/forget-password/verification`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(forgetPasswordVerificationRequestDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Login to the application
         * @param {LoginRequestDTO} loginRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerLogin: async (loginRequestDTO: LoginRequestDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginRequestDTO' is not null or undefined
            assertParamExists('authControllerLogin', 'loginRequestDTO', loginRequestDTO)
            const localVarPath = `/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginRequestDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Login with OAuth apps
         * @param {OAuthLoginRequestDTO} oAuthLoginRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerOAuthLogin: async (oAuthLoginRequestDTO: OAuthLoginRequestDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'oAuthLoginRequestDTO' is not null or undefined
            assertParamExists('authControllerOAuthLogin', 'oAuthLoginRequestDTO', oAuthLoginRequestDTO)
            const localVarPath = `/auth/login/oauth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(oAuthLoginRequestDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Forget password initiate
         * @param {ResetPasswordRequestDTO} resetPasswordRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerResetPassword: async (resetPasswordRequestDTO: ResetPasswordRequestDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'resetPasswordRequestDTO' is not null or undefined
            assertParamExists('authControllerResetPassword', 'resetPasswordRequestDTO', resetPasswordRequestDTO)
            const localVarPath = `/auth/reset-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(resetPasswordRequestDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Signup in the application
         * @param {SignupRequestDTO} signupRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerSignup: async (signupRequestDTO: SignupRequestDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'signupRequestDTO' is not null or undefined
            assertParamExists('authControllerSignup', 'signupRequestDTO', signupRequestDTO)
            const localVarPath = `/auth/signup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(signupRequestDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Exchange token
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerExchangeToken(token: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerExchangeToken(token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authControllerExchangeToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Forget password initiate
         * @param {ForgetPasswordRequestDTO} forgetPasswordRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerForgetPassword(forgetPasswordRequestDTO: ForgetPasswordRequestDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ForgetPasswordResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerForgetPassword(forgetPasswordRequestDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authControllerForgetPassword']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Forget password verification
         * @param {ForgetPasswordVerificationRequestDTO} forgetPasswordVerificationRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerForgetPasswordVerification(forgetPasswordVerificationRequestDTO: ForgetPasswordVerificationRequestDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ForgetPasswordVerificationResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerForgetPasswordVerification(forgetPasswordVerificationRequestDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authControllerForgetPasswordVerification']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Login to the application
         * @param {LoginRequestDTO} loginRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerLogin(loginRequestDTO: LoginRequestDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerLogin(loginRequestDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authControllerLogin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Login with OAuth apps
         * @param {OAuthLoginRequestDTO} oAuthLoginRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerOAuthLogin(oAuthLoginRequestDTO: OAuthLoginRequestDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerOAuthLogin(oAuthLoginRequestDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authControllerOAuthLogin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Forget password initiate
         * @param {ResetPasswordRequestDTO} resetPasswordRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerResetPassword(resetPasswordRequestDTO: ResetPasswordRequestDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BooleanResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerResetPassword(resetPasswordRequestDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authControllerResetPassword']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Signup in the application
         * @param {SignupRequestDTO} signupRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerSignup(signupRequestDTO: SignupRequestDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SignupResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerSignup(signupRequestDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authControllerSignup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * 
         * @summary Exchange token
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerExchangeToken(token: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.authControllerExchangeToken(token, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Forget password initiate
         * @param {ForgetPasswordRequestDTO} forgetPasswordRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerForgetPassword(forgetPasswordRequestDTO: ForgetPasswordRequestDTO, options?: RawAxiosRequestConfig): AxiosPromise<ForgetPasswordResponseDTO> {
            return localVarFp.authControllerForgetPassword(forgetPasswordRequestDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Forget password verification
         * @param {ForgetPasswordVerificationRequestDTO} forgetPasswordVerificationRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerForgetPasswordVerification(forgetPasswordVerificationRequestDTO: ForgetPasswordVerificationRequestDTO, options?: RawAxiosRequestConfig): AxiosPromise<ForgetPasswordVerificationResponseDTO> {
            return localVarFp.authControllerForgetPasswordVerification(forgetPasswordVerificationRequestDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Login to the application
         * @param {LoginRequestDTO} loginRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerLogin(loginRequestDTO: LoginRequestDTO, options?: RawAxiosRequestConfig): AxiosPromise<LoginResponseDTO> {
            return localVarFp.authControllerLogin(loginRequestDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Login with OAuth apps
         * @param {OAuthLoginRequestDTO} oAuthLoginRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerOAuthLogin(oAuthLoginRequestDTO: OAuthLoginRequestDTO, options?: RawAxiosRequestConfig): AxiosPromise<LoginResponseDTO> {
            return localVarFp.authControllerOAuthLogin(oAuthLoginRequestDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Forget password initiate
         * @param {ResetPasswordRequestDTO} resetPasswordRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerResetPassword(resetPasswordRequestDTO: ResetPasswordRequestDTO, options?: RawAxiosRequestConfig): AxiosPromise<BooleanResponseDTO> {
            return localVarFp.authControllerResetPassword(resetPasswordRequestDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Signup in the application
         * @param {SignupRequestDTO} signupRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerSignup(signupRequestDTO: SignupRequestDTO, options?: RawAxiosRequestConfig): AxiosPromise<SignupResponseDTO> {
            return localVarFp.authControllerSignup(signupRequestDTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * 
     * @summary Exchange token
     * @param {string} token 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerExchangeToken(token: string, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerExchangeToken(token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Forget password initiate
     * @param {ForgetPasswordRequestDTO} forgetPasswordRequestDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerForgetPassword(forgetPasswordRequestDTO: ForgetPasswordRequestDTO, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerForgetPassword(forgetPasswordRequestDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Forget password verification
     * @param {ForgetPasswordVerificationRequestDTO} forgetPasswordVerificationRequestDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerForgetPasswordVerification(forgetPasswordVerificationRequestDTO: ForgetPasswordVerificationRequestDTO, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerForgetPasswordVerification(forgetPasswordVerificationRequestDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Login to the application
     * @param {LoginRequestDTO} loginRequestDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerLogin(loginRequestDTO: LoginRequestDTO, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerLogin(loginRequestDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Login with OAuth apps
     * @param {OAuthLoginRequestDTO} oAuthLoginRequestDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerOAuthLogin(oAuthLoginRequestDTO: OAuthLoginRequestDTO, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerOAuthLogin(oAuthLoginRequestDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Forget password initiate
     * @param {ResetPasswordRequestDTO} resetPasswordRequestDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerResetPassword(resetPasswordRequestDTO: ResetPasswordRequestDTO, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerResetPassword(resetPasswordRequestDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Signup in the application
     * @param {SignupRequestDTO} signupRequestDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerSignup(signupRequestDTO: SignupRequestDTO, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerSignup(signupRequestDTO, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DocumentsApi - axios parameter creator
 * @export
 */
export const DocumentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add a new doc
         * @param {string} projectId 
         * @param {string} instanceId 
         * @param {string} collectionId 
         * @param {CreateDocumentRequestDTO} createDocumentRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentControllerAddDocToCollection: async (projectId: string, instanceId: string, collectionId: string, createDocumentRequestDTO: CreateDocumentRequestDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('documentControllerAddDocToCollection', 'projectId', projectId)
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('documentControllerAddDocToCollection', 'instanceId', instanceId)
            // verify required parameter 'collectionId' is not null or undefined
            assertParamExists('documentControllerAddDocToCollection', 'collectionId', collectionId)
            // verify required parameter 'createDocumentRequestDTO' is not null or undefined
            assertParamExists('documentControllerAddDocToCollection', 'createDocumentRequestDTO', createDocumentRequestDTO)
            const localVarPath = `/projects/{projectId}/document/{instanceId}/collections/{collectionId}/docs`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)))
                .replace(`{${"collectionId"}}`, encodeURIComponent(String(collectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createDocumentRequestDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Use a file to chunk and add to collection
         * @param {string} projectId 
         * @param {string} instanceId 
         * @param {string} collectionId 
         * @param {ChunkFileRequestDTO} chunkFileRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentControllerAddDocToCollectionFromFile: async (projectId: string, instanceId: string, collectionId: string, chunkFileRequestDTO: ChunkFileRequestDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('documentControllerAddDocToCollectionFromFile', 'projectId', projectId)
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('documentControllerAddDocToCollectionFromFile', 'instanceId', instanceId)
            // verify required parameter 'collectionId' is not null or undefined
            assertParamExists('documentControllerAddDocToCollectionFromFile', 'collectionId', collectionId)
            // verify required parameter 'chunkFileRequestDTO' is not null or undefined
            assertParamExists('documentControllerAddDocToCollectionFromFile', 'chunkFileRequestDTO', chunkFileRequestDTO)
            const localVarPath = `/projects/{projectId}/document/{instanceId}/collections/{collectionId}/docs/file`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)))
                .replace(`{${"collectionId"}}`, encodeURIComponent(String(collectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(chunkFileRequestDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create collection
         * @param {string} projectId 
         * @param {string} instanceId 
         * @param {CreateCollectionRequestDTO} createCollectionRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentControllerCreateCollection: async (projectId: string, instanceId: string, createCollectionRequestDTO: CreateCollectionRequestDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('documentControllerCreateCollection', 'projectId', projectId)
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('documentControllerCreateCollection', 'instanceId', instanceId)
            // verify required parameter 'createCollectionRequestDTO' is not null or undefined
            assertParamExists('documentControllerCreateCollection', 'createCollectionRequestDTO', createCollectionRequestDTO)
            const localVarPath = `/projects/{projectId}/document/{instanceId}/collections`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createCollectionRequestDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete collection
         * @param {string} projectId 
         * @param {string} instanceId 
         * @param {string} collectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentControllerDeleteCollection: async (projectId: string, instanceId: string, collectionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('documentControllerDeleteCollection', 'projectId', projectId)
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('documentControllerDeleteCollection', 'instanceId', instanceId)
            // verify required parameter 'collectionId' is not null or undefined
            assertParamExists('documentControllerDeleteCollection', 'collectionId', collectionId)
            const localVarPath = `/projects/{projectId}/document/{instanceId}/collections/{collectionId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)))
                .replace(`{${"collectionId"}}`, encodeURIComponent(String(collectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete doc by ID
         * @param {string} projectId 
         * @param {string} instanceId 
         * @param {string} collectionId 
         * @param {string} docId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentControllerDeleteDocById: async (projectId: string, instanceId: string, collectionId: string, docId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('documentControllerDeleteDocById', 'projectId', projectId)
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('documentControllerDeleteDocById', 'instanceId', instanceId)
            // verify required parameter 'collectionId' is not null or undefined
            assertParamExists('documentControllerDeleteDocById', 'collectionId', collectionId)
            // verify required parameter 'docId' is not null or undefined
            assertParamExists('documentControllerDeleteDocById', 'docId', docId)
            const localVarPath = `/projects/{projectId}/document/{instanceId}/collections/{collectionId}/docs/{docId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)))
                .replace(`{${"collectionId"}}`, encodeURIComponent(String(collectionId)))
                .replace(`{${"docId"}}`, encodeURIComponent(String(docId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete docs based on metadata filters
         * @param {string} projectId 
         * @param {string} instanceId 
         * @param {string} collectionId 
         * @param {string} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentControllerDeleteDocsFromCollection: async (projectId: string, instanceId: string, collectionId: string, filter: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('documentControllerDeleteDocsFromCollection', 'projectId', projectId)
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('documentControllerDeleteDocsFromCollection', 'instanceId', instanceId)
            // verify required parameter 'collectionId' is not null or undefined
            assertParamExists('documentControllerDeleteDocsFromCollection', 'collectionId', collectionId)
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('documentControllerDeleteDocsFromCollection', 'filter', filter)
            const localVarPath = `/projects/{projectId}/document/{instanceId}/collections/{collectionId}/docs`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)))
                .replace(`{${"collectionId"}}`, encodeURIComponent(String(collectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all collections
         * @param {string} projectId 
         * @param {string} instanceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentControllerGetAllCollections: async (projectId: string, instanceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('documentControllerGetAllCollections', 'projectId', projectId)
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('documentControllerGetAllCollections', 'instanceId', instanceId)
            const localVarPath = `/projects/{projectId}/document/{instanceId}/collections`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get collection info
         * @param {string} projectId 
         * @param {string} instanceId 
         * @param {string} collectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentControllerGetCollectionInfo: async (projectId: string, instanceId: string, collectionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('documentControllerGetCollectionInfo', 'projectId', projectId)
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('documentControllerGetCollectionInfo', 'instanceId', instanceId)
            // verify required parameter 'collectionId' is not null or undefined
            assertParamExists('documentControllerGetCollectionInfo', 'collectionId', collectionId)
            const localVarPath = `/projects/{projectId}/document/{instanceId}/collections/{collectionId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)))
                .replace(`{${"collectionId"}}`, encodeURIComponent(String(collectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get doc by ID
         * @param {string} projectId 
         * @param {string} instanceId 
         * @param {string} collectionId 
         * @param {string} docId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentControllerGetDocById: async (projectId: string, instanceId: string, collectionId: string, docId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('documentControllerGetDocById', 'projectId', projectId)
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('documentControllerGetDocById', 'instanceId', instanceId)
            // verify required parameter 'collectionId' is not null or undefined
            assertParamExists('documentControllerGetDocById', 'collectionId', collectionId)
            // verify required parameter 'docId' is not null or undefined
            assertParamExists('documentControllerGetDocById', 'docId', docId)
            const localVarPath = `/projects/{projectId}/document/{instanceId}/collections/{collectionId}/docs/{docId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)))
                .replace(`{${"collectionId"}}`, encodeURIComponent(String(collectionId)))
                .replace(`{${"docId"}}`, encodeURIComponent(String(docId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Similarity search query
         * @param {string} projectId 
         * @param {string} instanceId 
         * @param {string} collectionId 
         * @param {SimilaritySearchQueryDTO} similaritySearchQueryDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentControllerSimilaritySearch: async (projectId: string, instanceId: string, collectionId: string, similaritySearchQueryDTO: SimilaritySearchQueryDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('documentControllerSimilaritySearch', 'projectId', projectId)
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('documentControllerSimilaritySearch', 'instanceId', instanceId)
            // verify required parameter 'collectionId' is not null or undefined
            assertParamExists('documentControllerSimilaritySearch', 'collectionId', collectionId)
            // verify required parameter 'similaritySearchQueryDTO' is not null or undefined
            assertParamExists('documentControllerSimilaritySearch', 'similaritySearchQueryDTO', similaritySearchQueryDTO)
            const localVarPath = `/projects/{projectId}/document/{instanceId}/collections/{collectionId}/query`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)))
                .replace(`{${"collectionId"}}`, encodeURIComponent(String(collectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(similaritySearchQueryDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update collection
         * @param {string} projectId 
         * @param {string} instanceId 
         * @param {string} collectionId 
         * @param {CreateCollectionRequestDTO} createCollectionRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentControllerUpdateCollection: async (projectId: string, instanceId: string, collectionId: string, createCollectionRequestDTO: CreateCollectionRequestDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('documentControllerUpdateCollection', 'projectId', projectId)
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('documentControllerUpdateCollection', 'instanceId', instanceId)
            // verify required parameter 'collectionId' is not null or undefined
            assertParamExists('documentControllerUpdateCollection', 'collectionId', collectionId)
            // verify required parameter 'createCollectionRequestDTO' is not null or undefined
            assertParamExists('documentControllerUpdateCollection', 'createCollectionRequestDTO', createCollectionRequestDTO)
            const localVarPath = `/projects/{projectId}/document/{instanceId}/collections/{collectionId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)))
                .replace(`{${"collectionId"}}`, encodeURIComponent(String(collectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createCollectionRequestDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update or upsert doc
         * @param {string} projectId 
         * @param {string} instanceId 
         * @param {string} collectionId 
         * @param {string} docId 
         * @param {UpdateDocumentRequestDTO} updateDocumentRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentControllerUpdateDoc: async (projectId: string, instanceId: string, collectionId: string, docId: string, updateDocumentRequestDTO: UpdateDocumentRequestDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('documentControllerUpdateDoc', 'projectId', projectId)
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('documentControllerUpdateDoc', 'instanceId', instanceId)
            // verify required parameter 'collectionId' is not null or undefined
            assertParamExists('documentControllerUpdateDoc', 'collectionId', collectionId)
            // verify required parameter 'docId' is not null or undefined
            assertParamExists('documentControllerUpdateDoc', 'docId', docId)
            // verify required parameter 'updateDocumentRequestDTO' is not null or undefined
            assertParamExists('documentControllerUpdateDoc', 'updateDocumentRequestDTO', updateDocumentRequestDTO)
            const localVarPath = `/projects/{projectId}/document/{instanceId}/collections/{collectionId}/docs/{docId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)))
                .replace(`{${"collectionId"}}`, encodeURIComponent(String(collectionId)))
                .replace(`{${"docId"}}`, encodeURIComponent(String(docId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateDocumentRequestDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DocumentsApi - functional programming interface
 * @export
 */
export const DocumentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DocumentsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add a new doc
         * @param {string} projectId 
         * @param {string} instanceId 
         * @param {string} collectionId 
         * @param {CreateDocumentRequestDTO} createDocumentRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentControllerAddDocToCollection(projectId: string, instanceId: string, collectionId: string, createDocumentRequestDTO: CreateDocumentRequestDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentControllerAddDocToCollection(projectId, instanceId, collectionId, createDocumentRequestDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.documentControllerAddDocToCollection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Use a file to chunk and add to collection
         * @param {string} projectId 
         * @param {string} instanceId 
         * @param {string} collectionId 
         * @param {ChunkFileRequestDTO} chunkFileRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentControllerAddDocToCollectionFromFile(projectId: string, instanceId: string, collectionId: string, chunkFileRequestDTO: ChunkFileRequestDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentControllerAddDocToCollectionFromFile(projectId, instanceId, collectionId, chunkFileRequestDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.documentControllerAddDocToCollectionFromFile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create collection
         * @param {string} projectId 
         * @param {string} instanceId 
         * @param {CreateCollectionRequestDTO} createCollectionRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentControllerCreateCollection(projectId: string, instanceId: string, createCollectionRequestDTO: CreateCollectionRequestDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentControllerCreateCollection(projectId, instanceId, createCollectionRequestDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.documentControllerCreateCollection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete collection
         * @param {string} projectId 
         * @param {string} instanceId 
         * @param {string} collectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentControllerDeleteCollection(projectId: string, instanceId: string, collectionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentControllerDeleteCollection(projectId, instanceId, collectionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.documentControllerDeleteCollection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete doc by ID
         * @param {string} projectId 
         * @param {string} instanceId 
         * @param {string} collectionId 
         * @param {string} docId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentControllerDeleteDocById(projectId: string, instanceId: string, collectionId: string, docId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentControllerDeleteDocById(projectId, instanceId, collectionId, docId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.documentControllerDeleteDocById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete docs based on metadata filters
         * @param {string} projectId 
         * @param {string} instanceId 
         * @param {string} collectionId 
         * @param {string} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentControllerDeleteDocsFromCollection(projectId: string, instanceId: string, collectionId: string, filter: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentControllerDeleteDocsFromCollection(projectId, instanceId, collectionId, filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.documentControllerDeleteDocsFromCollection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all collections
         * @param {string} projectId 
         * @param {string} instanceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentControllerGetAllCollections(projectId: string, instanceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentControllerGetAllCollections(projectId, instanceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.documentControllerGetAllCollections']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get collection info
         * @param {string} projectId 
         * @param {string} instanceId 
         * @param {string} collectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentControllerGetCollectionInfo(projectId: string, instanceId: string, collectionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentControllerGetCollectionInfo(projectId, instanceId, collectionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.documentControllerGetCollectionInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get doc by ID
         * @param {string} projectId 
         * @param {string} instanceId 
         * @param {string} collectionId 
         * @param {string} docId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentControllerGetDocById(projectId: string, instanceId: string, collectionId: string, docId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentControllerGetDocById(projectId, instanceId, collectionId, docId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.documentControllerGetDocById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Similarity search query
         * @param {string} projectId 
         * @param {string} instanceId 
         * @param {string} collectionId 
         * @param {SimilaritySearchQueryDTO} similaritySearchQueryDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentControllerSimilaritySearch(projectId: string, instanceId: string, collectionId: string, similaritySearchQueryDTO: SimilaritySearchQueryDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentControllerSimilaritySearch(projectId, instanceId, collectionId, similaritySearchQueryDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.documentControllerSimilaritySearch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update collection
         * @param {string} projectId 
         * @param {string} instanceId 
         * @param {string} collectionId 
         * @param {CreateCollectionRequestDTO} createCollectionRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentControllerUpdateCollection(projectId: string, instanceId: string, collectionId: string, createCollectionRequestDTO: CreateCollectionRequestDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentControllerUpdateCollection(projectId, instanceId, collectionId, createCollectionRequestDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.documentControllerUpdateCollection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update or upsert doc
         * @param {string} projectId 
         * @param {string} instanceId 
         * @param {string} collectionId 
         * @param {string} docId 
         * @param {UpdateDocumentRequestDTO} updateDocumentRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentControllerUpdateDoc(projectId: string, instanceId: string, collectionId: string, docId: string, updateDocumentRequestDTO: UpdateDocumentRequestDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentControllerUpdateDoc(projectId, instanceId, collectionId, docId, updateDocumentRequestDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.documentControllerUpdateDoc']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DocumentsApi - factory interface
 * @export
 */
export const DocumentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DocumentsApiFp(configuration)
    return {
        /**
         * 
         * @summary Add a new doc
         * @param {string} projectId 
         * @param {string} instanceId 
         * @param {string} collectionId 
         * @param {CreateDocumentRequestDTO} createDocumentRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentControllerAddDocToCollection(projectId: string, instanceId: string, collectionId: string, createDocumentRequestDTO: CreateDocumentRequestDTO, options?: RawAxiosRequestConfig): AxiosPromise<MessageResponseDTO> {
            return localVarFp.documentControllerAddDocToCollection(projectId, instanceId, collectionId, createDocumentRequestDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Use a file to chunk and add to collection
         * @param {string} projectId 
         * @param {string} instanceId 
         * @param {string} collectionId 
         * @param {ChunkFileRequestDTO} chunkFileRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentControllerAddDocToCollectionFromFile(projectId: string, instanceId: string, collectionId: string, chunkFileRequestDTO: ChunkFileRequestDTO, options?: RawAxiosRequestConfig): AxiosPromise<MessageResponseDTO> {
            return localVarFp.documentControllerAddDocToCollectionFromFile(projectId, instanceId, collectionId, chunkFileRequestDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create collection
         * @param {string} projectId 
         * @param {string} instanceId 
         * @param {CreateCollectionRequestDTO} createCollectionRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentControllerCreateCollection(projectId: string, instanceId: string, createCollectionRequestDTO: CreateCollectionRequestDTO, options?: RawAxiosRequestConfig): AxiosPromise<MessageResponseDTO> {
            return localVarFp.documentControllerCreateCollection(projectId, instanceId, createCollectionRequestDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete collection
         * @param {string} projectId 
         * @param {string} instanceId 
         * @param {string} collectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentControllerDeleteCollection(projectId: string, instanceId: string, collectionId: string, options?: RawAxiosRequestConfig): AxiosPromise<MessageResponseDTO> {
            return localVarFp.documentControllerDeleteCollection(projectId, instanceId, collectionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete doc by ID
         * @param {string} projectId 
         * @param {string} instanceId 
         * @param {string} collectionId 
         * @param {string} docId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentControllerDeleteDocById(projectId: string, instanceId: string, collectionId: string, docId: string, options?: RawAxiosRequestConfig): AxiosPromise<MessageResponseDTO> {
            return localVarFp.documentControllerDeleteDocById(projectId, instanceId, collectionId, docId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete docs based on metadata filters
         * @param {string} projectId 
         * @param {string} instanceId 
         * @param {string} collectionId 
         * @param {string} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentControllerDeleteDocsFromCollection(projectId: string, instanceId: string, collectionId: string, filter: string, options?: RawAxiosRequestConfig): AxiosPromise<MessageResponseDTO> {
            return localVarFp.documentControllerDeleteDocsFromCollection(projectId, instanceId, collectionId, filter, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all collections
         * @param {string} projectId 
         * @param {string} instanceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentControllerGetAllCollections(projectId: string, instanceId: string, options?: RawAxiosRequestConfig): AxiosPromise<MessageResponseDTO> {
            return localVarFp.documentControllerGetAllCollections(projectId, instanceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get collection info
         * @param {string} projectId 
         * @param {string} instanceId 
         * @param {string} collectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentControllerGetCollectionInfo(projectId: string, instanceId: string, collectionId: string, options?: RawAxiosRequestConfig): AxiosPromise<MessageResponseDTO> {
            return localVarFp.documentControllerGetCollectionInfo(projectId, instanceId, collectionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get doc by ID
         * @param {string} projectId 
         * @param {string} instanceId 
         * @param {string} collectionId 
         * @param {string} docId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentControllerGetDocById(projectId: string, instanceId: string, collectionId: string, docId: string, options?: RawAxiosRequestConfig): AxiosPromise<MessageResponseDTO> {
            return localVarFp.documentControllerGetDocById(projectId, instanceId, collectionId, docId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Similarity search query
         * @param {string} projectId 
         * @param {string} instanceId 
         * @param {string} collectionId 
         * @param {SimilaritySearchQueryDTO} similaritySearchQueryDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentControllerSimilaritySearch(projectId: string, instanceId: string, collectionId: string, similaritySearchQueryDTO: SimilaritySearchQueryDTO, options?: RawAxiosRequestConfig): AxiosPromise<MessageResponseDTO> {
            return localVarFp.documentControllerSimilaritySearch(projectId, instanceId, collectionId, similaritySearchQueryDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update collection
         * @param {string} projectId 
         * @param {string} instanceId 
         * @param {string} collectionId 
         * @param {CreateCollectionRequestDTO} createCollectionRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentControllerUpdateCollection(projectId: string, instanceId: string, collectionId: string, createCollectionRequestDTO: CreateCollectionRequestDTO, options?: RawAxiosRequestConfig): AxiosPromise<MessageResponseDTO> {
            return localVarFp.documentControllerUpdateCollection(projectId, instanceId, collectionId, createCollectionRequestDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update or upsert doc
         * @param {string} projectId 
         * @param {string} instanceId 
         * @param {string} collectionId 
         * @param {string} docId 
         * @param {UpdateDocumentRequestDTO} updateDocumentRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentControllerUpdateDoc(projectId: string, instanceId: string, collectionId: string, docId: string, updateDocumentRequestDTO: UpdateDocumentRequestDTO, options?: RawAxiosRequestConfig): AxiosPromise<MessageResponseDTO> {
            return localVarFp.documentControllerUpdateDoc(projectId, instanceId, collectionId, docId, updateDocumentRequestDTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DocumentsApi - object-oriented interface
 * @export
 * @class DocumentsApi
 * @extends {BaseAPI}
 */
export class DocumentsApi extends BaseAPI {
    /**
     * 
     * @summary Add a new doc
     * @param {string} projectId 
     * @param {string} instanceId 
     * @param {string} collectionId 
     * @param {CreateDocumentRequestDTO} createDocumentRequestDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentControllerAddDocToCollection(projectId: string, instanceId: string, collectionId: string, createDocumentRequestDTO: CreateDocumentRequestDTO, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentControllerAddDocToCollection(projectId, instanceId, collectionId, createDocumentRequestDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Use a file to chunk and add to collection
     * @param {string} projectId 
     * @param {string} instanceId 
     * @param {string} collectionId 
     * @param {ChunkFileRequestDTO} chunkFileRequestDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentControllerAddDocToCollectionFromFile(projectId: string, instanceId: string, collectionId: string, chunkFileRequestDTO: ChunkFileRequestDTO, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentControllerAddDocToCollectionFromFile(projectId, instanceId, collectionId, chunkFileRequestDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create collection
     * @param {string} projectId 
     * @param {string} instanceId 
     * @param {CreateCollectionRequestDTO} createCollectionRequestDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentControllerCreateCollection(projectId: string, instanceId: string, createCollectionRequestDTO: CreateCollectionRequestDTO, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentControllerCreateCollection(projectId, instanceId, createCollectionRequestDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete collection
     * @param {string} projectId 
     * @param {string} instanceId 
     * @param {string} collectionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentControllerDeleteCollection(projectId: string, instanceId: string, collectionId: string, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentControllerDeleteCollection(projectId, instanceId, collectionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete doc by ID
     * @param {string} projectId 
     * @param {string} instanceId 
     * @param {string} collectionId 
     * @param {string} docId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentControllerDeleteDocById(projectId: string, instanceId: string, collectionId: string, docId: string, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentControllerDeleteDocById(projectId, instanceId, collectionId, docId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete docs based on metadata filters
     * @param {string} projectId 
     * @param {string} instanceId 
     * @param {string} collectionId 
     * @param {string} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentControllerDeleteDocsFromCollection(projectId: string, instanceId: string, collectionId: string, filter: string, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentControllerDeleteDocsFromCollection(projectId, instanceId, collectionId, filter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all collections
     * @param {string} projectId 
     * @param {string} instanceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentControllerGetAllCollections(projectId: string, instanceId: string, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentControllerGetAllCollections(projectId, instanceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get collection info
     * @param {string} projectId 
     * @param {string} instanceId 
     * @param {string} collectionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentControllerGetCollectionInfo(projectId: string, instanceId: string, collectionId: string, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentControllerGetCollectionInfo(projectId, instanceId, collectionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get doc by ID
     * @param {string} projectId 
     * @param {string} instanceId 
     * @param {string} collectionId 
     * @param {string} docId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentControllerGetDocById(projectId: string, instanceId: string, collectionId: string, docId: string, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentControllerGetDocById(projectId, instanceId, collectionId, docId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Similarity search query
     * @param {string} projectId 
     * @param {string} instanceId 
     * @param {string} collectionId 
     * @param {SimilaritySearchQueryDTO} similaritySearchQueryDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentControllerSimilaritySearch(projectId: string, instanceId: string, collectionId: string, similaritySearchQueryDTO: SimilaritySearchQueryDTO, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentControllerSimilaritySearch(projectId, instanceId, collectionId, similaritySearchQueryDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update collection
     * @param {string} projectId 
     * @param {string} instanceId 
     * @param {string} collectionId 
     * @param {CreateCollectionRequestDTO} createCollectionRequestDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentControllerUpdateCollection(projectId: string, instanceId: string, collectionId: string, createCollectionRequestDTO: CreateCollectionRequestDTO, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentControllerUpdateCollection(projectId, instanceId, collectionId, createCollectionRequestDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update or upsert doc
     * @param {string} projectId 
     * @param {string} instanceId 
     * @param {string} collectionId 
     * @param {string} docId 
     * @param {UpdateDocumentRequestDTO} updateDocumentRequestDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentControllerUpdateDoc(projectId: string, instanceId: string, collectionId: string, docId: string, updateDocumentRequestDTO: UpdateDocumentRequestDTO, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentControllerUpdateDoc(projectId, instanceId, collectionId, docId, updateDocumentRequestDTO, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * EvaluationTestApi - axios parameter creator
 * @export
 */
export const EvaluationTestApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add new evaluation test.
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        evaluationTestControllerAddEvaluationTest: async (projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('evaluationTestControllerAddEvaluationTest', 'projectId', projectId)
            const localVarPath = `/projects/{projectId}/evaluation-tests`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete evaluation
         * @param {string} projectId 
         * @param {string} testId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        evaluationTestControllerDeleteEvaluation: async (projectId: string, testId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('evaluationTestControllerDeleteEvaluation', 'projectId', projectId)
            // verify required parameter 'testId' is not null or undefined
            assertParamExists('evaluationTestControllerDeleteEvaluation', 'testId', testId)
            const localVarPath = `/projects/{projectId}/evaluation-tests/{testId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"testId"}}`, encodeURIComponent(String(testId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Execute evaluation test.
         * @param {string} projectId 
         * @param {string} testId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        evaluationTestControllerExecuteEvaluation: async (projectId: string, testId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('evaluationTestControllerExecuteEvaluation', 'projectId', projectId)
            // verify required parameter 'testId' is not null or undefined
            assertParamExists('evaluationTestControllerExecuteEvaluation', 'testId', testId)
            const localVarPath = `/projects/{projectId}/evaluation-tests/{testId}/execute`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"testId"}}`, encodeURIComponent(String(testId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Fetch evaluation test.
         * @param {string} projectId 
         * @param {string} modelId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        evaluationTestControllerGetEvaluationTest: async (projectId: string, modelId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('evaluationTestControllerGetEvaluationTest', 'projectId', projectId)
            // verify required parameter 'modelId' is not null or undefined
            assertParamExists('evaluationTestControllerGetEvaluationTest', 'modelId', modelId)
            const localVarPath = `/projects/{projectId}/evaluation-tests/{modelId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"modelId"}}`, encodeURIComponent(String(modelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update evaluation test
         * @param {string} projectId 
         * @param {string} testId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        evaluationTestControllerUpdateEvaluation: async (projectId: string, testId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('evaluationTestControllerUpdateEvaluation', 'projectId', projectId)
            // verify required parameter 'testId' is not null or undefined
            assertParamExists('evaluationTestControllerUpdateEvaluation', 'testId', testId)
            const localVarPath = `/projects/{projectId}/evaluation-tests/{testId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"testId"}}`, encodeURIComponent(String(testId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EvaluationTestApi - functional programming interface
 * @export
 */
export const EvaluationTestApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EvaluationTestApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add new evaluation test.
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async evaluationTestControllerAddEvaluationTest(projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.evaluationTestControllerAddEvaluationTest(projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EvaluationTestApi.evaluationTestControllerAddEvaluationTest']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete evaluation
         * @param {string} projectId 
         * @param {string} testId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async evaluationTestControllerDeleteEvaluation(projectId: string, testId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.evaluationTestControllerDeleteEvaluation(projectId, testId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EvaluationTestApi.evaluationTestControllerDeleteEvaluation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Execute evaluation test.
         * @param {string} projectId 
         * @param {string} testId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async evaluationTestControllerExecuteEvaluation(projectId: string, testId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.evaluationTestControllerExecuteEvaluation(projectId, testId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EvaluationTestApi.evaluationTestControllerExecuteEvaluation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Fetch evaluation test.
         * @param {string} projectId 
         * @param {string} modelId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async evaluationTestControllerGetEvaluationTest(projectId: string, modelId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.evaluationTestControllerGetEvaluationTest(projectId, modelId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EvaluationTestApi.evaluationTestControllerGetEvaluationTest']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update evaluation test
         * @param {string} projectId 
         * @param {string} testId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async evaluationTestControllerUpdateEvaluation(projectId: string, testId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.evaluationTestControllerUpdateEvaluation(projectId, testId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EvaluationTestApi.evaluationTestControllerUpdateEvaluation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * EvaluationTestApi - factory interface
 * @export
 */
export const EvaluationTestApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EvaluationTestApiFp(configuration)
    return {
        /**
         * 
         * @summary Add new evaluation test.
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        evaluationTestControllerAddEvaluationTest(projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.evaluationTestControllerAddEvaluationTest(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete evaluation
         * @param {string} projectId 
         * @param {string} testId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        evaluationTestControllerDeleteEvaluation(projectId: string, testId: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.evaluationTestControllerDeleteEvaluation(projectId, testId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Execute evaluation test.
         * @param {string} projectId 
         * @param {string} testId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        evaluationTestControllerExecuteEvaluation(projectId: string, testId: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.evaluationTestControllerExecuteEvaluation(projectId, testId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Fetch evaluation test.
         * @param {string} projectId 
         * @param {string} modelId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        evaluationTestControllerGetEvaluationTest(projectId: string, modelId: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.evaluationTestControllerGetEvaluationTest(projectId, modelId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update evaluation test
         * @param {string} projectId 
         * @param {string} testId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        evaluationTestControllerUpdateEvaluation(projectId: string, testId: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.evaluationTestControllerUpdateEvaluation(projectId, testId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EvaluationTestApi - object-oriented interface
 * @export
 * @class EvaluationTestApi
 * @extends {BaseAPI}
 */
export class EvaluationTestApi extends BaseAPI {
    /**
     * 
     * @summary Add new evaluation test.
     * @param {string} projectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EvaluationTestApi
     */
    public evaluationTestControllerAddEvaluationTest(projectId: string, options?: RawAxiosRequestConfig) {
        return EvaluationTestApiFp(this.configuration).evaluationTestControllerAddEvaluationTest(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete evaluation
     * @param {string} projectId 
     * @param {string} testId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EvaluationTestApi
     */
    public evaluationTestControllerDeleteEvaluation(projectId: string, testId: string, options?: RawAxiosRequestConfig) {
        return EvaluationTestApiFp(this.configuration).evaluationTestControllerDeleteEvaluation(projectId, testId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Execute evaluation test.
     * @param {string} projectId 
     * @param {string} testId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EvaluationTestApi
     */
    public evaluationTestControllerExecuteEvaluation(projectId: string, testId: string, options?: RawAxiosRequestConfig) {
        return EvaluationTestApiFp(this.configuration).evaluationTestControllerExecuteEvaluation(projectId, testId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Fetch evaluation test.
     * @param {string} projectId 
     * @param {string} modelId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EvaluationTestApi
     */
    public evaluationTestControllerGetEvaluationTest(projectId: string, modelId: string, options?: RawAxiosRequestConfig) {
        return EvaluationTestApiFp(this.configuration).evaluationTestControllerGetEvaluationTest(projectId, modelId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update evaluation test
     * @param {string} projectId 
     * @param {string} testId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EvaluationTestApi
     */
    public evaluationTestControllerUpdateEvaluation(projectId: string, testId: string, options?: RawAxiosRequestConfig) {
        return EvaluationTestApiFp(this.configuration).evaluationTestControllerUpdateEvaluation(projectId, testId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MachineAgentApi - axios parameter creator
 * @export
 */
export const MachineAgentApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create New Machine Agent
         * @param {string} projectId 
         * @param {CreateMachineAgentDto} createMachineAgentDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        machineAgentControllerCreateMachineAgent: async (projectId: string, createMachineAgentDto: CreateMachineAgentDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('machineAgentControllerCreateMachineAgent', 'projectId', projectId)
            // verify required parameter 'createMachineAgentDto' is not null or undefined
            assertParamExists('machineAgentControllerCreateMachineAgent', 'createMachineAgentDto', createMachineAgentDto)
            const localVarPath = `/projects/{projectId}/agents`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createMachineAgentDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete machine agent
         * @param {string} projectId 
         * @param {string} agentId 
         * @param {Array<string>} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        machineAgentControllerDeleteMachineAgents: async (projectId: string, agentId: string, requestBody: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('machineAgentControllerDeleteMachineAgents', 'projectId', projectId)
            // verify required parameter 'agentId' is not null or undefined
            assertParamExists('machineAgentControllerDeleteMachineAgents', 'agentId', agentId)
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('machineAgentControllerDeleteMachineAgents', 'requestBody', requestBody)
            const localVarPath = `/projects/{projectId}/agents/{agentId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"agentId"}}`, encodeURIComponent(String(agentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all machine agent with count
         * @param {string} projectId 
         * @param {number} page 
         * @param {number} limit 
         * @param {string} type 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        machineAgentControllerGetMachineAgentByProjectId: async (projectId: string, page: number, limit: number, type: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('machineAgentControllerGetMachineAgentByProjectId', 'projectId', projectId)
            // verify required parameter 'page' is not null or undefined
            assertParamExists('machineAgentControllerGetMachineAgentByProjectId', 'page', page)
            // verify required parameter 'limit' is not null or undefined
            assertParamExists('machineAgentControllerGetMachineAgentByProjectId', 'limit', limit)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('machineAgentControllerGetMachineAgentByProjectId', 'type', type)
            const localVarPath = `/projects/{projectId}/agents`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update machine agent by id
         * @param {string} projectId 
         * @param {string} agentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        machineAgentControllerUpdateMachineAgent: async (projectId: string, agentId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('machineAgentControllerUpdateMachineAgent', 'projectId', projectId)
            // verify required parameter 'agentId' is not null or undefined
            assertParamExists('machineAgentControllerUpdateMachineAgent', 'agentId', agentId)
            const localVarPath = `/projects/{projectId}/agents/{agentId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"agentId"}}`, encodeURIComponent(String(agentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MachineAgentApi - functional programming interface
 * @export
 */
export const MachineAgentApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MachineAgentApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create New Machine Agent
         * @param {string} projectId 
         * @param {CreateMachineAgentDto} createMachineAgentDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async machineAgentControllerCreateMachineAgent(projectId: string, createMachineAgentDto: CreateMachineAgentDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateMachineAgentDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.machineAgentControllerCreateMachineAgent(projectId, createMachineAgentDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MachineAgentApi.machineAgentControllerCreateMachineAgent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete machine agent
         * @param {string} projectId 
         * @param {string} agentId 
         * @param {Array<string>} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async machineAgentControllerDeleteMachineAgents(projectId: string, agentId: string, requestBody: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateMachineAgentDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.machineAgentControllerDeleteMachineAgents(projectId, agentId, requestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MachineAgentApi.machineAgentControllerDeleteMachineAgents']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all machine agent with count
         * @param {string} projectId 
         * @param {number} page 
         * @param {number} limit 
         * @param {string} type 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async machineAgentControllerGetMachineAgentByProjectId(projectId: string, page: number, limit: number, type: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateMachineAgentDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.machineAgentControllerGetMachineAgentByProjectId(projectId, page, limit, type, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MachineAgentApi.machineAgentControllerGetMachineAgentByProjectId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update machine agent by id
         * @param {string} projectId 
         * @param {string} agentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async machineAgentControllerUpdateMachineAgent(projectId: string, agentId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateMachineAgentDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.machineAgentControllerUpdateMachineAgent(projectId, agentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MachineAgentApi.machineAgentControllerUpdateMachineAgent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MachineAgentApi - factory interface
 * @export
 */
export const MachineAgentApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MachineAgentApiFp(configuration)
    return {
        /**
         * 
         * @summary Create New Machine Agent
         * @param {string} projectId 
         * @param {CreateMachineAgentDto} createMachineAgentDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        machineAgentControllerCreateMachineAgent(projectId: string, createMachineAgentDto: CreateMachineAgentDto, options?: RawAxiosRequestConfig): AxiosPromise<CreateMachineAgentDto> {
            return localVarFp.machineAgentControllerCreateMachineAgent(projectId, createMachineAgentDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete machine agent
         * @param {string} projectId 
         * @param {string} agentId 
         * @param {Array<string>} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        machineAgentControllerDeleteMachineAgents(projectId: string, agentId: string, requestBody: Array<string>, options?: RawAxiosRequestConfig): AxiosPromise<CreateMachineAgentDto> {
            return localVarFp.machineAgentControllerDeleteMachineAgents(projectId, agentId, requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all machine agent with count
         * @param {string} projectId 
         * @param {number} page 
         * @param {number} limit 
         * @param {string} type 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        machineAgentControllerGetMachineAgentByProjectId(projectId: string, page: number, limit: number, type: string, options?: RawAxiosRequestConfig): AxiosPromise<CreateMachineAgentDto> {
            return localVarFp.machineAgentControllerGetMachineAgentByProjectId(projectId, page, limit, type, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update machine agent by id
         * @param {string} projectId 
         * @param {string} agentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        machineAgentControllerUpdateMachineAgent(projectId: string, agentId: string, options?: RawAxiosRequestConfig): AxiosPromise<CreateMachineAgentDto> {
            return localVarFp.machineAgentControllerUpdateMachineAgent(projectId, agentId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MachineAgentApi - object-oriented interface
 * @export
 * @class MachineAgentApi
 * @extends {BaseAPI}
 */
export class MachineAgentApi extends BaseAPI {
    /**
     * 
     * @summary Create New Machine Agent
     * @param {string} projectId 
     * @param {CreateMachineAgentDto} createMachineAgentDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MachineAgentApi
     */
    public machineAgentControllerCreateMachineAgent(projectId: string, createMachineAgentDto: CreateMachineAgentDto, options?: RawAxiosRequestConfig) {
        return MachineAgentApiFp(this.configuration).machineAgentControllerCreateMachineAgent(projectId, createMachineAgentDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete machine agent
     * @param {string} projectId 
     * @param {string} agentId 
     * @param {Array<string>} requestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MachineAgentApi
     */
    public machineAgentControllerDeleteMachineAgents(projectId: string, agentId: string, requestBody: Array<string>, options?: RawAxiosRequestConfig) {
        return MachineAgentApiFp(this.configuration).machineAgentControllerDeleteMachineAgents(projectId, agentId, requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all machine agent with count
     * @param {string} projectId 
     * @param {number} page 
     * @param {number} limit 
     * @param {string} type 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MachineAgentApi
     */
    public machineAgentControllerGetMachineAgentByProjectId(projectId: string, page: number, limit: number, type: string, options?: RawAxiosRequestConfig) {
        return MachineAgentApiFp(this.configuration).machineAgentControllerGetMachineAgentByProjectId(projectId, page, limit, type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update machine agent by id
     * @param {string} projectId 
     * @param {string} agentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MachineAgentApi
     */
    public machineAgentControllerUpdateMachineAgent(projectId: string, agentId: string, options?: RawAxiosRequestConfig) {
        return MachineAgentApiFp(this.configuration).machineAgentControllerUpdateMachineAgent(projectId, agentId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MachineAgentLogsApi - axios parameter creator
 * @export
 */
export const MachineAgentLogsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Fetch agent logs.
         * @param {string} projectId 
         * @param {string} agentId 
         * @param {string} direction 
         * @param {string} cursor 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logsControllerFetchAgentLogs: async (projectId: string, agentId: string, direction: string, cursor: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('logsControllerFetchAgentLogs', 'projectId', projectId)
            // verify required parameter 'agentId' is not null or undefined
            assertParamExists('logsControllerFetchAgentLogs', 'agentId', agentId)
            // verify required parameter 'direction' is not null or undefined
            assertParamExists('logsControllerFetchAgentLogs', 'direction', direction)
            // verify required parameter 'cursor' is not null or undefined
            assertParamExists('logsControllerFetchAgentLogs', 'cursor', cursor)
            const localVarPath = `/projects/{projectId}/logs/{agentId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"agentId"}}`, encodeURIComponent(String(agentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Fetch event logs.
         * @param {string} projectId 
         * @param {string} agentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logsControllerFetchEventLogs: async (projectId: string, agentId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('logsControllerFetchEventLogs', 'projectId', projectId)
            // verify required parameter 'agentId' is not null or undefined
            assertParamExists('logsControllerFetchEventLogs', 'agentId', agentId)
            const localVarPath = `/projects/{projectId}/fetchEventLogs/{agentId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"agentId"}}`, encodeURIComponent(String(agentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MachineAgentLogsApi - functional programming interface
 * @export
 */
export const MachineAgentLogsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MachineAgentLogsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Fetch agent logs.
         * @param {string} projectId 
         * @param {string} agentId 
         * @param {string} direction 
         * @param {string} cursor 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logsControllerFetchAgentLogs(projectId: string, agentId: string, direction: string, cursor: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logsControllerFetchAgentLogs(projectId, agentId, direction, cursor, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MachineAgentLogsApi.logsControllerFetchAgentLogs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Fetch event logs.
         * @param {string} projectId 
         * @param {string} agentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logsControllerFetchEventLogs(projectId: string, agentId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logsControllerFetchEventLogs(projectId, agentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MachineAgentLogsApi.logsControllerFetchEventLogs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MachineAgentLogsApi - factory interface
 * @export
 */
export const MachineAgentLogsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MachineAgentLogsApiFp(configuration)
    return {
        /**
         * 
         * @summary Fetch agent logs.
         * @param {string} projectId 
         * @param {string} agentId 
         * @param {string} direction 
         * @param {string} cursor 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logsControllerFetchAgentLogs(projectId: string, agentId: string, direction: string, cursor: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.logsControllerFetchAgentLogs(projectId, agentId, direction, cursor, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Fetch event logs.
         * @param {string} projectId 
         * @param {string} agentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logsControllerFetchEventLogs(projectId: string, agentId: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.logsControllerFetchEventLogs(projectId, agentId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MachineAgentLogsApi - object-oriented interface
 * @export
 * @class MachineAgentLogsApi
 * @extends {BaseAPI}
 */
export class MachineAgentLogsApi extends BaseAPI {
    /**
     * 
     * @summary Fetch agent logs.
     * @param {string} projectId 
     * @param {string} agentId 
     * @param {string} direction 
     * @param {string} cursor 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MachineAgentLogsApi
     */
    public logsControllerFetchAgentLogs(projectId: string, agentId: string, direction: string, cursor: string, options?: RawAxiosRequestConfig) {
        return MachineAgentLogsApiFp(this.configuration).logsControllerFetchAgentLogs(projectId, agentId, direction, cursor, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Fetch event logs.
     * @param {string} projectId 
     * @param {string} agentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MachineAgentLogsApi
     */
    public logsControllerFetchEventLogs(projectId: string, agentId: string, options?: RawAxiosRequestConfig) {
        return MachineAgentLogsApiFp(this.configuration).logsControllerFetchEventLogs(projectId, agentId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MachineInstancesApi - axios parameter creator
 * @export
 */
export const MachineInstancesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create Machine Instance
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        machineInstancesControllerCreateMachineInstance: async (projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('machineInstancesControllerCreateMachineInstance', 'projectId', projectId)
            const localVarPath = `/projects/{projectId}/instances`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete machine instances by ids
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        machineInstancesControllerDeleteMachineInstance: async (projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('machineInstancesControllerDeleteMachineInstance', 'projectId', projectId)
            const localVarPath = `/projects/{projectId}/instances`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve running status of instances
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        machineInstancesControllerGetInstanceRunningStatus: async (projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('machineInstancesControllerGetInstanceRunningStatus', 'projectId', projectId)
            const localVarPath = `/projects/{projectId}/instances/status`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve CSV benchmarking datapoints for a specific machine
         * @param {string} projectId 
         * @param {string} machineId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        machineInstancesControllerGetMachineBenchmarkingDatapoints: async (projectId: string, machineId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('machineInstancesControllerGetMachineBenchmarkingDatapoints', 'projectId', projectId)
            // verify required parameter 'machineId' is not null or undefined
            assertParamExists('machineInstancesControllerGetMachineBenchmarkingDatapoints', 'machineId', machineId)
            const localVarPath = `/projects/{projectId}/instances/machine/{machineId}/benchmarking-datapoints`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"machineId"}}`, encodeURIComponent(String(machineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve benchmarking reports for a specific machine
         * @param {string} projectId 
         * @param {string} machineId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        machineInstancesControllerGetMachineBenchmarkingReports: async (projectId: string, machineId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('machineInstancesControllerGetMachineBenchmarkingReports', 'projectId', projectId)
            // verify required parameter 'machineId' is not null or undefined
            assertParamExists('machineInstancesControllerGetMachineBenchmarkingReports', 'machineId', machineId)
            const localVarPath = `/projects/{projectId}/instances/machine/{machineId}/benchmarking-reports`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"machineId"}}`, encodeURIComponent(String(machineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve status of a specific machine instance
         * @param {string} projectId 
         * @param {string} machineId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        machineInstancesControllerGetMachineBootstrapStatus: async (projectId: string, machineId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('machineInstancesControllerGetMachineBootstrapStatus', 'projectId', projectId)
            // verify required parameter 'machineId' is not null or undefined
            assertParamExists('machineInstancesControllerGetMachineBootstrapStatus', 'machineId', machineId)
            const localVarPath = `/projects/{projectId}/instances/machine/{machineId}/status`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"machineId"}}`, encodeURIComponent(String(machineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve running status of instances
         * @param {string} projectId 
         * @param {string} machineId 
         * @param {number} page 
         * @param {number} limit 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        machineInstancesControllerGetMachineInstanceById: async (projectId: string, machineId: string, page: number, limit: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('machineInstancesControllerGetMachineInstanceById', 'projectId', projectId)
            // verify required parameter 'machineId' is not null or undefined
            assertParamExists('machineInstancesControllerGetMachineInstanceById', 'machineId', machineId)
            // verify required parameter 'page' is not null or undefined
            assertParamExists('machineInstancesControllerGetMachineInstanceById', 'page', page)
            // verify required parameter 'limit' is not null or undefined
            assertParamExists('machineInstancesControllerGetMachineInstanceById', 'limit', limit)
            const localVarPath = `/projects/{projectId}/instances/machine/{machineId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"machineId"}}`, encodeURIComponent(String(machineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve all machine instances with count
         * @param {string} projectId 
         * @param {number} page 
         * @param {number} limit 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        machineInstancesControllerGetMachineInstanceByUserId: async (projectId: string, page: number, limit: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('machineInstancesControllerGetMachineInstanceByUserId', 'projectId', projectId)
            // verify required parameter 'page' is not null or undefined
            assertParamExists('machineInstancesControllerGetMachineInstanceByUserId', 'page', page)
            // verify required parameter 'limit' is not null or undefined
            assertParamExists('machineInstancesControllerGetMachineInstanceByUserId', 'limit', limit)
            const localVarPath = `/projects/{projectId}/instances`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Machine Instance Running Status
         * @param {string} projectId 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        machineInstancesControllerUpdateRunningStatus: async (projectId: string, body: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('machineInstancesControllerUpdateRunningStatus', 'projectId', projectId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('machineInstancesControllerUpdateRunningStatus', 'body', body)
            const localVarPath = `/projects/{projectId}/instances/status`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MachineInstancesApi - functional programming interface
 * @export
 */
export const MachineInstancesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MachineInstancesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create Machine Instance
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async machineInstancesControllerCreateMachineInstance(projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.machineInstancesControllerCreateMachineInstance(projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MachineInstancesApi.machineInstancesControllerCreateMachineInstance']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete machine instances by ids
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async machineInstancesControllerDeleteMachineInstance(projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.machineInstancesControllerDeleteMachineInstance(projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MachineInstancesApi.machineInstancesControllerDeleteMachineInstance']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve running status of instances
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async machineInstancesControllerGetInstanceRunningStatus(projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.machineInstancesControllerGetInstanceRunningStatus(projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MachineInstancesApi.machineInstancesControllerGetInstanceRunningStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve CSV benchmarking datapoints for a specific machine
         * @param {string} projectId 
         * @param {string} machineId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async machineInstancesControllerGetMachineBenchmarkingDatapoints(projectId: string, machineId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BenchmarkingDatapointDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.machineInstancesControllerGetMachineBenchmarkingDatapoints(projectId, machineId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MachineInstancesApi.machineInstancesControllerGetMachineBenchmarkingDatapoints']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve benchmarking reports for a specific machine
         * @param {string} projectId 
         * @param {string} machineId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async machineInstancesControllerGetMachineBenchmarkingReports(projectId: string, machineId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BenchmarkingReportsDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.machineInstancesControllerGetMachineBenchmarkingReports(projectId, machineId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MachineInstancesApi.machineInstancesControllerGetMachineBenchmarkingReports']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve status of a specific machine instance
         * @param {string} projectId 
         * @param {string} machineId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async machineInstancesControllerGetMachineBootstrapStatus(projectId: string, machineId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MachineStatusDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.machineInstancesControllerGetMachineBootstrapStatus(projectId, machineId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MachineInstancesApi.machineInstancesControllerGetMachineBootstrapStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve running status of instances
         * @param {string} projectId 
         * @param {string} machineId 
         * @param {number} page 
         * @param {number} limit 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async machineInstancesControllerGetMachineInstanceById(projectId: string, machineId: string, page: number, limit: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.machineInstancesControllerGetMachineInstanceById(projectId, machineId, page, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MachineInstancesApi.machineInstancesControllerGetMachineInstanceById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve all machine instances with count
         * @param {string} projectId 
         * @param {number} page 
         * @param {number} limit 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async machineInstancesControllerGetMachineInstanceByUserId(projectId: string, page: number, limit: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.machineInstancesControllerGetMachineInstanceByUserId(projectId, page, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MachineInstancesApi.machineInstancesControllerGetMachineInstanceByUserId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update Machine Instance Running Status
         * @param {string} projectId 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async machineInstancesControllerUpdateRunningStatus(projectId: string, body: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.machineInstancesControllerUpdateRunningStatus(projectId, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MachineInstancesApi.machineInstancesControllerUpdateRunningStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MachineInstancesApi - factory interface
 * @export
 */
export const MachineInstancesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MachineInstancesApiFp(configuration)
    return {
        /**
         * 
         * @summary Create Machine Instance
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        machineInstancesControllerCreateMachineInstance(projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.machineInstancesControllerCreateMachineInstance(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete machine instances by ids
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        machineInstancesControllerDeleteMachineInstance(projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.machineInstancesControllerDeleteMachineInstance(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve running status of instances
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        machineInstancesControllerGetInstanceRunningStatus(projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.machineInstancesControllerGetInstanceRunningStatus(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve CSV benchmarking datapoints for a specific machine
         * @param {string} projectId 
         * @param {string} machineId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        machineInstancesControllerGetMachineBenchmarkingDatapoints(projectId: string, machineId: string, options?: RawAxiosRequestConfig): AxiosPromise<BenchmarkingDatapointDto> {
            return localVarFp.machineInstancesControllerGetMachineBenchmarkingDatapoints(projectId, machineId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve benchmarking reports for a specific machine
         * @param {string} projectId 
         * @param {string} machineId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        machineInstancesControllerGetMachineBenchmarkingReports(projectId: string, machineId: string, options?: RawAxiosRequestConfig): AxiosPromise<BenchmarkingReportsDto> {
            return localVarFp.machineInstancesControllerGetMachineBenchmarkingReports(projectId, machineId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve status of a specific machine instance
         * @param {string} projectId 
         * @param {string} machineId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        machineInstancesControllerGetMachineBootstrapStatus(projectId: string, machineId: string, options?: RawAxiosRequestConfig): AxiosPromise<MachineStatusDto> {
            return localVarFp.machineInstancesControllerGetMachineBootstrapStatus(projectId, machineId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve running status of instances
         * @param {string} projectId 
         * @param {string} machineId 
         * @param {number} page 
         * @param {number} limit 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        machineInstancesControllerGetMachineInstanceById(projectId: string, machineId: string, page: number, limit: number, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.machineInstancesControllerGetMachineInstanceById(projectId, machineId, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve all machine instances with count
         * @param {string} projectId 
         * @param {number} page 
         * @param {number} limit 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        machineInstancesControllerGetMachineInstanceByUserId(projectId: string, page: number, limit: number, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.machineInstancesControllerGetMachineInstanceByUserId(projectId, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Machine Instance Running Status
         * @param {string} projectId 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        machineInstancesControllerUpdateRunningStatus(projectId: string, body: object, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.machineInstancesControllerUpdateRunningStatus(projectId, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MachineInstancesApi - object-oriented interface
 * @export
 * @class MachineInstancesApi
 * @extends {BaseAPI}
 */
export class MachineInstancesApi extends BaseAPI {
    /**
     * 
     * @summary Create Machine Instance
     * @param {string} projectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MachineInstancesApi
     */
    public machineInstancesControllerCreateMachineInstance(projectId: string, options?: RawAxiosRequestConfig) {
        return MachineInstancesApiFp(this.configuration).machineInstancesControllerCreateMachineInstance(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete machine instances by ids
     * @param {string} projectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MachineInstancesApi
     */
    public machineInstancesControllerDeleteMachineInstance(projectId: string, options?: RawAxiosRequestConfig) {
        return MachineInstancesApiFp(this.configuration).machineInstancesControllerDeleteMachineInstance(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve running status of instances
     * @param {string} projectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MachineInstancesApi
     */
    public machineInstancesControllerGetInstanceRunningStatus(projectId: string, options?: RawAxiosRequestConfig) {
        return MachineInstancesApiFp(this.configuration).machineInstancesControllerGetInstanceRunningStatus(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve CSV benchmarking datapoints for a specific machine
     * @param {string} projectId 
     * @param {string} machineId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MachineInstancesApi
     */
    public machineInstancesControllerGetMachineBenchmarkingDatapoints(projectId: string, machineId: string, options?: RawAxiosRequestConfig) {
        return MachineInstancesApiFp(this.configuration).machineInstancesControllerGetMachineBenchmarkingDatapoints(projectId, machineId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve benchmarking reports for a specific machine
     * @param {string} projectId 
     * @param {string} machineId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MachineInstancesApi
     */
    public machineInstancesControllerGetMachineBenchmarkingReports(projectId: string, machineId: string, options?: RawAxiosRequestConfig) {
        return MachineInstancesApiFp(this.configuration).machineInstancesControllerGetMachineBenchmarkingReports(projectId, machineId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve status of a specific machine instance
     * @param {string} projectId 
     * @param {string} machineId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MachineInstancesApi
     */
    public machineInstancesControllerGetMachineBootstrapStatus(projectId: string, machineId: string, options?: RawAxiosRequestConfig) {
        return MachineInstancesApiFp(this.configuration).machineInstancesControllerGetMachineBootstrapStatus(projectId, machineId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve running status of instances
     * @param {string} projectId 
     * @param {string} machineId 
     * @param {number} page 
     * @param {number} limit 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MachineInstancesApi
     */
    public machineInstancesControllerGetMachineInstanceById(projectId: string, machineId: string, page: number, limit: number, options?: RawAxiosRequestConfig) {
        return MachineInstancesApiFp(this.configuration).machineInstancesControllerGetMachineInstanceById(projectId, machineId, page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve all machine instances with count
     * @param {string} projectId 
     * @param {number} page 
     * @param {number} limit 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MachineInstancesApi
     */
    public machineInstancesControllerGetMachineInstanceByUserId(projectId: string, page: number, limit: number, options?: RawAxiosRequestConfig) {
        return MachineInstancesApiFp(this.configuration).machineInstancesControllerGetMachineInstanceByUserId(projectId, page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Machine Instance Running Status
     * @param {string} projectId 
     * @param {object} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MachineInstancesApi
     */
    public machineInstancesControllerUpdateRunningStatus(projectId: string, body: object, options?: RawAxiosRequestConfig) {
        return MachineInstancesApiFp(this.configuration).machineInstancesControllerUpdateRunningStatus(projectId, body, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MembersApi - axios parameter creator
 * @export
 */
export const MembersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add a team member
         * @param {string} projectId 
         * @param {AddProjectMemberDto} addProjectMemberDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        membersControllerAddTeamMemberToProject: async (projectId: string, addProjectMemberDto: AddProjectMemberDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('membersControllerAddTeamMemberToProject', 'projectId', projectId)
            // verify required parameter 'addProjectMemberDto' is not null or undefined
            assertParamExists('membersControllerAddTeamMemberToProject', 'addProjectMemberDto', addProjectMemberDto)
            const localVarPath = `/projects/{projectId}/members`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addProjectMemberDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve all team members
         * @param {string} projectId 
         * @param {number} [page] 
         * @param {number} [limit] 
         * @param {string} [column] 
         * @param {MembersControllerGetAllTeamMembersOfProjectDirectionEnum} [direction] 
         * @param {Array<string>} [teamMemberStatus] 
         * @param {Array<number>} [roleIds] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        membersControllerGetAllTeamMembersOfProject: async (projectId: string, page?: number, limit?: number, column?: string, direction?: MembersControllerGetAllTeamMembersOfProjectDirectionEnum, teamMemberStatus?: Array<string>, roleIds?: Array<number>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('membersControllerGetAllTeamMembersOfProject', 'projectId', projectId)
            const localVarPath = `/projects/{projectId}/members`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (column !== undefined) {
                localVarQueryParameter['column'] = column;
            }

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }

            if (teamMemberStatus) {
                localVarQueryParameter['teamMemberStatus'] = teamMemberStatus;
            }

            if (roleIds) {
                localVarQueryParameter['roleIds'] = roleIds;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update team member details
         * @param {string} projectId 
         * @param {string} memberId 
         * @param {UpdateTeamMemberRequestDTO} updateTeamMemberRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        membersControllerUpdateTeamMemberRole: async (projectId: string, memberId: string, updateTeamMemberRequestDTO: UpdateTeamMemberRequestDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('membersControllerUpdateTeamMemberRole', 'projectId', projectId)
            // verify required parameter 'memberId' is not null or undefined
            assertParamExists('membersControllerUpdateTeamMemberRole', 'memberId', memberId)
            // verify required parameter 'updateTeamMemberRequestDTO' is not null or undefined
            assertParamExists('membersControllerUpdateTeamMemberRole', 'updateTeamMemberRequestDTO', updateTeamMemberRequestDTO)
            const localVarPath = `/projects/{projectId}/members/{memberId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"memberId"}}`, encodeURIComponent(String(memberId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateTeamMemberRequestDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MembersApi - functional programming interface
 * @export
 */
export const MembersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MembersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add a team member
         * @param {string} projectId 
         * @param {AddProjectMemberDto} addProjectMemberDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async membersControllerAddTeamMemberToProject(projectId: string, addProjectMemberDto: AddProjectMemberDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddProjectMemberResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.membersControllerAddTeamMemberToProject(projectId, addProjectMemberDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MembersApi.membersControllerAddTeamMemberToProject']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve all team members
         * @param {string} projectId 
         * @param {number} [page] 
         * @param {number} [limit] 
         * @param {string} [column] 
         * @param {MembersControllerGetAllTeamMembersOfProjectDirectionEnum} [direction] 
         * @param {Array<string>} [teamMemberStatus] 
         * @param {Array<number>} [roleIds] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async membersControllerGetAllTeamMembersOfProject(projectId: string, page?: number, limit?: number, column?: string, direction?: MembersControllerGetAllTeamMembersOfProjectDirectionEnum, teamMemberStatus?: Array<string>, roleIds?: Array<number>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAllProjectMemberResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.membersControllerGetAllTeamMembersOfProject(projectId, page, limit, column, direction, teamMemberStatus, roleIds, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MembersApi.membersControllerGetAllTeamMembersOfProject']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update team member details
         * @param {string} projectId 
         * @param {string} memberId 
         * @param {UpdateTeamMemberRequestDTO} updateTeamMemberRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async membersControllerUpdateTeamMemberRole(projectId: string, memberId: string, updateTeamMemberRequestDTO: UpdateTeamMemberRequestDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddProjectMemberResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.membersControllerUpdateTeamMemberRole(projectId, memberId, updateTeamMemberRequestDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MembersApi.membersControllerUpdateTeamMemberRole']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MembersApi - factory interface
 * @export
 */
export const MembersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MembersApiFp(configuration)
    return {
        /**
         * 
         * @summary Add a team member
         * @param {string} projectId 
         * @param {AddProjectMemberDto} addProjectMemberDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        membersControllerAddTeamMemberToProject(projectId: string, addProjectMemberDto: AddProjectMemberDto, options?: RawAxiosRequestConfig): AxiosPromise<AddProjectMemberResponseDTO> {
            return localVarFp.membersControllerAddTeamMemberToProject(projectId, addProjectMemberDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve all team members
         * @param {string} projectId 
         * @param {number} [page] 
         * @param {number} [limit] 
         * @param {string} [column] 
         * @param {MembersControllerGetAllTeamMembersOfProjectDirectionEnum} [direction] 
         * @param {Array<string>} [teamMemberStatus] 
         * @param {Array<number>} [roleIds] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        membersControllerGetAllTeamMembersOfProject(projectId: string, page?: number, limit?: number, column?: string, direction?: MembersControllerGetAllTeamMembersOfProjectDirectionEnum, teamMemberStatus?: Array<string>, roleIds?: Array<number>, options?: RawAxiosRequestConfig): AxiosPromise<GetAllProjectMemberResponseDto> {
            return localVarFp.membersControllerGetAllTeamMembersOfProject(projectId, page, limit, column, direction, teamMemberStatus, roleIds, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update team member details
         * @param {string} projectId 
         * @param {string} memberId 
         * @param {UpdateTeamMemberRequestDTO} updateTeamMemberRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        membersControllerUpdateTeamMemberRole(projectId: string, memberId: string, updateTeamMemberRequestDTO: UpdateTeamMemberRequestDTO, options?: RawAxiosRequestConfig): AxiosPromise<AddProjectMemberResponseDTO> {
            return localVarFp.membersControllerUpdateTeamMemberRole(projectId, memberId, updateTeamMemberRequestDTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MembersApi - object-oriented interface
 * @export
 * @class MembersApi
 * @extends {BaseAPI}
 */
export class MembersApi extends BaseAPI {
    /**
     * 
     * @summary Add a team member
     * @param {string} projectId 
     * @param {AddProjectMemberDto} addProjectMemberDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MembersApi
     */
    public membersControllerAddTeamMemberToProject(projectId: string, addProjectMemberDto: AddProjectMemberDto, options?: RawAxiosRequestConfig) {
        return MembersApiFp(this.configuration).membersControllerAddTeamMemberToProject(projectId, addProjectMemberDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve all team members
     * @param {string} projectId 
     * @param {number} [page] 
     * @param {number} [limit] 
     * @param {string} [column] 
     * @param {MembersControllerGetAllTeamMembersOfProjectDirectionEnum} [direction] 
     * @param {Array<string>} [teamMemberStatus] 
     * @param {Array<number>} [roleIds] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MembersApi
     */
    public membersControllerGetAllTeamMembersOfProject(projectId: string, page?: number, limit?: number, column?: string, direction?: MembersControllerGetAllTeamMembersOfProjectDirectionEnum, teamMemberStatus?: Array<string>, roleIds?: Array<number>, options?: RawAxiosRequestConfig) {
        return MembersApiFp(this.configuration).membersControllerGetAllTeamMembersOfProject(projectId, page, limit, column, direction, teamMemberStatus, roleIds, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update team member details
     * @param {string} projectId 
     * @param {string} memberId 
     * @param {UpdateTeamMemberRequestDTO} updateTeamMemberRequestDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MembersApi
     */
    public membersControllerUpdateTeamMemberRole(projectId: string, memberId: string, updateTeamMemberRequestDTO: UpdateTeamMemberRequestDTO, options?: RawAxiosRequestConfig) {
        return MembersApiFp(this.configuration).membersControllerUpdateTeamMemberRole(projectId, memberId, updateTeamMemberRequestDTO, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const MembersControllerGetAllTeamMembersOfProjectDirectionEnum = {
    Asc: 'ASC',
    Desc: 'DESC'
} as const;
export type MembersControllerGetAllTeamMembersOfProjectDirectionEnum = typeof MembersControllerGetAllTeamMembersOfProjectDirectionEnum[keyof typeof MembersControllerGetAllTeamMembersOfProjectDirectionEnum];


/**
 * MiscellaneousApi - axios parameter creator
 * @export
 */
export const MiscellaneousApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get machine id matching instances.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        miscellaneousControllerGetData: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/projects/machine/images`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get machine id matching instances.
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        miscellaneousControllerGetMachineInstanceByImageId: async (projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('miscellaneousControllerGetMachineInstanceByImageId', 'projectId', projectId)
            const localVarPath = `/projects/{projectId}/allMachineInstance`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Join project
         * @param {UpdateTeamMemberStatusRequestDTO} updateTeamMemberStatusRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        miscellaneousControllerUpdateTeamMemberStatus: async (updateTeamMemberStatusRequestDTO: UpdateTeamMemberStatusRequestDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateTeamMemberStatusRequestDTO' is not null or undefined
            assertParamExists('miscellaneousControllerUpdateTeamMemberStatus', 'updateTeamMemberStatusRequestDTO', updateTeamMemberStatusRequestDTO)
            const localVarPath = `/projects/member/join`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateTeamMemberStatusRequestDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MiscellaneousApi - functional programming interface
 * @export
 */
export const MiscellaneousApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MiscellaneousApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get machine id matching instances.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async miscellaneousControllerGetData(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.miscellaneousControllerGetData(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MiscellaneousApi.miscellaneousControllerGetData']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get machine id matching instances.
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async miscellaneousControllerGetMachineInstanceByImageId(projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.miscellaneousControllerGetMachineInstanceByImageId(projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MiscellaneousApi.miscellaneousControllerGetMachineInstanceByImageId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Join project
         * @param {UpdateTeamMemberStatusRequestDTO} updateTeamMemberStatusRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async miscellaneousControllerUpdateTeamMemberStatus(updateTeamMemberStatusRequestDTO: UpdateTeamMemberStatusRequestDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddProjectMemberResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.miscellaneousControllerUpdateTeamMemberStatus(updateTeamMemberStatusRequestDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MiscellaneousApi.miscellaneousControllerUpdateTeamMemberStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MiscellaneousApi - factory interface
 * @export
 */
export const MiscellaneousApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MiscellaneousApiFp(configuration)
    return {
        /**
         * 
         * @summary Get machine id matching instances.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        miscellaneousControllerGetData(options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.miscellaneousControllerGetData(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get machine id matching instances.
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        miscellaneousControllerGetMachineInstanceByImageId(projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.miscellaneousControllerGetMachineInstanceByImageId(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Join project
         * @param {UpdateTeamMemberStatusRequestDTO} updateTeamMemberStatusRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        miscellaneousControllerUpdateTeamMemberStatus(updateTeamMemberStatusRequestDTO: UpdateTeamMemberStatusRequestDTO, options?: RawAxiosRequestConfig): AxiosPromise<AddProjectMemberResponseDTO> {
            return localVarFp.miscellaneousControllerUpdateTeamMemberStatus(updateTeamMemberStatusRequestDTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MiscellaneousApi - object-oriented interface
 * @export
 * @class MiscellaneousApi
 * @extends {BaseAPI}
 */
export class MiscellaneousApi extends BaseAPI {
    /**
     * 
     * @summary Get machine id matching instances.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MiscellaneousApi
     */
    public miscellaneousControllerGetData(options?: RawAxiosRequestConfig) {
        return MiscellaneousApiFp(this.configuration).miscellaneousControllerGetData(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get machine id matching instances.
     * @param {string} projectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MiscellaneousApi
     */
    public miscellaneousControllerGetMachineInstanceByImageId(projectId: string, options?: RawAxiosRequestConfig) {
        return MiscellaneousApiFp(this.configuration).miscellaneousControllerGetMachineInstanceByImageId(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Join project
     * @param {UpdateTeamMemberStatusRequestDTO} updateTeamMemberStatusRequestDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MiscellaneousApi
     */
    public miscellaneousControllerUpdateTeamMemberStatus(updateTeamMemberStatusRequestDTO: UpdateTeamMemberStatusRequestDTO, options?: RawAxiosRequestConfig) {
        return MiscellaneousApiFp(this.configuration).miscellaneousControllerUpdateTeamMemberStatus(updateTeamMemberStatusRequestDTO, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * NotificationsApi - axios parameter creator
 * @export
 */
export const NotificationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Retrieve last notifications
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationsControllerGetLastFiveNotifications: async (projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('notificationsControllerGetLastFiveNotifications', 'projectId', projectId)
            const localVarPath = `/projects/{projectId}/notifications`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Mark notification as read
         * @param {string} projectId 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationsControllerMarkNotificationsAsRead: async (projectId: string, body: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('notificationsControllerMarkNotificationsAsRead', 'projectId', projectId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('notificationsControllerMarkNotificationsAsRead', 'body', body)
            const localVarPath = `/projects/{projectId}/notifications/status`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NotificationsApi - functional programming interface
 * @export
 */
export const NotificationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NotificationsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Retrieve last notifications
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async notificationsControllerGetLastFiveNotifications(projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.notificationsControllerGetLastFiveNotifications(projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NotificationsApi.notificationsControllerGetLastFiveNotifications']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Mark notification as read
         * @param {string} projectId 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async notificationsControllerMarkNotificationsAsRead(projectId: string, body: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.notificationsControllerMarkNotificationsAsRead(projectId, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NotificationsApi.notificationsControllerMarkNotificationsAsRead']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * NotificationsApi - factory interface
 * @export
 */
export const NotificationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NotificationsApiFp(configuration)
    return {
        /**
         * 
         * @summary Retrieve last notifications
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationsControllerGetLastFiveNotifications(projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.notificationsControllerGetLastFiveNotifications(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Mark notification as read
         * @param {string} projectId 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationsControllerMarkNotificationsAsRead(projectId: string, body: object, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.notificationsControllerMarkNotificationsAsRead(projectId, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * NotificationsApi - object-oriented interface
 * @export
 * @class NotificationsApi
 * @extends {BaseAPI}
 */
export class NotificationsApi extends BaseAPI {
    /**
     * 
     * @summary Retrieve last notifications
     * @param {string} projectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApi
     */
    public notificationsControllerGetLastFiveNotifications(projectId: string, options?: RawAxiosRequestConfig) {
        return NotificationsApiFp(this.configuration).notificationsControllerGetLastFiveNotifications(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Mark notification as read
     * @param {string} projectId 
     * @param {object} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApi
     */
    public notificationsControllerMarkNotificationsAsRead(projectId: string, body: object, options?: RawAxiosRequestConfig) {
        return NotificationsApiFp(this.configuration).notificationsControllerMarkNotificationsAsRead(projectId, body, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProjectsApi - axios parameter creator
 * @export
 */
export const ProjectsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create Project
         * @param {CreateProjectDTO} createProjectDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectControllerCreateProject: async (createProjectDTO: CreateProjectDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createProjectDTO' is not null or undefined
            assertParamExists('projectControllerCreateProject', 'createProjectDTO', createProjectDTO)
            const localVarPath = `/projects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createProjectDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete project by id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectControllerDeleteProjectById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('projectControllerDeleteProjectById', 'id', id)
            const localVarPath = `/projects/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all projects
         * @param {number} [page] 
         * @param {number} [limit] 
         * @param {string} [column] 
         * @param {ProjectControllerGetAllProjectsDirectionEnum} [direction] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectControllerGetAllProjects: async (page?: number, limit?: number, column?: string, direction?: ProjectControllerGetAllProjectsDirectionEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/projects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (column !== undefined) {
                localVarQueryParameter['column'] = column;
            }

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get project by id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectControllerGetProjectById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('projectControllerGetProjectById', 'id', id)
            const localVarPath = `/projects/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update project by id
         * @param {string} id 
         * @param {UpdateProjectByIdRequest} updateProjectByIdRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectControllerUpdateProjectById: async (id: string, updateProjectByIdRequest: UpdateProjectByIdRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('projectControllerUpdateProjectById', 'id', id)
            // verify required parameter 'updateProjectByIdRequest' is not null or undefined
            assertParamExists('projectControllerUpdateProjectById', 'updateProjectByIdRequest', updateProjectByIdRequest)
            const localVarPath = `/projects/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateProjectByIdRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProjectsApi - functional programming interface
 * @export
 */
export const ProjectsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProjectsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create Project
         * @param {CreateProjectDTO} createProjectDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectControllerCreateProject(createProjectDTO: CreateProjectDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateProjectResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectControllerCreateProject(createProjectDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectsApi.projectControllerCreateProject']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete project by id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectControllerDeleteProjectById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteProjectResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectControllerDeleteProjectById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectsApi.projectControllerDeleteProjectById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all projects
         * @param {number} [page] 
         * @param {number} [limit] 
         * @param {string} [column] 
         * @param {ProjectControllerGetAllProjectsDirectionEnum} [direction] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectControllerGetAllProjects(page?: number, limit?: number, column?: string, direction?: ProjectControllerGetAllProjectsDirectionEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAllProjectsResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectControllerGetAllProjects(page, limit, column, direction, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectsApi.projectControllerGetAllProjects']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get project by id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectControllerGetProjectById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetProjectByIDResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectControllerGetProjectById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectsApi.projectControllerGetProjectById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update project by id
         * @param {string} id 
         * @param {UpdateProjectByIdRequest} updateProjectByIdRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectControllerUpdateProjectById(id: string, updateProjectByIdRequest: UpdateProjectByIdRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateProjectByIDResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectControllerUpdateProjectById(id, updateProjectByIdRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectsApi.projectControllerUpdateProjectById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProjectsApi - factory interface
 * @export
 */
export const ProjectsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProjectsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create Project
         * @param {CreateProjectDTO} createProjectDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectControllerCreateProject(createProjectDTO: CreateProjectDTO, options?: RawAxiosRequestConfig): AxiosPromise<CreateProjectResponseDTO> {
            return localVarFp.projectControllerCreateProject(createProjectDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete project by id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectControllerDeleteProjectById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<DeleteProjectResponseDTO> {
            return localVarFp.projectControllerDeleteProjectById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all projects
         * @param {number} [page] 
         * @param {number} [limit] 
         * @param {string} [column] 
         * @param {ProjectControllerGetAllProjectsDirectionEnum} [direction] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectControllerGetAllProjects(page?: number, limit?: number, column?: string, direction?: ProjectControllerGetAllProjectsDirectionEnum, options?: RawAxiosRequestConfig): AxiosPromise<GetAllProjectsResponseDTO> {
            return localVarFp.projectControllerGetAllProjects(page, limit, column, direction, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get project by id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectControllerGetProjectById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<GetProjectByIDResponseDTO> {
            return localVarFp.projectControllerGetProjectById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update project by id
         * @param {string} id 
         * @param {UpdateProjectByIdRequest} updateProjectByIdRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectControllerUpdateProjectById(id: string, updateProjectByIdRequest: UpdateProjectByIdRequest, options?: RawAxiosRequestConfig): AxiosPromise<UpdateProjectByIDResponseDTO> {
            return localVarFp.projectControllerUpdateProjectById(id, updateProjectByIdRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProjectsApi - object-oriented interface
 * @export
 * @class ProjectsApi
 * @extends {BaseAPI}
 */
export class ProjectsApi extends BaseAPI {
    /**
     * 
     * @summary Create Project
     * @param {CreateProjectDTO} createProjectDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public projectControllerCreateProject(createProjectDTO: CreateProjectDTO, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).projectControllerCreateProject(createProjectDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete project by id
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public projectControllerDeleteProjectById(id: string, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).projectControllerDeleteProjectById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all projects
     * @param {number} [page] 
     * @param {number} [limit] 
     * @param {string} [column] 
     * @param {ProjectControllerGetAllProjectsDirectionEnum} [direction] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public projectControllerGetAllProjects(page?: number, limit?: number, column?: string, direction?: ProjectControllerGetAllProjectsDirectionEnum, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).projectControllerGetAllProjects(page, limit, column, direction, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get project by id
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public projectControllerGetProjectById(id: string, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).projectControllerGetProjectById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update project by id
     * @param {string} id 
     * @param {UpdateProjectByIdRequest} updateProjectByIdRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public projectControllerUpdateProjectById(id: string, updateProjectByIdRequest: UpdateProjectByIdRequest, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).projectControllerUpdateProjectById(id, updateProjectByIdRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const ProjectControllerGetAllProjectsDirectionEnum = {
    Asc: 'ASC',
    Desc: 'DESC'
} as const;
export type ProjectControllerGetAllProjectsDirectionEnum = typeof ProjectControllerGetAllProjectsDirectionEnum[keyof typeof ProjectControllerGetAllProjectsDirectionEnum];


/**
 * QueriesAndDocumentationsApi - axios parameter creator
 * @export
 */
export const QueriesAndDocumentationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Fetch Swagger JSON
         * @param {string} modelId 
         * @param {string} projectId 
         * @param {string} fieldName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queriesAndDocControllerFetchSwaggerJSON: async (modelId: string, projectId: string, fieldName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'modelId' is not null or undefined
            assertParamExists('queriesAndDocControllerFetchSwaggerJSON', 'modelId', modelId)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('queriesAndDocControllerFetchSwaggerJSON', 'projectId', projectId)
            // verify required parameter 'fieldName' is not null or undefined
            assertParamExists('queriesAndDocControllerFetchSwaggerJSON', 'fieldName', fieldName)
            const localVarPath = `/projects/{projectId}/{fieldName}/{modelId}/swagger`
                .replace(`{${"modelId"}}`, encodeURIComponent(String(modelId)))
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"fieldName"}}`, encodeURIComponent(String(fieldName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Run Query
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queriesAndDocControllerRunQuery: async (projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('queriesAndDocControllerRunQuery', 'projectId', projectId)
            const localVarPath = `/projects/{projectId}/queries`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * QueriesAndDocumentationsApi - functional programming interface
 * @export
 */
export const QueriesAndDocumentationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = QueriesAndDocumentationsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Fetch Swagger JSON
         * @param {string} modelId 
         * @param {string} projectId 
         * @param {string} fieldName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async queriesAndDocControllerFetchSwaggerJSON(modelId: string, projectId: string, fieldName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.queriesAndDocControllerFetchSwaggerJSON(modelId, projectId, fieldName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['QueriesAndDocumentationsApi.queriesAndDocControllerFetchSwaggerJSON']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Run Query
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async queriesAndDocControllerRunQuery(projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateWebhookDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.queriesAndDocControllerRunQuery(projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['QueriesAndDocumentationsApi.queriesAndDocControllerRunQuery']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * QueriesAndDocumentationsApi - factory interface
 * @export
 */
export const QueriesAndDocumentationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = QueriesAndDocumentationsApiFp(configuration)
    return {
        /**
         * 
         * @summary Fetch Swagger JSON
         * @param {string} modelId 
         * @param {string} projectId 
         * @param {string} fieldName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queriesAndDocControllerFetchSwaggerJSON(modelId: string, projectId: string, fieldName: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.queriesAndDocControllerFetchSwaggerJSON(modelId, projectId, fieldName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Run Query
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queriesAndDocControllerRunQuery(projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<CreateWebhookDto> {
            return localVarFp.queriesAndDocControllerRunQuery(projectId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * QueriesAndDocumentationsApi - object-oriented interface
 * @export
 * @class QueriesAndDocumentationsApi
 * @extends {BaseAPI}
 */
export class QueriesAndDocumentationsApi extends BaseAPI {
    /**
     * 
     * @summary Fetch Swagger JSON
     * @param {string} modelId 
     * @param {string} projectId 
     * @param {string} fieldName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueriesAndDocumentationsApi
     */
    public queriesAndDocControllerFetchSwaggerJSON(modelId: string, projectId: string, fieldName: string, options?: RawAxiosRequestConfig) {
        return QueriesAndDocumentationsApiFp(this.configuration).queriesAndDocControllerFetchSwaggerJSON(modelId, projectId, fieldName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Run Query
     * @param {string} projectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueriesAndDocumentationsApi
     */
    public queriesAndDocControllerRunQuery(projectId: string, options?: RawAxiosRequestConfig) {
        return QueriesAndDocumentationsApiFp(this.configuration).queriesAndDocControllerRunQuery(projectId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RolesApi - axios parameter creator
 * @export
 */
export const RolesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new role
         * @param {string} projectId 
         * @param {CreateRoleDto} createRoleDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolesControllerCreateProjectRole: async (projectId: string, createRoleDto: CreateRoleDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('rolesControllerCreateProjectRole', 'projectId', projectId)
            // verify required parameter 'createRoleDto' is not null or undefined
            assertParamExists('rolesControllerCreateProjectRole', 'createRoleDto', createRoleDto)
            const localVarPath = `/projects/{projectId}/roles`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createRoleDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Project Role
         * @param {string} projectId 
         * @param {number} roleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolesControllerDeleteProjectRole: async (projectId: string, roleId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('rolesControllerDeleteProjectRole', 'projectId', projectId)
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('rolesControllerDeleteProjectRole', 'roleId', roleId)
            const localVarPath = `/projects/{projectId}/roles/{roleId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"roleId"}}`, encodeURIComponent(String(roleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve all roles
         * @param {string} projectId 
         * @param {number} [page] 
         * @param {number} [limit] 
         * @param {string} [column] 
         * @param {RolesControllerGetAllProjectRolesDirectionEnum} [direction] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolesControllerGetAllProjectRoles: async (projectId: string, page?: number, limit?: number, column?: string, direction?: RolesControllerGetAllProjectRolesDirectionEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('rolesControllerGetAllProjectRoles', 'projectId', projectId)
            const localVarPath = `/projects/{projectId}/roles`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (column !== undefined) {
                localVarQueryParameter['column'] = column;
            }

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a role by ID
         * @param {string} projectId 
         * @param {number} roleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolesControllerGetProjectRoleById: async (projectId: string, roleId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('rolesControllerGetProjectRoleById', 'projectId', projectId)
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('rolesControllerGetProjectRoleById', 'roleId', roleId)
            const localVarPath = `/projects/{projectId}/roles/{roleId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"roleId"}}`, encodeURIComponent(String(roleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve the role of a specific member
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolesControllerGetUserProjectRole: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('rolesControllerGetUserProjectRole', 'id', id)
            const localVarPath = `/projects/{id}/members/role`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a role
         * @param {string} projectId 
         * @param {number} roleId 
         * @param {UpdateRoleByIdDto} updateRoleByIdDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolesControllerUpdateProjectRoleById: async (projectId: string, roleId: number, updateRoleByIdDto: UpdateRoleByIdDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('rolesControllerUpdateProjectRoleById', 'projectId', projectId)
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('rolesControllerUpdateProjectRoleById', 'roleId', roleId)
            // verify required parameter 'updateRoleByIdDto' is not null or undefined
            assertParamExists('rolesControllerUpdateProjectRoleById', 'updateRoleByIdDto', updateRoleByIdDto)
            const localVarPath = `/projects/{projectId}/roles/{roleId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"roleId"}}`, encodeURIComponent(String(roleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateRoleByIdDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RolesApi - functional programming interface
 * @export
 */
export const RolesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RolesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new role
         * @param {string} projectId 
         * @param {CreateRoleDto} createRoleDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rolesControllerCreateProjectRole(projectId: string, createRoleDto: CreateRoleDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateProjectRoleResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rolesControllerCreateProjectRole(projectId, createRoleDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RolesApi.rolesControllerCreateProjectRole']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete Project Role
         * @param {string} projectId 
         * @param {number} roleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rolesControllerDeleteProjectRole(projectId: string, roleId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteProjectRoleByIdResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rolesControllerDeleteProjectRole(projectId, roleId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RolesApi.rolesControllerDeleteProjectRole']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve all roles
         * @param {string} projectId 
         * @param {number} [page] 
         * @param {number} [limit] 
         * @param {string} [column] 
         * @param {RolesControllerGetAllProjectRolesDirectionEnum} [direction] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rolesControllerGetAllProjectRoles(projectId: string, page?: number, limit?: number, column?: string, direction?: RolesControllerGetAllProjectRolesDirectionEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAllProjectRoleResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rolesControllerGetAllProjectRoles(projectId, page, limit, column, direction, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RolesApi.rolesControllerGetAllProjectRoles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve a role by ID
         * @param {string} projectId 
         * @param {number} roleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rolesControllerGetProjectRoleById(projectId: string, roleId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetProjectRoleByIdResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rolesControllerGetProjectRoleById(projectId, roleId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RolesApi.rolesControllerGetProjectRoleById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve the role of a specific member
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rolesControllerGetUserProjectRole(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUserProjectRoleByRoleIdResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rolesControllerGetUserProjectRole(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RolesApi.rolesControllerGetUserProjectRole']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a role
         * @param {string} projectId 
         * @param {number} roleId 
         * @param {UpdateRoleByIdDto} updateRoleByIdDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rolesControllerUpdateProjectRoleById(projectId: string, roleId: number, updateRoleByIdDto: UpdateRoleByIdDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateProjectRoleResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rolesControllerUpdateProjectRoleById(projectId, roleId, updateRoleByIdDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RolesApi.rolesControllerUpdateProjectRoleById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RolesApi - factory interface
 * @export
 */
export const RolesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RolesApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new role
         * @param {string} projectId 
         * @param {CreateRoleDto} createRoleDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolesControllerCreateProjectRole(projectId: string, createRoleDto: CreateRoleDto, options?: RawAxiosRequestConfig): AxiosPromise<CreateProjectRoleResponseDto> {
            return localVarFp.rolesControllerCreateProjectRole(projectId, createRoleDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Project Role
         * @param {string} projectId 
         * @param {number} roleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolesControllerDeleteProjectRole(projectId: string, roleId: number, options?: RawAxiosRequestConfig): AxiosPromise<DeleteProjectRoleByIdResponseDto> {
            return localVarFp.rolesControllerDeleteProjectRole(projectId, roleId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve all roles
         * @param {string} projectId 
         * @param {number} [page] 
         * @param {number} [limit] 
         * @param {string} [column] 
         * @param {RolesControllerGetAllProjectRolesDirectionEnum} [direction] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolesControllerGetAllProjectRoles(projectId: string, page?: number, limit?: number, column?: string, direction?: RolesControllerGetAllProjectRolesDirectionEnum, options?: RawAxiosRequestConfig): AxiosPromise<GetAllProjectRoleResponseDto> {
            return localVarFp.rolesControllerGetAllProjectRoles(projectId, page, limit, column, direction, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a role by ID
         * @param {string} projectId 
         * @param {number} roleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolesControllerGetProjectRoleById(projectId: string, roleId: number, options?: RawAxiosRequestConfig): AxiosPromise<GetProjectRoleByIdResponseDto> {
            return localVarFp.rolesControllerGetProjectRoleById(projectId, roleId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve the role of a specific member
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolesControllerGetUserProjectRole(id: string, options?: RawAxiosRequestConfig): AxiosPromise<GetUserProjectRoleByRoleIdResponseDto> {
            return localVarFp.rolesControllerGetUserProjectRole(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a role
         * @param {string} projectId 
         * @param {number} roleId 
         * @param {UpdateRoleByIdDto} updateRoleByIdDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolesControllerUpdateProjectRoleById(projectId: string, roleId: number, updateRoleByIdDto: UpdateRoleByIdDto, options?: RawAxiosRequestConfig): AxiosPromise<UpdateProjectRoleResponseDto> {
            return localVarFp.rolesControllerUpdateProjectRoleById(projectId, roleId, updateRoleByIdDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RolesApi - object-oriented interface
 * @export
 * @class RolesApi
 * @extends {BaseAPI}
 */
export class RolesApi extends BaseAPI {
    /**
     * 
     * @summary Create a new role
     * @param {string} projectId 
     * @param {CreateRoleDto} createRoleDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public rolesControllerCreateProjectRole(projectId: string, createRoleDto: CreateRoleDto, options?: RawAxiosRequestConfig) {
        return RolesApiFp(this.configuration).rolesControllerCreateProjectRole(projectId, createRoleDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Project Role
     * @param {string} projectId 
     * @param {number} roleId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public rolesControllerDeleteProjectRole(projectId: string, roleId: number, options?: RawAxiosRequestConfig) {
        return RolesApiFp(this.configuration).rolesControllerDeleteProjectRole(projectId, roleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve all roles
     * @param {string} projectId 
     * @param {number} [page] 
     * @param {number} [limit] 
     * @param {string} [column] 
     * @param {RolesControllerGetAllProjectRolesDirectionEnum} [direction] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public rolesControllerGetAllProjectRoles(projectId: string, page?: number, limit?: number, column?: string, direction?: RolesControllerGetAllProjectRolesDirectionEnum, options?: RawAxiosRequestConfig) {
        return RolesApiFp(this.configuration).rolesControllerGetAllProjectRoles(projectId, page, limit, column, direction, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a role by ID
     * @param {string} projectId 
     * @param {number} roleId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public rolesControllerGetProjectRoleById(projectId: string, roleId: number, options?: RawAxiosRequestConfig) {
        return RolesApiFp(this.configuration).rolesControllerGetProjectRoleById(projectId, roleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve the role of a specific member
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public rolesControllerGetUserProjectRole(id: string, options?: RawAxiosRequestConfig) {
        return RolesApiFp(this.configuration).rolesControllerGetUserProjectRole(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a role
     * @param {string} projectId 
     * @param {number} roleId 
     * @param {UpdateRoleByIdDto} updateRoleByIdDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public rolesControllerUpdateProjectRoleById(projectId: string, roleId: number, updateRoleByIdDto: UpdateRoleByIdDto, options?: RawAxiosRequestConfig) {
        return RolesApiFp(this.configuration).rolesControllerUpdateProjectRoleById(projectId, roleId, updateRoleByIdDto, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const RolesControllerGetAllProjectRolesDirectionEnum = {
    Asc: 'ASC',
    Desc: 'DESC'
} as const;
export type RolesControllerGetAllProjectRolesDirectionEnum = typeof RolesControllerGetAllProjectRolesDirectionEnum[keyof typeof RolesControllerGetAllProjectRolesDirectionEnum];


/**
 * WebhookApi - axios parameter creator
 * @export
 */
export const WebhookApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create webhook
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookControllerCreateWebhook: async (projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('webhookControllerCreateWebhook', 'projectId', projectId)
            const localVarPath = `/projects/{projectId}/webhooks`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete webhook
         * @param {string} projectId 
         * @param {string} modelId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookControllerDeleteWebhook: async (projectId: string, modelId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('webhookControllerDeleteWebhook', 'projectId', projectId)
            // verify required parameter 'modelId' is not null or undefined
            assertParamExists('webhookControllerDeleteWebhook', 'modelId', modelId)
            const localVarPath = `/projects/{projectId}/webhooks/{modelId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"modelId"}}`, encodeURIComponent(String(modelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Fetch webhook
         * @param {string} projectId 
         * @param {string} modelId 
         * @param {boolean} isAgentWebhook 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookControllerFetchWebhook: async (projectId: string, modelId: string, isAgentWebhook: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('webhookControllerFetchWebhook', 'projectId', projectId)
            // verify required parameter 'modelId' is not null or undefined
            assertParamExists('webhookControllerFetchWebhook', 'modelId', modelId)
            // verify required parameter 'isAgentWebhook' is not null or undefined
            assertParamExists('webhookControllerFetchWebhook', 'isAgentWebhook', isAgentWebhook)
            const localVarPath = `/projects/{projectId}/webhooks/{modelId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"modelId"}}`, encodeURIComponent(String(modelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (isAgentWebhook !== undefined) {
                localVarQueryParameter['isAgentWebhook'] = isAgentWebhook;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update webhook
         * @param {string} webhookId 
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookControllerUpdateWebhook: async (webhookId: string, projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'webhookId' is not null or undefined
            assertParamExists('webhookControllerUpdateWebhook', 'webhookId', webhookId)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('webhookControllerUpdateWebhook', 'projectId', projectId)
            const localVarPath = `/projects/{projectId}/webhooks/{webhookId}`
                .replace(`{${"webhookId"}}`, encodeURIComponent(String(webhookId)))
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WebhookApi - functional programming interface
 * @export
 */
export const WebhookApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WebhookApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create webhook
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async webhookControllerCreateWebhook(projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateWebhookDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.webhookControllerCreateWebhook(projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhookApi.webhookControllerCreateWebhook']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete webhook
         * @param {string} projectId 
         * @param {string} modelId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async webhookControllerDeleteWebhook(projectId: string, modelId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateWebhookDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.webhookControllerDeleteWebhook(projectId, modelId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhookApi.webhookControllerDeleteWebhook']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Fetch webhook
         * @param {string} projectId 
         * @param {string} modelId 
         * @param {boolean} isAgentWebhook 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async webhookControllerFetchWebhook(projectId: string, modelId: string, isAgentWebhook: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateWebhookDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.webhookControllerFetchWebhook(projectId, modelId, isAgentWebhook, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhookApi.webhookControllerFetchWebhook']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update webhook
         * @param {string} webhookId 
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async webhookControllerUpdateWebhook(webhookId: string, projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateWebhookDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.webhookControllerUpdateWebhook(webhookId, projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhookApi.webhookControllerUpdateWebhook']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * WebhookApi - factory interface
 * @export
 */
export const WebhookApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WebhookApiFp(configuration)
    return {
        /**
         * 
         * @summary Create webhook
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookControllerCreateWebhook(projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<CreateWebhookDto> {
            return localVarFp.webhookControllerCreateWebhook(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete webhook
         * @param {string} projectId 
         * @param {string} modelId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookControllerDeleteWebhook(projectId: string, modelId: string, options?: RawAxiosRequestConfig): AxiosPromise<CreateWebhookDto> {
            return localVarFp.webhookControllerDeleteWebhook(projectId, modelId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Fetch webhook
         * @param {string} projectId 
         * @param {string} modelId 
         * @param {boolean} isAgentWebhook 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookControllerFetchWebhook(projectId: string, modelId: string, isAgentWebhook: boolean, options?: RawAxiosRequestConfig): AxiosPromise<CreateWebhookDto> {
            return localVarFp.webhookControllerFetchWebhook(projectId, modelId, isAgentWebhook, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update webhook
         * @param {string} webhookId 
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookControllerUpdateWebhook(webhookId: string, projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<CreateWebhookDto> {
            return localVarFp.webhookControllerUpdateWebhook(webhookId, projectId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WebhookApi - object-oriented interface
 * @export
 * @class WebhookApi
 * @extends {BaseAPI}
 */
export class WebhookApi extends BaseAPI {
    /**
     * 
     * @summary Create webhook
     * @param {string} projectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    public webhookControllerCreateWebhook(projectId: string, options?: RawAxiosRequestConfig) {
        return WebhookApiFp(this.configuration).webhookControllerCreateWebhook(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete webhook
     * @param {string} projectId 
     * @param {string} modelId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    public webhookControllerDeleteWebhook(projectId: string, modelId: string, options?: RawAxiosRequestConfig) {
        return WebhookApiFp(this.configuration).webhookControllerDeleteWebhook(projectId, modelId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Fetch webhook
     * @param {string} projectId 
     * @param {string} modelId 
     * @param {boolean} isAgentWebhook 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    public webhookControllerFetchWebhook(projectId: string, modelId: string, isAgentWebhook: boolean, options?: RawAxiosRequestConfig) {
        return WebhookApiFp(this.configuration).webhookControllerFetchWebhook(projectId, modelId, isAgentWebhook, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update webhook
     * @param {string} webhookId 
     * @param {string} projectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    public webhookControllerUpdateWebhook(webhookId: string, projectId: string, options?: RawAxiosRequestConfig) {
        return WebhookApiFp(this.configuration).webhookControllerUpdateWebhook(webhookId, projectId, options).then((request) => request(this.axios, this.basePath));
    }
}



