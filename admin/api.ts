/* tslint:disable */
/* eslint-disable */
/**
 * Nestbox API Admin
 * API for Nestbox Admin, control your resources
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction, replaceWithSerializableTypeIfNeeded } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

export interface AddProjectMemberData {
    'message': string;
    'project': object;
}
export interface AddProjectMemberDto {
    'firstName': string;
    'lastName': string;
    'email': string;
    'roleId': number;
}
export interface AddProjectMemberResponseDTO {
    'data': AddProjectMemberData;
}
export interface AllProjectResponse {
    'id': string;
    'name': string;
    'description': string;
    'createdAt': string;
    'updatedAt': string;
    'deletedAt': string;
}
export interface AllProjectResponseModel {
    'projects': Array<AllProjectResponse>;
    'totalCount': number;
}
export interface BadRequestExceptionResponse {
    'message': string;
    'errors': object | null;
}
export interface BenchmarkingDatapointDto {
    /**
     * Combined content of all benchmarking lines
     */
    'lines': string;
    /**
     * Total number of lines found
     */
    'totalLines': number;
}
export interface BenchmarkingReportsDto {
    /**
     * Combined markdown content of all benchmarking reports
     */
    'content': string;
    /**
     * Total number of reports found
     */
    'totalReports': number;
}
export interface BooleanResponseDTO {
    'data': boolean;
}
export interface ChunkFileRequestDTO {
    'type': string;
    'url': string;
    'options': object;
}
export interface CreateCollectionRequestDTO {
    'name': string;
    'metadata': object;
}
export interface CreateDocumentRequestDTO {
    'id': string;
    'document': string;
    'metadata': object;
}
export interface CreateMachineAgentDto {
    'agentName': string;
    'goal': string;
    'modelBaseId': string;
    'machineName': string;
    'machineInstanceId': number;
    'instanceIP': string;
    'entryFunctionName': string;
    'machineManifestId': string;
    'type': string;
    'projectId': string;
    'userId': number;
    /**
     * Optional Input Schema JSON for agent.
     */
    'inputSchema'?: object;
}
export interface CreatePermissionDto {
    'read': boolean;
    'write': boolean;
    'update': boolean;
    'delete': boolean;
}
export interface CreateProjectDTO {
    'name': string;
    'description': string;
}
export interface CreateProjectResponseDTO {
    'data': ProjectResponseModel;
}
export interface CreateProjectRoleResponseDto {
    'data': CreateRoleDTO;
}
export interface CreateResourceDto {
    'name': string;
    'permissions': Array<CreatePermissionDto>;
}
export interface CreateRoleDTO {
    'id': number;
    'name': string;
    'description': string;
    'resources': Array<ResourceDTO>;
}
export interface CreateRoleDto {
    'name': string;
    'description': string;
    'resources': Array<CreateResourceDto>;
}
export interface CreateWebhookDto {
    /**
     * The URL for the webhook
     */
    'url': string;
    /**
     * Comma-separated notifications. Valid values: QUERY_CREATED, QUERY_COMPLETED, QUERY_FAILED, EVENT_CREATED, EVENT_UPDATED
     */
    'notifications': string;
}
export interface DeleteProjectDto {
    'message': string;
}
export interface DeleteProjectResponseDTO {
    'message': string;
}
export interface DeleteProjectRoleByIdResponseDto {
    'data': DeleteProjectDto;
}
export interface FatalErrorExceptionResponse {
    'message': string;
}
export interface ForbiddenExceptionResponse {
    'message': string;
}
export interface ForgetPasswordRequestDTO {
    'email': string;
}
export interface ForgetPasswordResponseDTO {
    'token': string;
}
export interface ForgetPasswordVerificationRequestDTO {
    'token': string;
}
export interface ForgetPasswordVerificationResponseDTO {
    'token': string;
}
export interface GetAllProjectDto {
    'roles': Array<GetAllRoleDTO>;
    'totalCount': number;
}
export interface GetAllProjectMemberResponse {
    'teamMembers': Array<TeamMemberDto>;
    'totalCount': number;
}
export interface GetAllProjectMemberResponseDto {
    'data': GetAllProjectMemberResponse;
}
export interface GetAllProjectRoleResponseDto {
    'data': GetAllProjectDto;
}
export interface GetAllProjectsResponseDTO {
    'data': AllProjectResponseModel;
}
export interface GetAllRoleDTO {
    'id': number;
    'name': string;
    'description': string;
    'projectId': string;
    'createdAt': string;
    'updatedAt': string;
    'deletedAt': string;
}
export interface GetProjectByIDResponseDTO {
    'data': ProjectResponseModel;
}
export interface GetProjectRoleByIdResponseDto {
    'data': GetRoleDTO;
}
export interface GetRoleDTO {
    'id': number;
    'name': string;
    'description': string;
    'resources': Array<ResourceDTO>;
}
export interface GetUserProjectRoleByRoleIdResponseDto {
    'data': GetRoleDTO;
}
export interface LoginRequestDTO {
    /**
     * Email
     */
    'email': string;
    /**
     * Password
     */
    'password': string;
}
export interface LoginResponseDTO {
    /**
     * Token
     */
    'token': string;
}
export interface MachineStatusDto {
    /**
     * Current status of the machine instance
     */
    'status': string;
    /**
     * Logs from the machine instance execution
     */
    'logs': string;
    /**
     * Timestamp of the status update
     */
    'timeStamp': string;
}
export interface MessageResponseDTO {
    'message': string;
}
export interface NotFoundExceptionResponse {
    'message': string;
}
export interface OAuthLoginRequestDTO {
    'providerId': string;
    'type': OAuthLoginRequestDTOTypeEnum;
    'email': string;
    'profilePictureUrl': string;
}

export const OAuthLoginRequestDTOTypeEnum = {
    Google: 'GOOGLE',
    Apple: 'APPLE'
} as const;

export type OAuthLoginRequestDTOTypeEnum = typeof OAuthLoginRequestDTOTypeEnum[keyof typeof OAuthLoginRequestDTOTypeEnum];

export interface PermissionsDTO {
    'id': number;
    'read': boolean;
    'write': boolean;
    'update': boolean;
    'delete': boolean;
}
export interface ProjectResponseModel {
    'id': string;
    'name': string;
    'description': string;
    'createdAt': string;
    'updatedAt': string;
    'deletedAt': string;
}
export interface ResetPasswordRequestDTO {
    'token': string;
    'password': string;
}
export interface ResourceDTO {
    'id': number;
    'name': string;
    'permissions': Array<PermissionsDTO>;
}
export interface RoleDto {
    'id': number;
    'name': string;
}
export interface SignupRequestDTO {
    'email': string;
    'password'?: string;
    'firstName': string;
    'lastName': string;
    'phone': string;
    'providerId'?: string;
    'providerType'?: SignupRequestDTOProviderTypeEnum;
    'image'?: string;
    'profilePictureUrl': string;
}

export const SignupRequestDTOProviderTypeEnum = {
    Google: 'GOOGLE',
    Apple: 'APPLE'
} as const;

export type SignupRequestDTOProviderTypeEnum = typeof SignupRequestDTOProviderTypeEnum[keyof typeof SignupRequestDTOProviderTypeEnum];

export interface SignupResponseDTO {
    /**
     * Token
     */
    'token': string;
}
export interface SimilaritySearchQueryDTO {
    'query': string;
    'params': object;
    'filter': object;
    'include': Array<string>;
}
export interface TeamMemberDto {
    'id': number;
    'status': string;
    'user': UserDto;
    'role': RoleDto;
}
export interface UnauthorizedExceptionResponse {
    'message': string;
}
export interface UpdateDocumentRequestDTO {
    'document': string;
    'metadata': object;
}
export interface UpdatePermissionDto {
    'id': number;
    'read': boolean;
    'write': boolean;
    'update': boolean;
    'delete': boolean;
}
export interface UpdateProjectByIDResponseDTO {
    'data': ProjectResponseModel;
}
export interface UpdateProjectByIdRequest {
    'name': string;
    'description': string;
}
export interface UpdateProjectRoleResponseDto {
    'data': UpdateRoleDTO;
}
export interface UpdateResourceDto {
    'id': number;
    'name': string;
    'permissions': Array<UpdatePermissionDto>;
}
export interface UpdateRoleByIdDto {
    'name': string;
    'description': string;
    'resources': Array<UpdateResourceDto>;
}
export interface UpdateRoleDTO {
    'id': number;
    'name': string;
    'description': string;
    'resources': Array<ResourceDTO>;
}
export interface UpdateTeamMemberRequestDTO {
    'roleId': number;
}
export interface UpdateTeamMemberStatusRequestDTO {
    'status': string;
    'token': string;
}
export interface UserDto {
    'id': number;
    'firstName': string;
    'lastName': string;
    'email': string;
    'status': string;
    'profilePicture': string;
    'bio': string;
}

/**
 * AuthApi - axios parameter creator
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Exchange token
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerExchangeToken: async (token: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('authControllerExchangeToken', 'token', token)
            const localVarPath = `/auth/google/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Forget password initiate
         * @param {ForgetPasswordRequestDTO} forgetPasswordRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerForgetPassword: async (forgetPasswordRequestDTO: ForgetPasswordRequestDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'forgetPasswordRequestDTO' is not null or undefined
            assertParamExists('authControllerForgetPassword', 'forgetPasswordRequestDTO', forgetPasswordRequestDTO)
            const localVarPath = `/auth/forget-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(forgetPasswordRequestDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Forget password verification
         * @param {ForgetPasswordVerificationRequestDTO} forgetPasswordVerificationRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerForgetPasswordVerification: async (forgetPasswordVerificationRequestDTO: ForgetPasswordVerificationRequestDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'forgetPasswordVerificationRequestDTO' is not null or undefined
            assertParamExists('authControllerForgetPasswordVerification', 'forgetPasswordVerificationRequestDTO', forgetPasswordVerificationRequestDTO)
            const localVarPath = `/auth/forget-password/verification`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(forgetPasswordVerificationRequestDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Login to the application
         * @param {LoginRequestDTO} loginRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerLogin: async (loginRequestDTO: LoginRequestDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginRequestDTO' is not null or undefined
            assertParamExists('authControllerLogin', 'loginRequestDTO', loginRequestDTO)
            const localVarPath = `/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginRequestDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Login with OAuth apps
         * @param {OAuthLoginRequestDTO} oAuthLoginRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerOAuthLogin: async (oAuthLoginRequestDTO: OAuthLoginRequestDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'oAuthLoginRequestDTO' is not null or undefined
            assertParamExists('authControllerOAuthLogin', 'oAuthLoginRequestDTO', oAuthLoginRequestDTO)
            const localVarPath = `/auth/login/oauth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(oAuthLoginRequestDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Refresh Google access token
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerRefreshToken: async (token: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('authControllerRefreshToken', 'token', token)
            const localVarPath = `/auth/google/refresh/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Forget password initiate
         * @param {ResetPasswordRequestDTO} resetPasswordRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerResetPassword: async (resetPasswordRequestDTO: ResetPasswordRequestDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'resetPasswordRequestDTO' is not null or undefined
            assertParamExists('authControllerResetPassword', 'resetPasswordRequestDTO', resetPasswordRequestDTO)
            const localVarPath = `/auth/reset-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(resetPasswordRequestDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Signup in the application
         * @param {SignupRequestDTO} signupRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerSignup: async (signupRequestDTO: SignupRequestDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'signupRequestDTO' is not null or undefined
            assertParamExists('authControllerSignup', 'signupRequestDTO', signupRequestDTO)
            const localVarPath = `/auth/signup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(signupRequestDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Exchange token
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerExchangeToken(token: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerExchangeToken(token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authControllerExchangeToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Forget password initiate
         * @param {ForgetPasswordRequestDTO} forgetPasswordRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerForgetPassword(forgetPasswordRequestDTO: ForgetPasswordRequestDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ForgetPasswordResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerForgetPassword(forgetPasswordRequestDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authControllerForgetPassword']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Forget password verification
         * @param {ForgetPasswordVerificationRequestDTO} forgetPasswordVerificationRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerForgetPasswordVerification(forgetPasswordVerificationRequestDTO: ForgetPasswordVerificationRequestDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ForgetPasswordVerificationResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerForgetPasswordVerification(forgetPasswordVerificationRequestDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authControllerForgetPasswordVerification']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Login to the application
         * @param {LoginRequestDTO} loginRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerLogin(loginRequestDTO: LoginRequestDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerLogin(loginRequestDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authControllerLogin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Login with OAuth apps
         * @param {OAuthLoginRequestDTO} oAuthLoginRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerOAuthLogin(oAuthLoginRequestDTO: OAuthLoginRequestDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerOAuthLogin(oAuthLoginRequestDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authControllerOAuthLogin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Refresh Google access token
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerRefreshToken(token: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerRefreshToken(token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authControllerRefreshToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Forget password initiate
         * @param {ResetPasswordRequestDTO} resetPasswordRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerResetPassword(resetPasswordRequestDTO: ResetPasswordRequestDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BooleanResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerResetPassword(resetPasswordRequestDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authControllerResetPassword']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Signup in the application
         * @param {SignupRequestDTO} signupRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerSignup(signupRequestDTO: SignupRequestDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SignupResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerSignup(signupRequestDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authControllerSignup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthApi - factory interface
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * 
         * @summary Exchange token
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerExchangeToken(token: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.authControllerExchangeToken(token, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Forget password initiate
         * @param {ForgetPasswordRequestDTO} forgetPasswordRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerForgetPassword(forgetPasswordRequestDTO: ForgetPasswordRequestDTO, options?: RawAxiosRequestConfig): AxiosPromise<ForgetPasswordResponseDTO> {
            return localVarFp.authControllerForgetPassword(forgetPasswordRequestDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Forget password verification
         * @param {ForgetPasswordVerificationRequestDTO} forgetPasswordVerificationRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerForgetPasswordVerification(forgetPasswordVerificationRequestDTO: ForgetPasswordVerificationRequestDTO, options?: RawAxiosRequestConfig): AxiosPromise<ForgetPasswordVerificationResponseDTO> {
            return localVarFp.authControllerForgetPasswordVerification(forgetPasswordVerificationRequestDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Login to the application
         * @param {LoginRequestDTO} loginRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerLogin(loginRequestDTO: LoginRequestDTO, options?: RawAxiosRequestConfig): AxiosPromise<LoginResponseDTO> {
            return localVarFp.authControllerLogin(loginRequestDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Login with OAuth apps
         * @param {OAuthLoginRequestDTO} oAuthLoginRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerOAuthLogin(oAuthLoginRequestDTO: OAuthLoginRequestDTO, options?: RawAxiosRequestConfig): AxiosPromise<LoginResponseDTO> {
            return localVarFp.authControllerOAuthLogin(oAuthLoginRequestDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Refresh Google access token
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerRefreshToken(token: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.authControllerRefreshToken(token, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Forget password initiate
         * @param {ResetPasswordRequestDTO} resetPasswordRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerResetPassword(resetPasswordRequestDTO: ResetPasswordRequestDTO, options?: RawAxiosRequestConfig): AxiosPromise<BooleanResponseDTO> {
            return localVarFp.authControllerResetPassword(resetPasswordRequestDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Signup in the application
         * @param {SignupRequestDTO} signupRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerSignup(signupRequestDTO: SignupRequestDTO, options?: RawAxiosRequestConfig): AxiosPromise<SignupResponseDTO> {
            return localVarFp.authControllerSignup(signupRequestDTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 */
export class AuthApi extends BaseAPI {
    /**
     * 
     * @summary Exchange token
     * @param {string} token 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public authControllerExchangeToken(token: string, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerExchangeToken(token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Forget password initiate
     * @param {ForgetPasswordRequestDTO} forgetPasswordRequestDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public authControllerForgetPassword(forgetPasswordRequestDTO: ForgetPasswordRequestDTO, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerForgetPassword(forgetPasswordRequestDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Forget password verification
     * @param {ForgetPasswordVerificationRequestDTO} forgetPasswordVerificationRequestDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public authControllerForgetPasswordVerification(forgetPasswordVerificationRequestDTO: ForgetPasswordVerificationRequestDTO, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerForgetPasswordVerification(forgetPasswordVerificationRequestDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Login to the application
     * @param {LoginRequestDTO} loginRequestDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public authControllerLogin(loginRequestDTO: LoginRequestDTO, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerLogin(loginRequestDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Login with OAuth apps
     * @param {OAuthLoginRequestDTO} oAuthLoginRequestDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public authControllerOAuthLogin(oAuthLoginRequestDTO: OAuthLoginRequestDTO, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerOAuthLogin(oAuthLoginRequestDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Refresh Google access token
     * @param {string} token 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public authControllerRefreshToken(token: string, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerRefreshToken(token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Forget password initiate
     * @param {ResetPasswordRequestDTO} resetPasswordRequestDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public authControllerResetPassword(resetPasswordRequestDTO: ResetPasswordRequestDTO, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerResetPassword(resetPasswordRequestDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Signup in the application
     * @param {SignupRequestDTO} signupRequestDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public authControllerSignup(signupRequestDTO: SignupRequestDTO, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerSignup(signupRequestDTO, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DocumentProcessingApi - axios parameter creator
 */
export const DocumentProcessingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create batch query from YAML file (multipart)
         * @param {string} projectId 
         * @param {string} instanceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentProcessingControllerCreateBatchQuery: async (projectId: string, instanceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('documentProcessingControllerCreateBatchQuery', 'projectId', projectId)
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('documentProcessingControllerCreateBatchQuery', 'instanceId', instanceId)
            const localVarPath = `/projects/{projectId}/document-processing/{instanceId}/queries`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create document processing job by uploading file (multipart)
         * @param {string} projectId 
         * @param {string} instanceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentProcessingControllerCreateDocumentProcessingJob: async (projectId: string, instanceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('documentProcessingControllerCreateDocumentProcessingJob', 'projectId', projectId)
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('documentProcessingControllerCreateDocumentProcessingJob', 'instanceId', instanceId)
            const localVarPath = `/projects/{projectId}/document-processing/{instanceId}/documents`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create evaluation from YAML file (multipart)
         * @param {string} projectId 
         * @param {string} instanceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentProcessingControllerCreateEval: async (projectId: string, instanceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('documentProcessingControllerCreateEval', 'projectId', projectId)
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('documentProcessingControllerCreateEval', 'instanceId', instanceId)
            const localVarPath = `/projects/{projectId}/document-processing/{instanceId}/evals`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create processing profile from YAML file (multipart)
         * @param {string} projectId 
         * @param {string} instanceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentProcessingControllerCreateProfile: async (projectId: string, instanceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('documentProcessingControllerCreateProfile', 'projectId', projectId)
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('documentProcessingControllerCreateProfile', 'instanceId', instanceId)
            const localVarPath = `/projects/{projectId}/document-processing/{instanceId}/profiles`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create webhook for receiving notifications
         * @param {string} projectId 
         * @param {string} instanceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentProcessingControllerCreateWebhook: async (projectId: string, instanceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('documentProcessingControllerCreateWebhook', 'projectId', projectId)
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('documentProcessingControllerCreateWebhook', 'instanceId', instanceId)
            const localVarPath = `/projects/{projectId}/document-processing/{instanceId}/webhooks`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete webhook
         * @param {string} projectId 
         * @param {string} instanceId 
         * @param {string} webhookId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentProcessingControllerDeleteWebhook: async (projectId: string, instanceId: string, webhookId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('documentProcessingControllerDeleteWebhook', 'projectId', projectId)
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('documentProcessingControllerDeleteWebhook', 'instanceId', instanceId)
            // verify required parameter 'webhookId' is not null or undefined
            assertParamExists('documentProcessingControllerDeleteWebhook', 'webhookId', webhookId)
            const localVarPath = `/projects/{projectId}/document-processing/{instanceId}/webhooks/{webhookId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)))
                .replace(`{${"webhookId"}}`, encodeURIComponent(String(webhookId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Download document artifacts as archive
         * @param {string} projectId 
         * @param {string} instanceId 
         * @param {string} documentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentProcessingControllerDownloadDocumentArtifacts: async (projectId: string, instanceId: string, documentId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('documentProcessingControllerDownloadDocumentArtifacts', 'projectId', projectId)
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('documentProcessingControllerDownloadDocumentArtifacts', 'instanceId', instanceId)
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('documentProcessingControllerDownloadDocumentArtifacts', 'documentId', documentId)
            const localVarPath = `/projects/{projectId}/document-processing/{instanceId}/documents/{documentId}/artifacts`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)))
                .replace(`{${"documentId"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get processed document by ID
         * @param {string} projectId 
         * @param {string} instanceId 
         * @param {string} documentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentProcessingControllerGetDocument: async (projectId: string, instanceId: string, documentId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('documentProcessingControllerGetDocument', 'projectId', projectId)
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('documentProcessingControllerGetDocument', 'instanceId', instanceId)
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('documentProcessingControllerGetDocument', 'documentId', documentId)
            const localVarPath = `/projects/{projectId}/document-processing/{instanceId}/documents/{documentId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)))
                .replace(`{${"documentId"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get evaluation details by document ID and eval ID
         * @param {string} projectId 
         * @param {string} instanceId 
         * @param {string} documentId 
         * @param {string} evalId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentProcessingControllerGetEval: async (projectId: string, instanceId: string, documentId: string, evalId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('documentProcessingControllerGetEval', 'projectId', projectId)
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('documentProcessingControllerGetEval', 'instanceId', instanceId)
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('documentProcessingControllerGetEval', 'documentId', documentId)
            // verify required parameter 'evalId' is not null or undefined
            assertParamExists('documentProcessingControllerGetEval', 'evalId', evalId)
            const localVarPath = `/projects/{projectId}/document-processing/{instanceId}/documents/{documentId}/evals/{evalId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)))
                .replace(`{${"documentId"}}`, encodeURIComponent(String(documentId)))
                .replace(`{${"evalId"}}`, encodeURIComponent(String(evalId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get document processing API client health
         * @param {string} projectId 
         * @param {string} instanceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentProcessingControllerGetHealth: async (projectId: string, instanceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('documentProcessingControllerGetHealth', 'projectId', projectId)
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('documentProcessingControllerGetHealth', 'instanceId', instanceId)
            const localVarPath = `/projects/{projectId}/document-processing/{instanceId}/health`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get processing job details by ID
         * @param {string} projectId 
         * @param {string} instanceId 
         * @param {string} jobId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentProcessingControllerGetJob: async (projectId: string, instanceId: string, jobId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('documentProcessingControllerGetJob', 'projectId', projectId)
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('documentProcessingControllerGetJob', 'instanceId', instanceId)
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('documentProcessingControllerGetJob', 'jobId', jobId)
            const localVarPath = `/projects/{projectId}/document-processing/{instanceId}/jobs/{jobId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)))
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get processing job status (lightweight)
         * @param {string} projectId 
         * @param {string} instanceId 
         * @param {string} jobId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentProcessingControllerGetJobStatus: async (projectId: string, instanceId: string, jobId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('documentProcessingControllerGetJobStatus', 'projectId', projectId)
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('documentProcessingControllerGetJobStatus', 'instanceId', instanceId)
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('documentProcessingControllerGetJobStatus', 'jobId', jobId)
            const localVarPath = `/projects/{projectId}/document-processing/{instanceId}/jobs/{jobId}/status`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)))
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get processing profile by ID
         * @param {string} projectId 
         * @param {string} instanceId 
         * @param {string} profileId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentProcessingControllerGetProfile: async (projectId: string, instanceId: string, profileId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('documentProcessingControllerGetProfile', 'projectId', projectId)
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('documentProcessingControllerGetProfile', 'instanceId', instanceId)
            // verify required parameter 'profileId' is not null or undefined
            assertParamExists('documentProcessingControllerGetProfile', 'profileId', profileId)
            const localVarPath = `/projects/{projectId}/document-processing/{instanceId}/profiles/{profileId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)))
                .replace(`{${"profileId"}}`, encodeURIComponent(String(profileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get profile schema for YAML configuration
         * @param {string} projectId 
         * @param {string} instanceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentProcessingControllerGetProfileSchema: async (projectId: string, instanceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('documentProcessingControllerGetProfileSchema', 'projectId', projectId)
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('documentProcessingControllerGetProfileSchema', 'instanceId', instanceId)
            const localVarPath = `/projects/{projectId}/document-processing/{instanceId}/profiles/schema`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get batch query details by ID
         * @param {string} projectId 
         * @param {string} instanceId 
         * @param {string} queryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentProcessingControllerGetQuery: async (projectId: string, instanceId: string, queryId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('documentProcessingControllerGetQuery', 'projectId', projectId)
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('documentProcessingControllerGetQuery', 'instanceId', instanceId)
            // verify required parameter 'queryId' is not null or undefined
            assertParamExists('documentProcessingControllerGetQuery', 'queryId', queryId)
            const localVarPath = `/projects/{projectId}/document-processing/{instanceId}/queries/{queryId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)))
                .replace(`{${"queryId"}}`, encodeURIComponent(String(queryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get webhook details by ID
         * @param {string} projectId 
         * @param {string} instanceId 
         * @param {string} webhookId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentProcessingControllerGetWebhook: async (projectId: string, instanceId: string, webhookId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('documentProcessingControllerGetWebhook', 'projectId', projectId)
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('documentProcessingControllerGetWebhook', 'instanceId', instanceId)
            // verify required parameter 'webhookId' is not null or undefined
            assertParamExists('documentProcessingControllerGetWebhook', 'webhookId', webhookId)
            const localVarPath = `/projects/{projectId}/document-processing/{instanceId}/webhooks/{webhookId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)))
                .replace(`{${"webhookId"}}`, encodeURIComponent(String(webhookId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List processed documents with pagination and filters
         * @param {string} projectId 
         * @param {string} instanceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentProcessingControllerListDocuments: async (projectId: string, instanceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('documentProcessingControllerListDocuments', 'projectId', projectId)
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('documentProcessingControllerListDocuments', 'instanceId', instanceId)
            const localVarPath = `/projects/{projectId}/document-processing/{instanceId}/documents`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List evaluations for a document with pagination
         * @param {string} projectId 
         * @param {string} instanceId 
         * @param {string} documentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentProcessingControllerListEvals: async (projectId: string, instanceId: string, documentId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('documentProcessingControllerListEvals', 'projectId', projectId)
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('documentProcessingControllerListEvals', 'instanceId', instanceId)
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('documentProcessingControllerListEvals', 'documentId', documentId)
            const localVarPath = `/projects/{projectId}/document-processing/{instanceId}/documents/{documentId}/evals`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)))
                .replace(`{${"documentId"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List processing jobs with pagination
         * @param {string} projectId 
         * @param {string} instanceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentProcessingControllerListJobs: async (projectId: string, instanceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('documentProcessingControllerListJobs', 'projectId', projectId)
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('documentProcessingControllerListJobs', 'instanceId', instanceId)
            const localVarPath = `/projects/{projectId}/document-processing/{instanceId}/jobs`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List processing profiles with pagination
         * @param {string} projectId 
         * @param {string} instanceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentProcessingControllerListProfiles: async (projectId: string, instanceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('documentProcessingControllerListProfiles', 'projectId', projectId)
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('documentProcessingControllerListProfiles', 'instanceId', instanceId)
            const localVarPath = `/projects/{projectId}/document-processing/{instanceId}/profiles`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List batch queries with pagination and filters
         * @param {string} projectId 
         * @param {string} instanceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentProcessingControllerListQueries: async (projectId: string, instanceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('documentProcessingControllerListQueries', 'projectId', projectId)
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('documentProcessingControllerListQueries', 'instanceId', instanceId)
            const localVarPath = `/projects/{projectId}/document-processing/{instanceId}/queries`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List webhooks with pagination
         * @param {string} projectId 
         * @param {string} instanceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentProcessingControllerListWebhooks: async (projectId: string, instanceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('documentProcessingControllerListWebhooks', 'projectId', projectId)
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('documentProcessingControllerListWebhooks', 'instanceId', instanceId)
            const localVarPath = `/projects/{projectId}/document-processing/{instanceId}/webhooks`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update webhook configuration
         * @param {string} projectId 
         * @param {string} instanceId 
         * @param {string} webhookId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentProcessingControllerUpdateWebhook: async (projectId: string, instanceId: string, webhookId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('documentProcessingControllerUpdateWebhook', 'projectId', projectId)
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('documentProcessingControllerUpdateWebhook', 'instanceId', instanceId)
            // verify required parameter 'webhookId' is not null or undefined
            assertParamExists('documentProcessingControllerUpdateWebhook', 'webhookId', webhookId)
            const localVarPath = `/projects/{projectId}/document-processing/{instanceId}/webhooks/{webhookId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)))
                .replace(`{${"webhookId"}}`, encodeURIComponent(String(webhookId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Validate eval YAML without creating evaluation (multipart)
         * @param {string} projectId 
         * @param {string} instanceId 
         * @param {string} documentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentProcessingControllerValidateEvalYaml: async (projectId: string, instanceId: string, documentId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('documentProcessingControllerValidateEvalYaml', 'projectId', projectId)
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('documentProcessingControllerValidateEvalYaml', 'instanceId', instanceId)
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('documentProcessingControllerValidateEvalYaml', 'documentId', documentId)
            const localVarPath = `/projects/{projectId}/document-processing/{instanceId}/documents/{documentId}/evals/validate`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)))
                .replace(`{${"documentId"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Validate batch query YAML without creating query (multipart)
         * @param {string} projectId 
         * @param {string} instanceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentProcessingControllerValidateQueryYaml: async (projectId: string, instanceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('documentProcessingControllerValidateQueryYaml', 'projectId', projectId)
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('documentProcessingControllerValidateQueryYaml', 'instanceId', instanceId)
            const localVarPath = `/projects/{projectId}/document-processing/{instanceId}/queries/validate`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DocumentProcessingApi - functional programming interface
 */
export const DocumentProcessingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DocumentProcessingApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create batch query from YAML file (multipart)
         * @param {string} projectId 
         * @param {string} instanceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentProcessingControllerCreateBatchQuery(projectId: string, instanceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentProcessingControllerCreateBatchQuery(projectId, instanceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentProcessingApi.documentProcessingControllerCreateBatchQuery']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create document processing job by uploading file (multipart)
         * @param {string} projectId 
         * @param {string} instanceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentProcessingControllerCreateDocumentProcessingJob(projectId: string, instanceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentProcessingControllerCreateDocumentProcessingJob(projectId, instanceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentProcessingApi.documentProcessingControllerCreateDocumentProcessingJob']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create evaluation from YAML file (multipart)
         * @param {string} projectId 
         * @param {string} instanceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentProcessingControllerCreateEval(projectId: string, instanceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentProcessingControllerCreateEval(projectId, instanceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentProcessingApi.documentProcessingControllerCreateEval']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create processing profile from YAML file (multipart)
         * @param {string} projectId 
         * @param {string} instanceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentProcessingControllerCreateProfile(projectId: string, instanceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentProcessingControllerCreateProfile(projectId, instanceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentProcessingApi.documentProcessingControllerCreateProfile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create webhook for receiving notifications
         * @param {string} projectId 
         * @param {string} instanceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentProcessingControllerCreateWebhook(projectId: string, instanceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentProcessingControllerCreateWebhook(projectId, instanceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentProcessingApi.documentProcessingControllerCreateWebhook']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete webhook
         * @param {string} projectId 
         * @param {string} instanceId 
         * @param {string} webhookId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentProcessingControllerDeleteWebhook(projectId: string, instanceId: string, webhookId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentProcessingControllerDeleteWebhook(projectId, instanceId, webhookId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentProcessingApi.documentProcessingControllerDeleteWebhook']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Download document artifacts as archive
         * @param {string} projectId 
         * @param {string} instanceId 
         * @param {string} documentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentProcessingControllerDownloadDocumentArtifacts(projectId: string, instanceId: string, documentId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentProcessingControllerDownloadDocumentArtifacts(projectId, instanceId, documentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentProcessingApi.documentProcessingControllerDownloadDocumentArtifacts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get processed document by ID
         * @param {string} projectId 
         * @param {string} instanceId 
         * @param {string} documentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentProcessingControllerGetDocument(projectId: string, instanceId: string, documentId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentProcessingControllerGetDocument(projectId, instanceId, documentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentProcessingApi.documentProcessingControllerGetDocument']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get evaluation details by document ID and eval ID
         * @param {string} projectId 
         * @param {string} instanceId 
         * @param {string} documentId 
         * @param {string} evalId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentProcessingControllerGetEval(projectId: string, instanceId: string, documentId: string, evalId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentProcessingControllerGetEval(projectId, instanceId, documentId, evalId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentProcessingApi.documentProcessingControllerGetEval']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get document processing API client health
         * @param {string} projectId 
         * @param {string} instanceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentProcessingControllerGetHealth(projectId: string, instanceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentProcessingControllerGetHealth(projectId, instanceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentProcessingApi.documentProcessingControllerGetHealth']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get processing job details by ID
         * @param {string} projectId 
         * @param {string} instanceId 
         * @param {string} jobId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentProcessingControllerGetJob(projectId: string, instanceId: string, jobId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentProcessingControllerGetJob(projectId, instanceId, jobId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentProcessingApi.documentProcessingControllerGetJob']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get processing job status (lightweight)
         * @param {string} projectId 
         * @param {string} instanceId 
         * @param {string} jobId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentProcessingControllerGetJobStatus(projectId: string, instanceId: string, jobId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentProcessingControllerGetJobStatus(projectId, instanceId, jobId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentProcessingApi.documentProcessingControllerGetJobStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get processing profile by ID
         * @param {string} projectId 
         * @param {string} instanceId 
         * @param {string} profileId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentProcessingControllerGetProfile(projectId: string, instanceId: string, profileId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentProcessingControllerGetProfile(projectId, instanceId, profileId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentProcessingApi.documentProcessingControllerGetProfile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get profile schema for YAML configuration
         * @param {string} projectId 
         * @param {string} instanceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentProcessingControllerGetProfileSchema(projectId: string, instanceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentProcessingControllerGetProfileSchema(projectId, instanceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentProcessingApi.documentProcessingControllerGetProfileSchema']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get batch query details by ID
         * @param {string} projectId 
         * @param {string} instanceId 
         * @param {string} queryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentProcessingControllerGetQuery(projectId: string, instanceId: string, queryId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentProcessingControllerGetQuery(projectId, instanceId, queryId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentProcessingApi.documentProcessingControllerGetQuery']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get webhook details by ID
         * @param {string} projectId 
         * @param {string} instanceId 
         * @param {string} webhookId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentProcessingControllerGetWebhook(projectId: string, instanceId: string, webhookId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentProcessingControllerGetWebhook(projectId, instanceId, webhookId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentProcessingApi.documentProcessingControllerGetWebhook']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List processed documents with pagination and filters
         * @param {string} projectId 
         * @param {string} instanceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentProcessingControllerListDocuments(projectId: string, instanceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentProcessingControllerListDocuments(projectId, instanceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentProcessingApi.documentProcessingControllerListDocuments']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List evaluations for a document with pagination
         * @param {string} projectId 
         * @param {string} instanceId 
         * @param {string} documentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentProcessingControllerListEvals(projectId: string, instanceId: string, documentId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentProcessingControllerListEvals(projectId, instanceId, documentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentProcessingApi.documentProcessingControllerListEvals']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List processing jobs with pagination
         * @param {string} projectId 
         * @param {string} instanceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentProcessingControllerListJobs(projectId: string, instanceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentProcessingControllerListJobs(projectId, instanceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentProcessingApi.documentProcessingControllerListJobs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List processing profiles with pagination
         * @param {string} projectId 
         * @param {string} instanceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentProcessingControllerListProfiles(projectId: string, instanceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentProcessingControllerListProfiles(projectId, instanceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentProcessingApi.documentProcessingControllerListProfiles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List batch queries with pagination and filters
         * @param {string} projectId 
         * @param {string} instanceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentProcessingControllerListQueries(projectId: string, instanceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentProcessingControllerListQueries(projectId, instanceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentProcessingApi.documentProcessingControllerListQueries']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List webhooks with pagination
         * @param {string} projectId 
         * @param {string} instanceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentProcessingControllerListWebhooks(projectId: string, instanceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentProcessingControllerListWebhooks(projectId, instanceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentProcessingApi.documentProcessingControllerListWebhooks']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update webhook configuration
         * @param {string} projectId 
         * @param {string} instanceId 
         * @param {string} webhookId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentProcessingControllerUpdateWebhook(projectId: string, instanceId: string, webhookId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentProcessingControllerUpdateWebhook(projectId, instanceId, webhookId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentProcessingApi.documentProcessingControllerUpdateWebhook']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Validate eval YAML without creating evaluation (multipart)
         * @param {string} projectId 
         * @param {string} instanceId 
         * @param {string} documentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentProcessingControllerValidateEvalYaml(projectId: string, instanceId: string, documentId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentProcessingControllerValidateEvalYaml(projectId, instanceId, documentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentProcessingApi.documentProcessingControllerValidateEvalYaml']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Validate batch query YAML without creating query (multipart)
         * @param {string} projectId 
         * @param {string} instanceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentProcessingControllerValidateQueryYaml(projectId: string, instanceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentProcessingControllerValidateQueryYaml(projectId, instanceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentProcessingApi.documentProcessingControllerValidateQueryYaml']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DocumentProcessingApi - factory interface
 */
export const DocumentProcessingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DocumentProcessingApiFp(configuration)
    return {
        /**
         * 
         * @summary Create batch query from YAML file (multipart)
         * @param {string} projectId 
         * @param {string} instanceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentProcessingControllerCreateBatchQuery(projectId: string, instanceId: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.documentProcessingControllerCreateBatchQuery(projectId, instanceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create document processing job by uploading file (multipart)
         * @param {string} projectId 
         * @param {string} instanceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentProcessingControllerCreateDocumentProcessingJob(projectId: string, instanceId: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.documentProcessingControllerCreateDocumentProcessingJob(projectId, instanceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create evaluation from YAML file (multipart)
         * @param {string} projectId 
         * @param {string} instanceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentProcessingControllerCreateEval(projectId: string, instanceId: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.documentProcessingControllerCreateEval(projectId, instanceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create processing profile from YAML file (multipart)
         * @param {string} projectId 
         * @param {string} instanceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentProcessingControllerCreateProfile(projectId: string, instanceId: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.documentProcessingControllerCreateProfile(projectId, instanceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create webhook for receiving notifications
         * @param {string} projectId 
         * @param {string} instanceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentProcessingControllerCreateWebhook(projectId: string, instanceId: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.documentProcessingControllerCreateWebhook(projectId, instanceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete webhook
         * @param {string} projectId 
         * @param {string} instanceId 
         * @param {string} webhookId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentProcessingControllerDeleteWebhook(projectId: string, instanceId: string, webhookId: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.documentProcessingControllerDeleteWebhook(projectId, instanceId, webhookId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Download document artifacts as archive
         * @param {string} projectId 
         * @param {string} instanceId 
         * @param {string} documentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentProcessingControllerDownloadDocumentArtifacts(projectId: string, instanceId: string, documentId: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.documentProcessingControllerDownloadDocumentArtifacts(projectId, instanceId, documentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get processed document by ID
         * @param {string} projectId 
         * @param {string} instanceId 
         * @param {string} documentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentProcessingControllerGetDocument(projectId: string, instanceId: string, documentId: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.documentProcessingControllerGetDocument(projectId, instanceId, documentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get evaluation details by document ID and eval ID
         * @param {string} projectId 
         * @param {string} instanceId 
         * @param {string} documentId 
         * @param {string} evalId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentProcessingControllerGetEval(projectId: string, instanceId: string, documentId: string, evalId: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.documentProcessingControllerGetEval(projectId, instanceId, documentId, evalId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get document processing API client health
         * @param {string} projectId 
         * @param {string} instanceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentProcessingControllerGetHealth(projectId: string, instanceId: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.documentProcessingControllerGetHealth(projectId, instanceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get processing job details by ID
         * @param {string} projectId 
         * @param {string} instanceId 
         * @param {string} jobId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentProcessingControllerGetJob(projectId: string, instanceId: string, jobId: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.documentProcessingControllerGetJob(projectId, instanceId, jobId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get processing job status (lightweight)
         * @param {string} projectId 
         * @param {string} instanceId 
         * @param {string} jobId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentProcessingControllerGetJobStatus(projectId: string, instanceId: string, jobId: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.documentProcessingControllerGetJobStatus(projectId, instanceId, jobId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get processing profile by ID
         * @param {string} projectId 
         * @param {string} instanceId 
         * @param {string} profileId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentProcessingControllerGetProfile(projectId: string, instanceId: string, profileId: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.documentProcessingControllerGetProfile(projectId, instanceId, profileId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get profile schema for YAML configuration
         * @param {string} projectId 
         * @param {string} instanceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentProcessingControllerGetProfileSchema(projectId: string, instanceId: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.documentProcessingControllerGetProfileSchema(projectId, instanceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get batch query details by ID
         * @param {string} projectId 
         * @param {string} instanceId 
         * @param {string} queryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentProcessingControllerGetQuery(projectId: string, instanceId: string, queryId: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.documentProcessingControllerGetQuery(projectId, instanceId, queryId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get webhook details by ID
         * @param {string} projectId 
         * @param {string} instanceId 
         * @param {string} webhookId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentProcessingControllerGetWebhook(projectId: string, instanceId: string, webhookId: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.documentProcessingControllerGetWebhook(projectId, instanceId, webhookId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List processed documents with pagination and filters
         * @param {string} projectId 
         * @param {string} instanceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentProcessingControllerListDocuments(projectId: string, instanceId: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.documentProcessingControllerListDocuments(projectId, instanceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List evaluations for a document with pagination
         * @param {string} projectId 
         * @param {string} instanceId 
         * @param {string} documentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentProcessingControllerListEvals(projectId: string, instanceId: string, documentId: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.documentProcessingControllerListEvals(projectId, instanceId, documentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List processing jobs with pagination
         * @param {string} projectId 
         * @param {string} instanceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentProcessingControllerListJobs(projectId: string, instanceId: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.documentProcessingControllerListJobs(projectId, instanceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List processing profiles with pagination
         * @param {string} projectId 
         * @param {string} instanceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentProcessingControllerListProfiles(projectId: string, instanceId: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.documentProcessingControllerListProfiles(projectId, instanceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List batch queries with pagination and filters
         * @param {string} projectId 
         * @param {string} instanceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentProcessingControllerListQueries(projectId: string, instanceId: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.documentProcessingControllerListQueries(projectId, instanceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List webhooks with pagination
         * @param {string} projectId 
         * @param {string} instanceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentProcessingControllerListWebhooks(projectId: string, instanceId: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.documentProcessingControllerListWebhooks(projectId, instanceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update webhook configuration
         * @param {string} projectId 
         * @param {string} instanceId 
         * @param {string} webhookId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentProcessingControllerUpdateWebhook(projectId: string, instanceId: string, webhookId: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.documentProcessingControllerUpdateWebhook(projectId, instanceId, webhookId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Validate eval YAML without creating evaluation (multipart)
         * @param {string} projectId 
         * @param {string} instanceId 
         * @param {string} documentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentProcessingControllerValidateEvalYaml(projectId: string, instanceId: string, documentId: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.documentProcessingControllerValidateEvalYaml(projectId, instanceId, documentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Validate batch query YAML without creating query (multipart)
         * @param {string} projectId 
         * @param {string} instanceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentProcessingControllerValidateQueryYaml(projectId: string, instanceId: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.documentProcessingControllerValidateQueryYaml(projectId, instanceId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DocumentProcessingApi - object-oriented interface
 */
export class DocumentProcessingApi extends BaseAPI {
    /**
     * 
     * @summary Create batch query from YAML file (multipart)
     * @param {string} projectId 
     * @param {string} instanceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public documentProcessingControllerCreateBatchQuery(projectId: string, instanceId: string, options?: RawAxiosRequestConfig) {
        return DocumentProcessingApiFp(this.configuration).documentProcessingControllerCreateBatchQuery(projectId, instanceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create document processing job by uploading file (multipart)
     * @param {string} projectId 
     * @param {string} instanceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public documentProcessingControllerCreateDocumentProcessingJob(projectId: string, instanceId: string, options?: RawAxiosRequestConfig) {
        return DocumentProcessingApiFp(this.configuration).documentProcessingControllerCreateDocumentProcessingJob(projectId, instanceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create evaluation from YAML file (multipart)
     * @param {string} projectId 
     * @param {string} instanceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public documentProcessingControllerCreateEval(projectId: string, instanceId: string, options?: RawAxiosRequestConfig) {
        return DocumentProcessingApiFp(this.configuration).documentProcessingControllerCreateEval(projectId, instanceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create processing profile from YAML file (multipart)
     * @param {string} projectId 
     * @param {string} instanceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public documentProcessingControllerCreateProfile(projectId: string, instanceId: string, options?: RawAxiosRequestConfig) {
        return DocumentProcessingApiFp(this.configuration).documentProcessingControllerCreateProfile(projectId, instanceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create webhook for receiving notifications
     * @param {string} projectId 
     * @param {string} instanceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public documentProcessingControllerCreateWebhook(projectId: string, instanceId: string, options?: RawAxiosRequestConfig) {
        return DocumentProcessingApiFp(this.configuration).documentProcessingControllerCreateWebhook(projectId, instanceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete webhook
     * @param {string} projectId 
     * @param {string} instanceId 
     * @param {string} webhookId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public documentProcessingControllerDeleteWebhook(projectId: string, instanceId: string, webhookId: string, options?: RawAxiosRequestConfig) {
        return DocumentProcessingApiFp(this.configuration).documentProcessingControllerDeleteWebhook(projectId, instanceId, webhookId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Download document artifacts as archive
     * @param {string} projectId 
     * @param {string} instanceId 
     * @param {string} documentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public documentProcessingControllerDownloadDocumentArtifacts(projectId: string, instanceId: string, documentId: string, options?: RawAxiosRequestConfig) {
        return DocumentProcessingApiFp(this.configuration).documentProcessingControllerDownloadDocumentArtifacts(projectId, instanceId, documentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get processed document by ID
     * @param {string} projectId 
     * @param {string} instanceId 
     * @param {string} documentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public documentProcessingControllerGetDocument(projectId: string, instanceId: string, documentId: string, options?: RawAxiosRequestConfig) {
        return DocumentProcessingApiFp(this.configuration).documentProcessingControllerGetDocument(projectId, instanceId, documentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get evaluation details by document ID and eval ID
     * @param {string} projectId 
     * @param {string} instanceId 
     * @param {string} documentId 
     * @param {string} evalId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public documentProcessingControllerGetEval(projectId: string, instanceId: string, documentId: string, evalId: string, options?: RawAxiosRequestConfig) {
        return DocumentProcessingApiFp(this.configuration).documentProcessingControllerGetEval(projectId, instanceId, documentId, evalId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get document processing API client health
     * @param {string} projectId 
     * @param {string} instanceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public documentProcessingControllerGetHealth(projectId: string, instanceId: string, options?: RawAxiosRequestConfig) {
        return DocumentProcessingApiFp(this.configuration).documentProcessingControllerGetHealth(projectId, instanceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get processing job details by ID
     * @param {string} projectId 
     * @param {string} instanceId 
     * @param {string} jobId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public documentProcessingControllerGetJob(projectId: string, instanceId: string, jobId: string, options?: RawAxiosRequestConfig) {
        return DocumentProcessingApiFp(this.configuration).documentProcessingControllerGetJob(projectId, instanceId, jobId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get processing job status (lightweight)
     * @param {string} projectId 
     * @param {string} instanceId 
     * @param {string} jobId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public documentProcessingControllerGetJobStatus(projectId: string, instanceId: string, jobId: string, options?: RawAxiosRequestConfig) {
        return DocumentProcessingApiFp(this.configuration).documentProcessingControllerGetJobStatus(projectId, instanceId, jobId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get processing profile by ID
     * @param {string} projectId 
     * @param {string} instanceId 
     * @param {string} profileId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public documentProcessingControllerGetProfile(projectId: string, instanceId: string, profileId: string, options?: RawAxiosRequestConfig) {
        return DocumentProcessingApiFp(this.configuration).documentProcessingControllerGetProfile(projectId, instanceId, profileId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get profile schema for YAML configuration
     * @param {string} projectId 
     * @param {string} instanceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public documentProcessingControllerGetProfileSchema(projectId: string, instanceId: string, options?: RawAxiosRequestConfig) {
        return DocumentProcessingApiFp(this.configuration).documentProcessingControllerGetProfileSchema(projectId, instanceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get batch query details by ID
     * @param {string} projectId 
     * @param {string} instanceId 
     * @param {string} queryId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public documentProcessingControllerGetQuery(projectId: string, instanceId: string, queryId: string, options?: RawAxiosRequestConfig) {
        return DocumentProcessingApiFp(this.configuration).documentProcessingControllerGetQuery(projectId, instanceId, queryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get webhook details by ID
     * @param {string} projectId 
     * @param {string} instanceId 
     * @param {string} webhookId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public documentProcessingControllerGetWebhook(projectId: string, instanceId: string, webhookId: string, options?: RawAxiosRequestConfig) {
        return DocumentProcessingApiFp(this.configuration).documentProcessingControllerGetWebhook(projectId, instanceId, webhookId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List processed documents with pagination and filters
     * @param {string} projectId 
     * @param {string} instanceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public documentProcessingControllerListDocuments(projectId: string, instanceId: string, options?: RawAxiosRequestConfig) {
        return DocumentProcessingApiFp(this.configuration).documentProcessingControllerListDocuments(projectId, instanceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List evaluations for a document with pagination
     * @param {string} projectId 
     * @param {string} instanceId 
     * @param {string} documentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public documentProcessingControllerListEvals(projectId: string, instanceId: string, documentId: string, options?: RawAxiosRequestConfig) {
        return DocumentProcessingApiFp(this.configuration).documentProcessingControllerListEvals(projectId, instanceId, documentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List processing jobs with pagination
     * @param {string} projectId 
     * @param {string} instanceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public documentProcessingControllerListJobs(projectId: string, instanceId: string, options?: RawAxiosRequestConfig) {
        return DocumentProcessingApiFp(this.configuration).documentProcessingControllerListJobs(projectId, instanceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List processing profiles with pagination
     * @param {string} projectId 
     * @param {string} instanceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public documentProcessingControllerListProfiles(projectId: string, instanceId: string, options?: RawAxiosRequestConfig) {
        return DocumentProcessingApiFp(this.configuration).documentProcessingControllerListProfiles(projectId, instanceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List batch queries with pagination and filters
     * @param {string} projectId 
     * @param {string} instanceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public documentProcessingControllerListQueries(projectId: string, instanceId: string, options?: RawAxiosRequestConfig) {
        return DocumentProcessingApiFp(this.configuration).documentProcessingControllerListQueries(projectId, instanceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List webhooks with pagination
     * @param {string} projectId 
     * @param {string} instanceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public documentProcessingControllerListWebhooks(projectId: string, instanceId: string, options?: RawAxiosRequestConfig) {
        return DocumentProcessingApiFp(this.configuration).documentProcessingControllerListWebhooks(projectId, instanceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update webhook configuration
     * @param {string} projectId 
     * @param {string} instanceId 
     * @param {string} webhookId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public documentProcessingControllerUpdateWebhook(projectId: string, instanceId: string, webhookId: string, options?: RawAxiosRequestConfig) {
        return DocumentProcessingApiFp(this.configuration).documentProcessingControllerUpdateWebhook(projectId, instanceId, webhookId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Validate eval YAML without creating evaluation (multipart)
     * @param {string} projectId 
     * @param {string} instanceId 
     * @param {string} documentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public documentProcessingControllerValidateEvalYaml(projectId: string, instanceId: string, documentId: string, options?: RawAxiosRequestConfig) {
        return DocumentProcessingApiFp(this.configuration).documentProcessingControllerValidateEvalYaml(projectId, instanceId, documentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Validate batch query YAML without creating query (multipart)
     * @param {string} projectId 
     * @param {string} instanceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public documentProcessingControllerValidateQueryYaml(projectId: string, instanceId: string, options?: RawAxiosRequestConfig) {
        return DocumentProcessingApiFp(this.configuration).documentProcessingControllerValidateQueryYaml(projectId, instanceId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DocumentsApi - axios parameter creator
 */
export const DocumentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add a new doc
         * @param {string} projectId 
         * @param {string} instanceId 
         * @param {string} collectionId 
         * @param {CreateDocumentRequestDTO} createDocumentRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentControllerAddDocToCollection: async (projectId: string, instanceId: string, collectionId: string, createDocumentRequestDTO: CreateDocumentRequestDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('documentControllerAddDocToCollection', 'projectId', projectId)
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('documentControllerAddDocToCollection', 'instanceId', instanceId)
            // verify required parameter 'collectionId' is not null or undefined
            assertParamExists('documentControllerAddDocToCollection', 'collectionId', collectionId)
            // verify required parameter 'createDocumentRequestDTO' is not null or undefined
            assertParamExists('documentControllerAddDocToCollection', 'createDocumentRequestDTO', createDocumentRequestDTO)
            const localVarPath = `/projects/{projectId}/document/{instanceId}/collections/{collectionId}/docs`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)))
                .replace(`{${"collectionId"}}`, encodeURIComponent(String(collectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createDocumentRequestDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Use a file to chunk and add to collection
         * @param {string} projectId 
         * @param {string} instanceId 
         * @param {string} collectionId 
         * @param {ChunkFileRequestDTO} chunkFileRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentControllerAddDocToCollectionFromFile: async (projectId: string, instanceId: string, collectionId: string, chunkFileRequestDTO: ChunkFileRequestDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('documentControllerAddDocToCollectionFromFile', 'projectId', projectId)
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('documentControllerAddDocToCollectionFromFile', 'instanceId', instanceId)
            // verify required parameter 'collectionId' is not null or undefined
            assertParamExists('documentControllerAddDocToCollectionFromFile', 'collectionId', collectionId)
            // verify required parameter 'chunkFileRequestDTO' is not null or undefined
            assertParamExists('documentControllerAddDocToCollectionFromFile', 'chunkFileRequestDTO', chunkFileRequestDTO)
            const localVarPath = `/projects/{projectId}/document/{instanceId}/collections/{collectionId}/docs/file`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)))
                .replace(`{${"collectionId"}}`, encodeURIComponent(String(collectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(chunkFileRequestDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create collection
         * @param {string} projectId 
         * @param {string} instanceId 
         * @param {CreateCollectionRequestDTO} createCollectionRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentControllerCreateCollection: async (projectId: string, instanceId: string, createCollectionRequestDTO: CreateCollectionRequestDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('documentControllerCreateCollection', 'projectId', projectId)
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('documentControllerCreateCollection', 'instanceId', instanceId)
            // verify required parameter 'createCollectionRequestDTO' is not null or undefined
            assertParamExists('documentControllerCreateCollection', 'createCollectionRequestDTO', createCollectionRequestDTO)
            const localVarPath = `/projects/{projectId}/document/{instanceId}/collections`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createCollectionRequestDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete collection
         * @param {string} projectId 
         * @param {string} instanceId 
         * @param {string} collectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentControllerDeleteCollection: async (projectId: string, instanceId: string, collectionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('documentControllerDeleteCollection', 'projectId', projectId)
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('documentControllerDeleteCollection', 'instanceId', instanceId)
            // verify required parameter 'collectionId' is not null or undefined
            assertParamExists('documentControllerDeleteCollection', 'collectionId', collectionId)
            const localVarPath = `/projects/{projectId}/document/{instanceId}/collections/{collectionId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)))
                .replace(`{${"collectionId"}}`, encodeURIComponent(String(collectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete doc by ID
         * @param {string} projectId 
         * @param {string} instanceId 
         * @param {string} collectionId 
         * @param {string} docId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentControllerDeleteDocById: async (projectId: string, instanceId: string, collectionId: string, docId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('documentControllerDeleteDocById', 'projectId', projectId)
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('documentControllerDeleteDocById', 'instanceId', instanceId)
            // verify required parameter 'collectionId' is not null or undefined
            assertParamExists('documentControllerDeleteDocById', 'collectionId', collectionId)
            // verify required parameter 'docId' is not null or undefined
            assertParamExists('documentControllerDeleteDocById', 'docId', docId)
            const localVarPath = `/projects/{projectId}/document/{instanceId}/collections/{collectionId}/docs/{docId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)))
                .replace(`{${"collectionId"}}`, encodeURIComponent(String(collectionId)))
                .replace(`{${"docId"}}`, encodeURIComponent(String(docId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete docs based on metadata filters
         * @param {string} projectId 
         * @param {string} instanceId 
         * @param {string} collectionId 
         * @param {string} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentControllerDeleteDocsFromCollection: async (projectId: string, instanceId: string, collectionId: string, filter: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('documentControllerDeleteDocsFromCollection', 'projectId', projectId)
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('documentControllerDeleteDocsFromCollection', 'instanceId', instanceId)
            // verify required parameter 'collectionId' is not null or undefined
            assertParamExists('documentControllerDeleteDocsFromCollection', 'collectionId', collectionId)
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('documentControllerDeleteDocsFromCollection', 'filter', filter)
            const localVarPath = `/projects/{projectId}/document/{instanceId}/collections/{collectionId}/docs`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)))
                .replace(`{${"collectionId"}}`, encodeURIComponent(String(collectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all collections
         * @param {string} projectId 
         * @param {string} instanceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentControllerGetAllCollections: async (projectId: string, instanceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('documentControllerGetAllCollections', 'projectId', projectId)
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('documentControllerGetAllCollections', 'instanceId', instanceId)
            const localVarPath = `/projects/{projectId}/document/{instanceId}/collections`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get collection info
         * @param {string} projectId 
         * @param {string} instanceId 
         * @param {string} collectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentControllerGetCollectionInfo: async (projectId: string, instanceId: string, collectionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('documentControllerGetCollectionInfo', 'projectId', projectId)
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('documentControllerGetCollectionInfo', 'instanceId', instanceId)
            // verify required parameter 'collectionId' is not null or undefined
            assertParamExists('documentControllerGetCollectionInfo', 'collectionId', collectionId)
            const localVarPath = `/projects/{projectId}/document/{instanceId}/collections/{collectionId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)))
                .replace(`{${"collectionId"}}`, encodeURIComponent(String(collectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get doc by ID
         * @param {string} projectId 
         * @param {string} instanceId 
         * @param {string} collectionId 
         * @param {string} docId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentControllerGetDocById: async (projectId: string, instanceId: string, collectionId: string, docId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('documentControllerGetDocById', 'projectId', projectId)
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('documentControllerGetDocById', 'instanceId', instanceId)
            // verify required parameter 'collectionId' is not null or undefined
            assertParamExists('documentControllerGetDocById', 'collectionId', collectionId)
            // verify required parameter 'docId' is not null or undefined
            assertParamExists('documentControllerGetDocById', 'docId', docId)
            const localVarPath = `/projects/{projectId}/document/{instanceId}/collections/{collectionId}/docs/{docId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)))
                .replace(`{${"collectionId"}}`, encodeURIComponent(String(collectionId)))
                .replace(`{${"docId"}}`, encodeURIComponent(String(docId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Similarity search query
         * @param {string} projectId 
         * @param {string} instanceId 
         * @param {string} collectionId 
         * @param {SimilaritySearchQueryDTO} similaritySearchQueryDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentControllerSimilaritySearch: async (projectId: string, instanceId: string, collectionId: string, similaritySearchQueryDTO: SimilaritySearchQueryDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('documentControllerSimilaritySearch', 'projectId', projectId)
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('documentControllerSimilaritySearch', 'instanceId', instanceId)
            // verify required parameter 'collectionId' is not null or undefined
            assertParamExists('documentControllerSimilaritySearch', 'collectionId', collectionId)
            // verify required parameter 'similaritySearchQueryDTO' is not null or undefined
            assertParamExists('documentControllerSimilaritySearch', 'similaritySearchQueryDTO', similaritySearchQueryDTO)
            const localVarPath = `/projects/{projectId}/document/{instanceId}/collections/{collectionId}/query`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)))
                .replace(`{${"collectionId"}}`, encodeURIComponent(String(collectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(similaritySearchQueryDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update collection
         * @param {string} projectId 
         * @param {string} instanceId 
         * @param {string} collectionId 
         * @param {CreateCollectionRequestDTO} createCollectionRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentControllerUpdateCollection: async (projectId: string, instanceId: string, collectionId: string, createCollectionRequestDTO: CreateCollectionRequestDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('documentControllerUpdateCollection', 'projectId', projectId)
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('documentControllerUpdateCollection', 'instanceId', instanceId)
            // verify required parameter 'collectionId' is not null or undefined
            assertParamExists('documentControllerUpdateCollection', 'collectionId', collectionId)
            // verify required parameter 'createCollectionRequestDTO' is not null or undefined
            assertParamExists('documentControllerUpdateCollection', 'createCollectionRequestDTO', createCollectionRequestDTO)
            const localVarPath = `/projects/{projectId}/document/{instanceId}/collections/{collectionId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)))
                .replace(`{${"collectionId"}}`, encodeURIComponent(String(collectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createCollectionRequestDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update or upsert doc
         * @param {string} projectId 
         * @param {string} instanceId 
         * @param {string} collectionId 
         * @param {string} docId 
         * @param {UpdateDocumentRequestDTO} updateDocumentRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentControllerUpdateDoc: async (projectId: string, instanceId: string, collectionId: string, docId: string, updateDocumentRequestDTO: UpdateDocumentRequestDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('documentControllerUpdateDoc', 'projectId', projectId)
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('documentControllerUpdateDoc', 'instanceId', instanceId)
            // verify required parameter 'collectionId' is not null or undefined
            assertParamExists('documentControllerUpdateDoc', 'collectionId', collectionId)
            // verify required parameter 'docId' is not null or undefined
            assertParamExists('documentControllerUpdateDoc', 'docId', docId)
            // verify required parameter 'updateDocumentRequestDTO' is not null or undefined
            assertParamExists('documentControllerUpdateDoc', 'updateDocumentRequestDTO', updateDocumentRequestDTO)
            const localVarPath = `/projects/{projectId}/document/{instanceId}/collections/{collectionId}/docs/{docId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)))
                .replace(`{${"collectionId"}}`, encodeURIComponent(String(collectionId)))
                .replace(`{${"docId"}}`, encodeURIComponent(String(docId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateDocumentRequestDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DocumentsApi - functional programming interface
 */
export const DocumentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DocumentsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add a new doc
         * @param {string} projectId 
         * @param {string} instanceId 
         * @param {string} collectionId 
         * @param {CreateDocumentRequestDTO} createDocumentRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentControllerAddDocToCollection(projectId: string, instanceId: string, collectionId: string, createDocumentRequestDTO: CreateDocumentRequestDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentControllerAddDocToCollection(projectId, instanceId, collectionId, createDocumentRequestDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.documentControllerAddDocToCollection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Use a file to chunk and add to collection
         * @param {string} projectId 
         * @param {string} instanceId 
         * @param {string} collectionId 
         * @param {ChunkFileRequestDTO} chunkFileRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentControllerAddDocToCollectionFromFile(projectId: string, instanceId: string, collectionId: string, chunkFileRequestDTO: ChunkFileRequestDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentControllerAddDocToCollectionFromFile(projectId, instanceId, collectionId, chunkFileRequestDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.documentControllerAddDocToCollectionFromFile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create collection
         * @param {string} projectId 
         * @param {string} instanceId 
         * @param {CreateCollectionRequestDTO} createCollectionRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentControllerCreateCollection(projectId: string, instanceId: string, createCollectionRequestDTO: CreateCollectionRequestDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentControllerCreateCollection(projectId, instanceId, createCollectionRequestDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.documentControllerCreateCollection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete collection
         * @param {string} projectId 
         * @param {string} instanceId 
         * @param {string} collectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentControllerDeleteCollection(projectId: string, instanceId: string, collectionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentControllerDeleteCollection(projectId, instanceId, collectionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.documentControllerDeleteCollection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete doc by ID
         * @param {string} projectId 
         * @param {string} instanceId 
         * @param {string} collectionId 
         * @param {string} docId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentControllerDeleteDocById(projectId: string, instanceId: string, collectionId: string, docId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentControllerDeleteDocById(projectId, instanceId, collectionId, docId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.documentControllerDeleteDocById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete docs based on metadata filters
         * @param {string} projectId 
         * @param {string} instanceId 
         * @param {string} collectionId 
         * @param {string} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentControllerDeleteDocsFromCollection(projectId: string, instanceId: string, collectionId: string, filter: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentControllerDeleteDocsFromCollection(projectId, instanceId, collectionId, filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.documentControllerDeleteDocsFromCollection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all collections
         * @param {string} projectId 
         * @param {string} instanceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentControllerGetAllCollections(projectId: string, instanceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentControllerGetAllCollections(projectId, instanceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.documentControllerGetAllCollections']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get collection info
         * @param {string} projectId 
         * @param {string} instanceId 
         * @param {string} collectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentControllerGetCollectionInfo(projectId: string, instanceId: string, collectionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentControllerGetCollectionInfo(projectId, instanceId, collectionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.documentControllerGetCollectionInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get doc by ID
         * @param {string} projectId 
         * @param {string} instanceId 
         * @param {string} collectionId 
         * @param {string} docId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentControllerGetDocById(projectId: string, instanceId: string, collectionId: string, docId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentControllerGetDocById(projectId, instanceId, collectionId, docId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.documentControllerGetDocById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Similarity search query
         * @param {string} projectId 
         * @param {string} instanceId 
         * @param {string} collectionId 
         * @param {SimilaritySearchQueryDTO} similaritySearchQueryDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentControllerSimilaritySearch(projectId: string, instanceId: string, collectionId: string, similaritySearchQueryDTO: SimilaritySearchQueryDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentControllerSimilaritySearch(projectId, instanceId, collectionId, similaritySearchQueryDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.documentControllerSimilaritySearch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update collection
         * @param {string} projectId 
         * @param {string} instanceId 
         * @param {string} collectionId 
         * @param {CreateCollectionRequestDTO} createCollectionRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentControllerUpdateCollection(projectId: string, instanceId: string, collectionId: string, createCollectionRequestDTO: CreateCollectionRequestDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentControllerUpdateCollection(projectId, instanceId, collectionId, createCollectionRequestDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.documentControllerUpdateCollection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update or upsert doc
         * @param {string} projectId 
         * @param {string} instanceId 
         * @param {string} collectionId 
         * @param {string} docId 
         * @param {UpdateDocumentRequestDTO} updateDocumentRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentControllerUpdateDoc(projectId: string, instanceId: string, collectionId: string, docId: string, updateDocumentRequestDTO: UpdateDocumentRequestDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentControllerUpdateDoc(projectId, instanceId, collectionId, docId, updateDocumentRequestDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.documentControllerUpdateDoc']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DocumentsApi - factory interface
 */
export const DocumentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DocumentsApiFp(configuration)
    return {
        /**
         * 
         * @summary Add a new doc
         * @param {string} projectId 
         * @param {string} instanceId 
         * @param {string} collectionId 
         * @param {CreateDocumentRequestDTO} createDocumentRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentControllerAddDocToCollection(projectId: string, instanceId: string, collectionId: string, createDocumentRequestDTO: CreateDocumentRequestDTO, options?: RawAxiosRequestConfig): AxiosPromise<MessageResponseDTO> {
            return localVarFp.documentControllerAddDocToCollection(projectId, instanceId, collectionId, createDocumentRequestDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Use a file to chunk and add to collection
         * @param {string} projectId 
         * @param {string} instanceId 
         * @param {string} collectionId 
         * @param {ChunkFileRequestDTO} chunkFileRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentControllerAddDocToCollectionFromFile(projectId: string, instanceId: string, collectionId: string, chunkFileRequestDTO: ChunkFileRequestDTO, options?: RawAxiosRequestConfig): AxiosPromise<MessageResponseDTO> {
            return localVarFp.documentControllerAddDocToCollectionFromFile(projectId, instanceId, collectionId, chunkFileRequestDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create collection
         * @param {string} projectId 
         * @param {string} instanceId 
         * @param {CreateCollectionRequestDTO} createCollectionRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentControllerCreateCollection(projectId: string, instanceId: string, createCollectionRequestDTO: CreateCollectionRequestDTO, options?: RawAxiosRequestConfig): AxiosPromise<MessageResponseDTO> {
            return localVarFp.documentControllerCreateCollection(projectId, instanceId, createCollectionRequestDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete collection
         * @param {string} projectId 
         * @param {string} instanceId 
         * @param {string} collectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentControllerDeleteCollection(projectId: string, instanceId: string, collectionId: string, options?: RawAxiosRequestConfig): AxiosPromise<MessageResponseDTO> {
            return localVarFp.documentControllerDeleteCollection(projectId, instanceId, collectionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete doc by ID
         * @param {string} projectId 
         * @param {string} instanceId 
         * @param {string} collectionId 
         * @param {string} docId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentControllerDeleteDocById(projectId: string, instanceId: string, collectionId: string, docId: string, options?: RawAxiosRequestConfig): AxiosPromise<MessageResponseDTO> {
            return localVarFp.documentControllerDeleteDocById(projectId, instanceId, collectionId, docId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete docs based on metadata filters
         * @param {string} projectId 
         * @param {string} instanceId 
         * @param {string} collectionId 
         * @param {string} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentControllerDeleteDocsFromCollection(projectId: string, instanceId: string, collectionId: string, filter: string, options?: RawAxiosRequestConfig): AxiosPromise<MessageResponseDTO> {
            return localVarFp.documentControllerDeleteDocsFromCollection(projectId, instanceId, collectionId, filter, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all collections
         * @param {string} projectId 
         * @param {string} instanceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentControllerGetAllCollections(projectId: string, instanceId: string, options?: RawAxiosRequestConfig): AxiosPromise<MessageResponseDTO> {
            return localVarFp.documentControllerGetAllCollections(projectId, instanceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get collection info
         * @param {string} projectId 
         * @param {string} instanceId 
         * @param {string} collectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentControllerGetCollectionInfo(projectId: string, instanceId: string, collectionId: string, options?: RawAxiosRequestConfig): AxiosPromise<MessageResponseDTO> {
            return localVarFp.documentControllerGetCollectionInfo(projectId, instanceId, collectionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get doc by ID
         * @param {string} projectId 
         * @param {string} instanceId 
         * @param {string} collectionId 
         * @param {string} docId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentControllerGetDocById(projectId: string, instanceId: string, collectionId: string, docId: string, options?: RawAxiosRequestConfig): AxiosPromise<MessageResponseDTO> {
            return localVarFp.documentControllerGetDocById(projectId, instanceId, collectionId, docId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Similarity search query
         * @param {string} projectId 
         * @param {string} instanceId 
         * @param {string} collectionId 
         * @param {SimilaritySearchQueryDTO} similaritySearchQueryDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentControllerSimilaritySearch(projectId: string, instanceId: string, collectionId: string, similaritySearchQueryDTO: SimilaritySearchQueryDTO, options?: RawAxiosRequestConfig): AxiosPromise<MessageResponseDTO> {
            return localVarFp.documentControllerSimilaritySearch(projectId, instanceId, collectionId, similaritySearchQueryDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update collection
         * @param {string} projectId 
         * @param {string} instanceId 
         * @param {string} collectionId 
         * @param {CreateCollectionRequestDTO} createCollectionRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentControllerUpdateCollection(projectId: string, instanceId: string, collectionId: string, createCollectionRequestDTO: CreateCollectionRequestDTO, options?: RawAxiosRequestConfig): AxiosPromise<MessageResponseDTO> {
            return localVarFp.documentControllerUpdateCollection(projectId, instanceId, collectionId, createCollectionRequestDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update or upsert doc
         * @param {string} projectId 
         * @param {string} instanceId 
         * @param {string} collectionId 
         * @param {string} docId 
         * @param {UpdateDocumentRequestDTO} updateDocumentRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentControllerUpdateDoc(projectId: string, instanceId: string, collectionId: string, docId: string, updateDocumentRequestDTO: UpdateDocumentRequestDTO, options?: RawAxiosRequestConfig): AxiosPromise<MessageResponseDTO> {
            return localVarFp.documentControllerUpdateDoc(projectId, instanceId, collectionId, docId, updateDocumentRequestDTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DocumentsApi - object-oriented interface
 */
export class DocumentsApi extends BaseAPI {
    /**
     * 
     * @summary Add a new doc
     * @param {string} projectId 
     * @param {string} instanceId 
     * @param {string} collectionId 
     * @param {CreateDocumentRequestDTO} createDocumentRequestDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public documentControllerAddDocToCollection(projectId: string, instanceId: string, collectionId: string, createDocumentRequestDTO: CreateDocumentRequestDTO, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentControllerAddDocToCollection(projectId, instanceId, collectionId, createDocumentRequestDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Use a file to chunk and add to collection
     * @param {string} projectId 
     * @param {string} instanceId 
     * @param {string} collectionId 
     * @param {ChunkFileRequestDTO} chunkFileRequestDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public documentControllerAddDocToCollectionFromFile(projectId: string, instanceId: string, collectionId: string, chunkFileRequestDTO: ChunkFileRequestDTO, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentControllerAddDocToCollectionFromFile(projectId, instanceId, collectionId, chunkFileRequestDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create collection
     * @param {string} projectId 
     * @param {string} instanceId 
     * @param {CreateCollectionRequestDTO} createCollectionRequestDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public documentControllerCreateCollection(projectId: string, instanceId: string, createCollectionRequestDTO: CreateCollectionRequestDTO, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentControllerCreateCollection(projectId, instanceId, createCollectionRequestDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete collection
     * @param {string} projectId 
     * @param {string} instanceId 
     * @param {string} collectionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public documentControllerDeleteCollection(projectId: string, instanceId: string, collectionId: string, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentControllerDeleteCollection(projectId, instanceId, collectionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete doc by ID
     * @param {string} projectId 
     * @param {string} instanceId 
     * @param {string} collectionId 
     * @param {string} docId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public documentControllerDeleteDocById(projectId: string, instanceId: string, collectionId: string, docId: string, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentControllerDeleteDocById(projectId, instanceId, collectionId, docId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete docs based on metadata filters
     * @param {string} projectId 
     * @param {string} instanceId 
     * @param {string} collectionId 
     * @param {string} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public documentControllerDeleteDocsFromCollection(projectId: string, instanceId: string, collectionId: string, filter: string, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentControllerDeleteDocsFromCollection(projectId, instanceId, collectionId, filter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all collections
     * @param {string} projectId 
     * @param {string} instanceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public documentControllerGetAllCollections(projectId: string, instanceId: string, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentControllerGetAllCollections(projectId, instanceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get collection info
     * @param {string} projectId 
     * @param {string} instanceId 
     * @param {string} collectionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public documentControllerGetCollectionInfo(projectId: string, instanceId: string, collectionId: string, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentControllerGetCollectionInfo(projectId, instanceId, collectionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get doc by ID
     * @param {string} projectId 
     * @param {string} instanceId 
     * @param {string} collectionId 
     * @param {string} docId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public documentControllerGetDocById(projectId: string, instanceId: string, collectionId: string, docId: string, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentControllerGetDocById(projectId, instanceId, collectionId, docId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Similarity search query
     * @param {string} projectId 
     * @param {string} instanceId 
     * @param {string} collectionId 
     * @param {SimilaritySearchQueryDTO} similaritySearchQueryDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public documentControllerSimilaritySearch(projectId: string, instanceId: string, collectionId: string, similaritySearchQueryDTO: SimilaritySearchQueryDTO, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentControllerSimilaritySearch(projectId, instanceId, collectionId, similaritySearchQueryDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update collection
     * @param {string} projectId 
     * @param {string} instanceId 
     * @param {string} collectionId 
     * @param {CreateCollectionRequestDTO} createCollectionRequestDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public documentControllerUpdateCollection(projectId: string, instanceId: string, collectionId: string, createCollectionRequestDTO: CreateCollectionRequestDTO, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentControllerUpdateCollection(projectId, instanceId, collectionId, createCollectionRequestDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update or upsert doc
     * @param {string} projectId 
     * @param {string} instanceId 
     * @param {string} collectionId 
     * @param {string} docId 
     * @param {UpdateDocumentRequestDTO} updateDocumentRequestDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public documentControllerUpdateDoc(projectId: string, instanceId: string, collectionId: string, docId: string, updateDocumentRequestDTO: UpdateDocumentRequestDTO, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentControllerUpdateDoc(projectId, instanceId, collectionId, docId, updateDocumentRequestDTO, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * EvaluationTestApi - axios parameter creator
 */
export const EvaluationTestApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add new evaluation test.
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        evaluationTestControllerAddEvaluationTest: async (projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('evaluationTestControllerAddEvaluationTest', 'projectId', projectId)
            const localVarPath = `/projects/{projectId}/evaluation-tests`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete evaluation
         * @param {string} projectId 
         * @param {string} testId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        evaluationTestControllerDeleteEvaluation: async (projectId: string, testId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('evaluationTestControllerDeleteEvaluation', 'projectId', projectId)
            // verify required parameter 'testId' is not null or undefined
            assertParamExists('evaluationTestControllerDeleteEvaluation', 'testId', testId)
            const localVarPath = `/projects/{projectId}/evaluation-tests/{testId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"testId"}}`, encodeURIComponent(String(testId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Execute evaluation test.
         * @param {string} projectId 
         * @param {string} testId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        evaluationTestControllerExecuteEvaluation: async (projectId: string, testId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('evaluationTestControllerExecuteEvaluation', 'projectId', projectId)
            // verify required parameter 'testId' is not null or undefined
            assertParamExists('evaluationTestControllerExecuteEvaluation', 'testId', testId)
            const localVarPath = `/projects/{projectId}/evaluation-tests/{testId}/execute`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"testId"}}`, encodeURIComponent(String(testId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Fetch evaluation test.
         * @param {string} projectId 
         * @param {string} modelId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        evaluationTestControllerGetEvaluationTest: async (projectId: string, modelId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('evaluationTestControllerGetEvaluationTest', 'projectId', projectId)
            // verify required parameter 'modelId' is not null or undefined
            assertParamExists('evaluationTestControllerGetEvaluationTest', 'modelId', modelId)
            const localVarPath = `/projects/{projectId}/evaluation-tests/{modelId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"modelId"}}`, encodeURIComponent(String(modelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update evaluation test
         * @param {string} projectId 
         * @param {string} testId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        evaluationTestControllerUpdateEvaluation: async (projectId: string, testId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('evaluationTestControllerUpdateEvaluation', 'projectId', projectId)
            // verify required parameter 'testId' is not null or undefined
            assertParamExists('evaluationTestControllerUpdateEvaluation', 'testId', testId)
            const localVarPath = `/projects/{projectId}/evaluation-tests/{testId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"testId"}}`, encodeURIComponent(String(testId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EvaluationTestApi - functional programming interface
 */
export const EvaluationTestApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EvaluationTestApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add new evaluation test.
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async evaluationTestControllerAddEvaluationTest(projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.evaluationTestControllerAddEvaluationTest(projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EvaluationTestApi.evaluationTestControllerAddEvaluationTest']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete evaluation
         * @param {string} projectId 
         * @param {string} testId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async evaluationTestControllerDeleteEvaluation(projectId: string, testId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.evaluationTestControllerDeleteEvaluation(projectId, testId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EvaluationTestApi.evaluationTestControllerDeleteEvaluation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Execute evaluation test.
         * @param {string} projectId 
         * @param {string} testId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async evaluationTestControllerExecuteEvaluation(projectId: string, testId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.evaluationTestControllerExecuteEvaluation(projectId, testId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EvaluationTestApi.evaluationTestControllerExecuteEvaluation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Fetch evaluation test.
         * @param {string} projectId 
         * @param {string} modelId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async evaluationTestControllerGetEvaluationTest(projectId: string, modelId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.evaluationTestControllerGetEvaluationTest(projectId, modelId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EvaluationTestApi.evaluationTestControllerGetEvaluationTest']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update evaluation test
         * @param {string} projectId 
         * @param {string} testId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async evaluationTestControllerUpdateEvaluation(projectId: string, testId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.evaluationTestControllerUpdateEvaluation(projectId, testId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EvaluationTestApi.evaluationTestControllerUpdateEvaluation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * EvaluationTestApi - factory interface
 */
export const EvaluationTestApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EvaluationTestApiFp(configuration)
    return {
        /**
         * 
         * @summary Add new evaluation test.
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        evaluationTestControllerAddEvaluationTest(projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.evaluationTestControllerAddEvaluationTest(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete evaluation
         * @param {string} projectId 
         * @param {string} testId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        evaluationTestControllerDeleteEvaluation(projectId: string, testId: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.evaluationTestControllerDeleteEvaluation(projectId, testId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Execute evaluation test.
         * @param {string} projectId 
         * @param {string} testId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        evaluationTestControllerExecuteEvaluation(projectId: string, testId: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.evaluationTestControllerExecuteEvaluation(projectId, testId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Fetch evaluation test.
         * @param {string} projectId 
         * @param {string} modelId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        evaluationTestControllerGetEvaluationTest(projectId: string, modelId: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.evaluationTestControllerGetEvaluationTest(projectId, modelId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update evaluation test
         * @param {string} projectId 
         * @param {string} testId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        evaluationTestControllerUpdateEvaluation(projectId: string, testId: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.evaluationTestControllerUpdateEvaluation(projectId, testId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EvaluationTestApi - object-oriented interface
 */
export class EvaluationTestApi extends BaseAPI {
    /**
     * 
     * @summary Add new evaluation test.
     * @param {string} projectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public evaluationTestControllerAddEvaluationTest(projectId: string, options?: RawAxiosRequestConfig) {
        return EvaluationTestApiFp(this.configuration).evaluationTestControllerAddEvaluationTest(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete evaluation
     * @param {string} projectId 
     * @param {string} testId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public evaluationTestControllerDeleteEvaluation(projectId: string, testId: string, options?: RawAxiosRequestConfig) {
        return EvaluationTestApiFp(this.configuration).evaluationTestControllerDeleteEvaluation(projectId, testId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Execute evaluation test.
     * @param {string} projectId 
     * @param {string} testId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public evaluationTestControllerExecuteEvaluation(projectId: string, testId: string, options?: RawAxiosRequestConfig) {
        return EvaluationTestApiFp(this.configuration).evaluationTestControllerExecuteEvaluation(projectId, testId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Fetch evaluation test.
     * @param {string} projectId 
     * @param {string} modelId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public evaluationTestControllerGetEvaluationTest(projectId: string, modelId: string, options?: RawAxiosRequestConfig) {
        return EvaluationTestApiFp(this.configuration).evaluationTestControllerGetEvaluationTest(projectId, modelId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update evaluation test
     * @param {string} projectId 
     * @param {string} testId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public evaluationTestControllerUpdateEvaluation(projectId: string, testId: string, options?: RawAxiosRequestConfig) {
        return EvaluationTestApiFp(this.configuration).evaluationTestControllerUpdateEvaluation(projectId, testId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MachineAgentApi - axios parameter creator
 */
export const MachineAgentApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create New Machine Agent
         * @param {string} projectId 
         * @param {CreateMachineAgentDto} createMachineAgentDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        machineAgentControllerCreateMachineAgent: async (projectId: string, createMachineAgentDto: CreateMachineAgentDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('machineAgentControllerCreateMachineAgent', 'projectId', projectId)
            // verify required parameter 'createMachineAgentDto' is not null or undefined
            assertParamExists('machineAgentControllerCreateMachineAgent', 'createMachineAgentDto', createMachineAgentDto)
            const localVarPath = `/projects/{projectId}/agents`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createMachineAgentDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete machine agent
         * @param {string} projectId 
         * @param {string} agentId 
         * @param {Array<string>} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        machineAgentControllerDeleteMachineAgents: async (projectId: string, agentId: string, requestBody: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('machineAgentControllerDeleteMachineAgents', 'projectId', projectId)
            // verify required parameter 'agentId' is not null or undefined
            assertParamExists('machineAgentControllerDeleteMachineAgents', 'agentId', agentId)
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('machineAgentControllerDeleteMachineAgents', 'requestBody', requestBody)
            const localVarPath = `/projects/{projectId}/agents/{agentId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"agentId"}}`, encodeURIComponent(String(agentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all machine agent with count
         * @param {string} projectId 
         * @param {number} page 
         * @param {number} limit 
         * @param {string} type 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        machineAgentControllerGetMachineAgentByProjectId: async (projectId: string, page: number, limit: number, type: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('machineAgentControllerGetMachineAgentByProjectId', 'projectId', projectId)
            // verify required parameter 'page' is not null or undefined
            assertParamExists('machineAgentControllerGetMachineAgentByProjectId', 'page', page)
            // verify required parameter 'limit' is not null or undefined
            assertParamExists('machineAgentControllerGetMachineAgentByProjectId', 'limit', limit)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('machineAgentControllerGetMachineAgentByProjectId', 'type', type)
            const localVarPath = `/projects/{projectId}/agents`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update machine agent by id
         * @param {string} projectId 
         * @param {string} agentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        machineAgentControllerUpdateMachineAgent: async (projectId: string, agentId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('machineAgentControllerUpdateMachineAgent', 'projectId', projectId)
            // verify required parameter 'agentId' is not null or undefined
            assertParamExists('machineAgentControllerUpdateMachineAgent', 'agentId', agentId)
            const localVarPath = `/projects/{projectId}/agents/{agentId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"agentId"}}`, encodeURIComponent(String(agentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MachineAgentApi - functional programming interface
 */
export const MachineAgentApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MachineAgentApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create New Machine Agent
         * @param {string} projectId 
         * @param {CreateMachineAgentDto} createMachineAgentDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async machineAgentControllerCreateMachineAgent(projectId: string, createMachineAgentDto: CreateMachineAgentDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateMachineAgentDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.machineAgentControllerCreateMachineAgent(projectId, createMachineAgentDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MachineAgentApi.machineAgentControllerCreateMachineAgent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete machine agent
         * @param {string} projectId 
         * @param {string} agentId 
         * @param {Array<string>} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async machineAgentControllerDeleteMachineAgents(projectId: string, agentId: string, requestBody: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateMachineAgentDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.machineAgentControllerDeleteMachineAgents(projectId, agentId, requestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MachineAgentApi.machineAgentControllerDeleteMachineAgents']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all machine agent with count
         * @param {string} projectId 
         * @param {number} page 
         * @param {number} limit 
         * @param {string} type 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async machineAgentControllerGetMachineAgentByProjectId(projectId: string, page: number, limit: number, type: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateMachineAgentDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.machineAgentControllerGetMachineAgentByProjectId(projectId, page, limit, type, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MachineAgentApi.machineAgentControllerGetMachineAgentByProjectId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update machine agent by id
         * @param {string} projectId 
         * @param {string} agentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async machineAgentControllerUpdateMachineAgent(projectId: string, agentId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateMachineAgentDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.machineAgentControllerUpdateMachineAgent(projectId, agentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MachineAgentApi.machineAgentControllerUpdateMachineAgent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MachineAgentApi - factory interface
 */
export const MachineAgentApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MachineAgentApiFp(configuration)
    return {
        /**
         * 
         * @summary Create New Machine Agent
         * @param {string} projectId 
         * @param {CreateMachineAgentDto} createMachineAgentDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        machineAgentControllerCreateMachineAgent(projectId: string, createMachineAgentDto: CreateMachineAgentDto, options?: RawAxiosRequestConfig): AxiosPromise<CreateMachineAgentDto> {
            return localVarFp.machineAgentControllerCreateMachineAgent(projectId, createMachineAgentDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete machine agent
         * @param {string} projectId 
         * @param {string} agentId 
         * @param {Array<string>} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        machineAgentControllerDeleteMachineAgents(projectId: string, agentId: string, requestBody: Array<string>, options?: RawAxiosRequestConfig): AxiosPromise<CreateMachineAgentDto> {
            return localVarFp.machineAgentControllerDeleteMachineAgents(projectId, agentId, requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all machine agent with count
         * @param {string} projectId 
         * @param {number} page 
         * @param {number} limit 
         * @param {string} type 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        machineAgentControllerGetMachineAgentByProjectId(projectId: string, page: number, limit: number, type: string, options?: RawAxiosRequestConfig): AxiosPromise<CreateMachineAgentDto> {
            return localVarFp.machineAgentControllerGetMachineAgentByProjectId(projectId, page, limit, type, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update machine agent by id
         * @param {string} projectId 
         * @param {string} agentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        machineAgentControllerUpdateMachineAgent(projectId: string, agentId: string, options?: RawAxiosRequestConfig): AxiosPromise<CreateMachineAgentDto> {
            return localVarFp.machineAgentControllerUpdateMachineAgent(projectId, agentId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MachineAgentApi - object-oriented interface
 */
export class MachineAgentApi extends BaseAPI {
    /**
     * 
     * @summary Create New Machine Agent
     * @param {string} projectId 
     * @param {CreateMachineAgentDto} createMachineAgentDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public machineAgentControllerCreateMachineAgent(projectId: string, createMachineAgentDto: CreateMachineAgentDto, options?: RawAxiosRequestConfig) {
        return MachineAgentApiFp(this.configuration).machineAgentControllerCreateMachineAgent(projectId, createMachineAgentDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete machine agent
     * @param {string} projectId 
     * @param {string} agentId 
     * @param {Array<string>} requestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public machineAgentControllerDeleteMachineAgents(projectId: string, agentId: string, requestBody: Array<string>, options?: RawAxiosRequestConfig) {
        return MachineAgentApiFp(this.configuration).machineAgentControllerDeleteMachineAgents(projectId, agentId, requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all machine agent with count
     * @param {string} projectId 
     * @param {number} page 
     * @param {number} limit 
     * @param {string} type 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public machineAgentControllerGetMachineAgentByProjectId(projectId: string, page: number, limit: number, type: string, options?: RawAxiosRequestConfig) {
        return MachineAgentApiFp(this.configuration).machineAgentControllerGetMachineAgentByProjectId(projectId, page, limit, type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update machine agent by id
     * @param {string} projectId 
     * @param {string} agentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public machineAgentControllerUpdateMachineAgent(projectId: string, agentId: string, options?: RawAxiosRequestConfig) {
        return MachineAgentApiFp(this.configuration).machineAgentControllerUpdateMachineAgent(projectId, agentId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MachineAgentLogsApi - axios parameter creator
 */
export const MachineAgentLogsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Fetch agent logs.
         * @param {string} projectId 
         * @param {string} agentId 
         * @param {string} direction 
         * @param {string} cursor 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logsControllerFetchAgentLogs: async (projectId: string, agentId: string, direction: string, cursor: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('logsControllerFetchAgentLogs', 'projectId', projectId)
            // verify required parameter 'agentId' is not null or undefined
            assertParamExists('logsControllerFetchAgentLogs', 'agentId', agentId)
            // verify required parameter 'direction' is not null or undefined
            assertParamExists('logsControllerFetchAgentLogs', 'direction', direction)
            // verify required parameter 'cursor' is not null or undefined
            assertParamExists('logsControllerFetchAgentLogs', 'cursor', cursor)
            const localVarPath = `/projects/{projectId}/logs/{agentId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"agentId"}}`, encodeURIComponent(String(agentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Fetch event logs.
         * @param {string} projectId 
         * @param {string} agentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logsControllerFetchEventLogs: async (projectId: string, agentId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('logsControllerFetchEventLogs', 'projectId', projectId)
            // verify required parameter 'agentId' is not null or undefined
            assertParamExists('logsControllerFetchEventLogs', 'agentId', agentId)
            const localVarPath = `/projects/{projectId}/fetchEventLogs/{agentId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"agentId"}}`, encodeURIComponent(String(agentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MachineAgentLogsApi - functional programming interface
 */
export const MachineAgentLogsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MachineAgentLogsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Fetch agent logs.
         * @param {string} projectId 
         * @param {string} agentId 
         * @param {string} direction 
         * @param {string} cursor 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logsControllerFetchAgentLogs(projectId: string, agentId: string, direction: string, cursor: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logsControllerFetchAgentLogs(projectId, agentId, direction, cursor, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MachineAgentLogsApi.logsControllerFetchAgentLogs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Fetch event logs.
         * @param {string} projectId 
         * @param {string} agentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logsControllerFetchEventLogs(projectId: string, agentId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logsControllerFetchEventLogs(projectId, agentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MachineAgentLogsApi.logsControllerFetchEventLogs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MachineAgentLogsApi - factory interface
 */
export const MachineAgentLogsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MachineAgentLogsApiFp(configuration)
    return {
        /**
         * 
         * @summary Fetch agent logs.
         * @param {string} projectId 
         * @param {string} agentId 
         * @param {string} direction 
         * @param {string} cursor 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logsControllerFetchAgentLogs(projectId: string, agentId: string, direction: string, cursor: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.logsControllerFetchAgentLogs(projectId, agentId, direction, cursor, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Fetch event logs.
         * @param {string} projectId 
         * @param {string} agentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logsControllerFetchEventLogs(projectId: string, agentId: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.logsControllerFetchEventLogs(projectId, agentId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MachineAgentLogsApi - object-oriented interface
 */
export class MachineAgentLogsApi extends BaseAPI {
    /**
     * 
     * @summary Fetch agent logs.
     * @param {string} projectId 
     * @param {string} agentId 
     * @param {string} direction 
     * @param {string} cursor 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public logsControllerFetchAgentLogs(projectId: string, agentId: string, direction: string, cursor: string, options?: RawAxiosRequestConfig) {
        return MachineAgentLogsApiFp(this.configuration).logsControllerFetchAgentLogs(projectId, agentId, direction, cursor, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Fetch event logs.
     * @param {string} projectId 
     * @param {string} agentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public logsControllerFetchEventLogs(projectId: string, agentId: string, options?: RawAxiosRequestConfig) {
        return MachineAgentLogsApiFp(this.configuration).logsControllerFetchEventLogs(projectId, agentId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MachineInstancesApi - axios parameter creator
 */
export const MachineInstancesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create Machine Instance
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        machineInstancesControllerCreateMachineInstance: async (projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('machineInstancesControllerCreateMachineInstance', 'projectId', projectId)
            const localVarPath = `/projects/{projectId}/instances`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete machine instances by ids
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        machineInstancesControllerDeleteMachineInstance: async (projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('machineInstancesControllerDeleteMachineInstance', 'projectId', projectId)
            const localVarPath = `/projects/{projectId}/instances`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve running status of instances
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        machineInstancesControllerGetInstanceRunningStatus: async (projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('machineInstancesControllerGetInstanceRunningStatus', 'projectId', projectId)
            const localVarPath = `/projects/{projectId}/instances/status`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve CSV benchmarking datapoints for a specific machine
         * @param {string} projectId 
         * @param {string} machineId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        machineInstancesControllerGetMachineBenchmarkingDatapoints: async (projectId: string, machineId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('machineInstancesControllerGetMachineBenchmarkingDatapoints', 'projectId', projectId)
            // verify required parameter 'machineId' is not null or undefined
            assertParamExists('machineInstancesControllerGetMachineBenchmarkingDatapoints', 'machineId', machineId)
            const localVarPath = `/projects/{projectId}/instances/machine/{machineId}/benchmarking-datapoints`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"machineId"}}`, encodeURIComponent(String(machineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve benchmarking reports for a specific machine
         * @param {string} projectId 
         * @param {string} machineId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        machineInstancesControllerGetMachineBenchmarkingReports: async (projectId: string, machineId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('machineInstancesControllerGetMachineBenchmarkingReports', 'projectId', projectId)
            // verify required parameter 'machineId' is not null or undefined
            assertParamExists('machineInstancesControllerGetMachineBenchmarkingReports', 'machineId', machineId)
            const localVarPath = `/projects/{projectId}/instances/machine/{machineId}/benchmarking-reports`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"machineId"}}`, encodeURIComponent(String(machineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve status of a specific machine instance
         * @param {string} projectId 
         * @param {string} machineId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        machineInstancesControllerGetMachineBootstrapStatus: async (projectId: string, machineId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('machineInstancesControllerGetMachineBootstrapStatus', 'projectId', projectId)
            // verify required parameter 'machineId' is not null or undefined
            assertParamExists('machineInstancesControllerGetMachineBootstrapStatus', 'machineId', machineId)
            const localVarPath = `/projects/{projectId}/instances/machine/{machineId}/status`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"machineId"}}`, encodeURIComponent(String(machineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve running status of instances
         * @param {string} projectId 
         * @param {string} machineId 
         * @param {number} page 
         * @param {number} limit 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        machineInstancesControllerGetMachineInstanceById: async (projectId: string, machineId: string, page: number, limit: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('machineInstancesControllerGetMachineInstanceById', 'projectId', projectId)
            // verify required parameter 'machineId' is not null or undefined
            assertParamExists('machineInstancesControllerGetMachineInstanceById', 'machineId', machineId)
            // verify required parameter 'page' is not null or undefined
            assertParamExists('machineInstancesControllerGetMachineInstanceById', 'page', page)
            // verify required parameter 'limit' is not null or undefined
            assertParamExists('machineInstancesControllerGetMachineInstanceById', 'limit', limit)
            const localVarPath = `/projects/{projectId}/instances/machine/{machineId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"machineId"}}`, encodeURIComponent(String(machineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve all machine instances with count
         * @param {string} projectId 
         * @param {number} page 
         * @param {number} limit 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        machineInstancesControllerGetMachineInstanceByUserId: async (projectId: string, page: number, limit: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('machineInstancesControllerGetMachineInstanceByUserId', 'projectId', projectId)
            // verify required parameter 'page' is not null or undefined
            assertParamExists('machineInstancesControllerGetMachineInstanceByUserId', 'page', page)
            // verify required parameter 'limit' is not null or undefined
            assertParamExists('machineInstancesControllerGetMachineInstanceByUserId', 'limit', limit)
            const localVarPath = `/projects/{projectId}/instances`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Machine Instance Running Status
         * @param {string} projectId 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        machineInstancesControllerUpdateRunningStatus: async (projectId: string, body: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('machineInstancesControllerUpdateRunningStatus', 'projectId', projectId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('machineInstancesControllerUpdateRunningStatus', 'body', body)
            const localVarPath = `/projects/{projectId}/instances/status`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MachineInstancesApi - functional programming interface
 */
export const MachineInstancesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MachineInstancesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create Machine Instance
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async machineInstancesControllerCreateMachineInstance(projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.machineInstancesControllerCreateMachineInstance(projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MachineInstancesApi.machineInstancesControllerCreateMachineInstance']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete machine instances by ids
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async machineInstancesControllerDeleteMachineInstance(projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.machineInstancesControllerDeleteMachineInstance(projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MachineInstancesApi.machineInstancesControllerDeleteMachineInstance']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve running status of instances
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async machineInstancesControllerGetInstanceRunningStatus(projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.machineInstancesControllerGetInstanceRunningStatus(projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MachineInstancesApi.machineInstancesControllerGetInstanceRunningStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve CSV benchmarking datapoints for a specific machine
         * @param {string} projectId 
         * @param {string} machineId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async machineInstancesControllerGetMachineBenchmarkingDatapoints(projectId: string, machineId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BenchmarkingDatapointDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.machineInstancesControllerGetMachineBenchmarkingDatapoints(projectId, machineId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MachineInstancesApi.machineInstancesControllerGetMachineBenchmarkingDatapoints']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve benchmarking reports for a specific machine
         * @param {string} projectId 
         * @param {string} machineId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async machineInstancesControllerGetMachineBenchmarkingReports(projectId: string, machineId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BenchmarkingReportsDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.machineInstancesControllerGetMachineBenchmarkingReports(projectId, machineId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MachineInstancesApi.machineInstancesControllerGetMachineBenchmarkingReports']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve status of a specific machine instance
         * @param {string} projectId 
         * @param {string} machineId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async machineInstancesControllerGetMachineBootstrapStatus(projectId: string, machineId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MachineStatusDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.machineInstancesControllerGetMachineBootstrapStatus(projectId, machineId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MachineInstancesApi.machineInstancesControllerGetMachineBootstrapStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve running status of instances
         * @param {string} projectId 
         * @param {string} machineId 
         * @param {number} page 
         * @param {number} limit 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async machineInstancesControllerGetMachineInstanceById(projectId: string, machineId: string, page: number, limit: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.machineInstancesControllerGetMachineInstanceById(projectId, machineId, page, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MachineInstancesApi.machineInstancesControllerGetMachineInstanceById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve all machine instances with count
         * @param {string} projectId 
         * @param {number} page 
         * @param {number} limit 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async machineInstancesControllerGetMachineInstanceByUserId(projectId: string, page: number, limit: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.machineInstancesControllerGetMachineInstanceByUserId(projectId, page, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MachineInstancesApi.machineInstancesControllerGetMachineInstanceByUserId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update Machine Instance Running Status
         * @param {string} projectId 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async machineInstancesControllerUpdateRunningStatus(projectId: string, body: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.machineInstancesControllerUpdateRunningStatus(projectId, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MachineInstancesApi.machineInstancesControllerUpdateRunningStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MachineInstancesApi - factory interface
 */
export const MachineInstancesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MachineInstancesApiFp(configuration)
    return {
        /**
         * 
         * @summary Create Machine Instance
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        machineInstancesControllerCreateMachineInstance(projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.machineInstancesControllerCreateMachineInstance(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete machine instances by ids
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        machineInstancesControllerDeleteMachineInstance(projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.machineInstancesControllerDeleteMachineInstance(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve running status of instances
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        machineInstancesControllerGetInstanceRunningStatus(projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.machineInstancesControllerGetInstanceRunningStatus(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve CSV benchmarking datapoints for a specific machine
         * @param {string} projectId 
         * @param {string} machineId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        machineInstancesControllerGetMachineBenchmarkingDatapoints(projectId: string, machineId: string, options?: RawAxiosRequestConfig): AxiosPromise<BenchmarkingDatapointDto> {
            return localVarFp.machineInstancesControllerGetMachineBenchmarkingDatapoints(projectId, machineId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve benchmarking reports for a specific machine
         * @param {string} projectId 
         * @param {string} machineId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        machineInstancesControllerGetMachineBenchmarkingReports(projectId: string, machineId: string, options?: RawAxiosRequestConfig): AxiosPromise<BenchmarkingReportsDto> {
            return localVarFp.machineInstancesControllerGetMachineBenchmarkingReports(projectId, machineId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve status of a specific machine instance
         * @param {string} projectId 
         * @param {string} machineId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        machineInstancesControllerGetMachineBootstrapStatus(projectId: string, machineId: string, options?: RawAxiosRequestConfig): AxiosPromise<MachineStatusDto> {
            return localVarFp.machineInstancesControllerGetMachineBootstrapStatus(projectId, machineId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve running status of instances
         * @param {string} projectId 
         * @param {string} machineId 
         * @param {number} page 
         * @param {number} limit 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        machineInstancesControllerGetMachineInstanceById(projectId: string, machineId: string, page: number, limit: number, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.machineInstancesControllerGetMachineInstanceById(projectId, machineId, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve all machine instances with count
         * @param {string} projectId 
         * @param {number} page 
         * @param {number} limit 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        machineInstancesControllerGetMachineInstanceByUserId(projectId: string, page: number, limit: number, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.machineInstancesControllerGetMachineInstanceByUserId(projectId, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Machine Instance Running Status
         * @param {string} projectId 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        machineInstancesControllerUpdateRunningStatus(projectId: string, body: object, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.machineInstancesControllerUpdateRunningStatus(projectId, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MachineInstancesApi - object-oriented interface
 */
export class MachineInstancesApi extends BaseAPI {
    /**
     * 
     * @summary Create Machine Instance
     * @param {string} projectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public machineInstancesControllerCreateMachineInstance(projectId: string, options?: RawAxiosRequestConfig) {
        return MachineInstancesApiFp(this.configuration).machineInstancesControllerCreateMachineInstance(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete machine instances by ids
     * @param {string} projectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public machineInstancesControllerDeleteMachineInstance(projectId: string, options?: RawAxiosRequestConfig) {
        return MachineInstancesApiFp(this.configuration).machineInstancesControllerDeleteMachineInstance(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve running status of instances
     * @param {string} projectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public machineInstancesControllerGetInstanceRunningStatus(projectId: string, options?: RawAxiosRequestConfig) {
        return MachineInstancesApiFp(this.configuration).machineInstancesControllerGetInstanceRunningStatus(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve CSV benchmarking datapoints for a specific machine
     * @param {string} projectId 
     * @param {string} machineId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public machineInstancesControllerGetMachineBenchmarkingDatapoints(projectId: string, machineId: string, options?: RawAxiosRequestConfig) {
        return MachineInstancesApiFp(this.configuration).machineInstancesControllerGetMachineBenchmarkingDatapoints(projectId, machineId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve benchmarking reports for a specific machine
     * @param {string} projectId 
     * @param {string} machineId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public machineInstancesControllerGetMachineBenchmarkingReports(projectId: string, machineId: string, options?: RawAxiosRequestConfig) {
        return MachineInstancesApiFp(this.configuration).machineInstancesControllerGetMachineBenchmarkingReports(projectId, machineId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve status of a specific machine instance
     * @param {string} projectId 
     * @param {string} machineId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public machineInstancesControllerGetMachineBootstrapStatus(projectId: string, machineId: string, options?: RawAxiosRequestConfig) {
        return MachineInstancesApiFp(this.configuration).machineInstancesControllerGetMachineBootstrapStatus(projectId, machineId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve running status of instances
     * @param {string} projectId 
     * @param {string} machineId 
     * @param {number} page 
     * @param {number} limit 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public machineInstancesControllerGetMachineInstanceById(projectId: string, machineId: string, page: number, limit: number, options?: RawAxiosRequestConfig) {
        return MachineInstancesApiFp(this.configuration).machineInstancesControllerGetMachineInstanceById(projectId, machineId, page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve all machine instances with count
     * @param {string} projectId 
     * @param {number} page 
     * @param {number} limit 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public machineInstancesControllerGetMachineInstanceByUserId(projectId: string, page: number, limit: number, options?: RawAxiosRequestConfig) {
        return MachineInstancesApiFp(this.configuration).machineInstancesControllerGetMachineInstanceByUserId(projectId, page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Machine Instance Running Status
     * @param {string} projectId 
     * @param {object} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public machineInstancesControllerUpdateRunningStatus(projectId: string, body: object, options?: RawAxiosRequestConfig) {
        return MachineInstancesApiFp(this.configuration).machineInstancesControllerUpdateRunningStatus(projectId, body, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MembersApi - axios parameter creator
 */
export const MembersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add a team member
         * @param {string} projectId 
         * @param {AddProjectMemberDto} addProjectMemberDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        membersControllerAddTeamMemberToProject: async (projectId: string, addProjectMemberDto: AddProjectMemberDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('membersControllerAddTeamMemberToProject', 'projectId', projectId)
            // verify required parameter 'addProjectMemberDto' is not null or undefined
            assertParamExists('membersControllerAddTeamMemberToProject', 'addProjectMemberDto', addProjectMemberDto)
            const localVarPath = `/projects/{projectId}/members`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addProjectMemberDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve all team members
         * @param {string} projectId 
         * @param {number} [page] 
         * @param {number} [limit] 
         * @param {string} [column] 
         * @param {MembersControllerGetAllTeamMembersOfProjectDirectionEnum} [direction] 
         * @param {Array<string>} [teamMemberStatus] 
         * @param {Array<number>} [roleIds] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        membersControllerGetAllTeamMembersOfProject: async (projectId: string, page?: number, limit?: number, column?: string, direction?: MembersControllerGetAllTeamMembersOfProjectDirectionEnum, teamMemberStatus?: Array<string>, roleIds?: Array<number>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('membersControllerGetAllTeamMembersOfProject', 'projectId', projectId)
            const localVarPath = `/projects/{projectId}/members`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (column !== undefined) {
                localVarQueryParameter['column'] = column;
            }

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }

            if (teamMemberStatus) {
                localVarQueryParameter['teamMemberStatus'] = teamMemberStatus;
            }

            if (roleIds) {
                localVarQueryParameter['roleIds'] = roleIds;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update team member details
         * @param {string} projectId 
         * @param {string} memberId 
         * @param {UpdateTeamMemberRequestDTO} updateTeamMemberRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        membersControllerUpdateTeamMemberRole: async (projectId: string, memberId: string, updateTeamMemberRequestDTO: UpdateTeamMemberRequestDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('membersControllerUpdateTeamMemberRole', 'projectId', projectId)
            // verify required parameter 'memberId' is not null or undefined
            assertParamExists('membersControllerUpdateTeamMemberRole', 'memberId', memberId)
            // verify required parameter 'updateTeamMemberRequestDTO' is not null or undefined
            assertParamExists('membersControllerUpdateTeamMemberRole', 'updateTeamMemberRequestDTO', updateTeamMemberRequestDTO)
            const localVarPath = `/projects/{projectId}/members/{memberId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"memberId"}}`, encodeURIComponent(String(memberId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateTeamMemberRequestDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MembersApi - functional programming interface
 */
export const MembersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MembersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add a team member
         * @param {string} projectId 
         * @param {AddProjectMemberDto} addProjectMemberDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async membersControllerAddTeamMemberToProject(projectId: string, addProjectMemberDto: AddProjectMemberDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddProjectMemberResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.membersControllerAddTeamMemberToProject(projectId, addProjectMemberDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MembersApi.membersControllerAddTeamMemberToProject']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve all team members
         * @param {string} projectId 
         * @param {number} [page] 
         * @param {number} [limit] 
         * @param {string} [column] 
         * @param {MembersControllerGetAllTeamMembersOfProjectDirectionEnum} [direction] 
         * @param {Array<string>} [teamMemberStatus] 
         * @param {Array<number>} [roleIds] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async membersControllerGetAllTeamMembersOfProject(projectId: string, page?: number, limit?: number, column?: string, direction?: MembersControllerGetAllTeamMembersOfProjectDirectionEnum, teamMemberStatus?: Array<string>, roleIds?: Array<number>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAllProjectMemberResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.membersControllerGetAllTeamMembersOfProject(projectId, page, limit, column, direction, teamMemberStatus, roleIds, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MembersApi.membersControllerGetAllTeamMembersOfProject']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update team member details
         * @param {string} projectId 
         * @param {string} memberId 
         * @param {UpdateTeamMemberRequestDTO} updateTeamMemberRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async membersControllerUpdateTeamMemberRole(projectId: string, memberId: string, updateTeamMemberRequestDTO: UpdateTeamMemberRequestDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddProjectMemberResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.membersControllerUpdateTeamMemberRole(projectId, memberId, updateTeamMemberRequestDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MembersApi.membersControllerUpdateTeamMemberRole']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MembersApi - factory interface
 */
export const MembersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MembersApiFp(configuration)
    return {
        /**
         * 
         * @summary Add a team member
         * @param {string} projectId 
         * @param {AddProjectMemberDto} addProjectMemberDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        membersControllerAddTeamMemberToProject(projectId: string, addProjectMemberDto: AddProjectMemberDto, options?: RawAxiosRequestConfig): AxiosPromise<AddProjectMemberResponseDTO> {
            return localVarFp.membersControllerAddTeamMemberToProject(projectId, addProjectMemberDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve all team members
         * @param {string} projectId 
         * @param {number} [page] 
         * @param {number} [limit] 
         * @param {string} [column] 
         * @param {MembersControllerGetAllTeamMembersOfProjectDirectionEnum} [direction] 
         * @param {Array<string>} [teamMemberStatus] 
         * @param {Array<number>} [roleIds] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        membersControllerGetAllTeamMembersOfProject(projectId: string, page?: number, limit?: number, column?: string, direction?: MembersControllerGetAllTeamMembersOfProjectDirectionEnum, teamMemberStatus?: Array<string>, roleIds?: Array<number>, options?: RawAxiosRequestConfig): AxiosPromise<GetAllProjectMemberResponseDto> {
            return localVarFp.membersControllerGetAllTeamMembersOfProject(projectId, page, limit, column, direction, teamMemberStatus, roleIds, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update team member details
         * @param {string} projectId 
         * @param {string} memberId 
         * @param {UpdateTeamMemberRequestDTO} updateTeamMemberRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        membersControllerUpdateTeamMemberRole(projectId: string, memberId: string, updateTeamMemberRequestDTO: UpdateTeamMemberRequestDTO, options?: RawAxiosRequestConfig): AxiosPromise<AddProjectMemberResponseDTO> {
            return localVarFp.membersControllerUpdateTeamMemberRole(projectId, memberId, updateTeamMemberRequestDTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MembersApi - object-oriented interface
 */
export class MembersApi extends BaseAPI {
    /**
     * 
     * @summary Add a team member
     * @param {string} projectId 
     * @param {AddProjectMemberDto} addProjectMemberDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public membersControllerAddTeamMemberToProject(projectId: string, addProjectMemberDto: AddProjectMemberDto, options?: RawAxiosRequestConfig) {
        return MembersApiFp(this.configuration).membersControllerAddTeamMemberToProject(projectId, addProjectMemberDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve all team members
     * @param {string} projectId 
     * @param {number} [page] 
     * @param {number} [limit] 
     * @param {string} [column] 
     * @param {MembersControllerGetAllTeamMembersOfProjectDirectionEnum} [direction] 
     * @param {Array<string>} [teamMemberStatus] 
     * @param {Array<number>} [roleIds] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public membersControllerGetAllTeamMembersOfProject(projectId: string, page?: number, limit?: number, column?: string, direction?: MembersControllerGetAllTeamMembersOfProjectDirectionEnum, teamMemberStatus?: Array<string>, roleIds?: Array<number>, options?: RawAxiosRequestConfig) {
        return MembersApiFp(this.configuration).membersControllerGetAllTeamMembersOfProject(projectId, page, limit, column, direction, teamMemberStatus, roleIds, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update team member details
     * @param {string} projectId 
     * @param {string} memberId 
     * @param {UpdateTeamMemberRequestDTO} updateTeamMemberRequestDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public membersControllerUpdateTeamMemberRole(projectId: string, memberId: string, updateTeamMemberRequestDTO: UpdateTeamMemberRequestDTO, options?: RawAxiosRequestConfig) {
        return MembersApiFp(this.configuration).membersControllerUpdateTeamMemberRole(projectId, memberId, updateTeamMemberRequestDTO, options).then((request) => request(this.axios, this.basePath));
    }
}

export const MembersControllerGetAllTeamMembersOfProjectDirectionEnum = {
    Asc: 'ASC',
    Desc: 'DESC'
} as const;
export type MembersControllerGetAllTeamMembersOfProjectDirectionEnum = typeof MembersControllerGetAllTeamMembersOfProjectDirectionEnum[keyof typeof MembersControllerGetAllTeamMembersOfProjectDirectionEnum];


/**
 * MiscellaneousApi - axios parameter creator
 */
export const MiscellaneousApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get machine id matching instances.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        miscellaneousControllerGetData: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/projects/machine/images`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get machine id matching instances.
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        miscellaneousControllerGetMachineInstanceByImageId: async (projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('miscellaneousControllerGetMachineInstanceByImageId', 'projectId', projectId)
            const localVarPath = `/projects/{projectId}/allMachineInstance`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Join project
         * @param {UpdateTeamMemberStatusRequestDTO} updateTeamMemberStatusRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        miscellaneousControllerUpdateTeamMemberStatus: async (updateTeamMemberStatusRequestDTO: UpdateTeamMemberStatusRequestDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateTeamMemberStatusRequestDTO' is not null or undefined
            assertParamExists('miscellaneousControllerUpdateTeamMemberStatus', 'updateTeamMemberStatusRequestDTO', updateTeamMemberStatusRequestDTO)
            const localVarPath = `/projects/member/join`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateTeamMemberStatusRequestDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MiscellaneousApi - functional programming interface
 */
export const MiscellaneousApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MiscellaneousApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get machine id matching instances.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async miscellaneousControllerGetData(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.miscellaneousControllerGetData(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MiscellaneousApi.miscellaneousControllerGetData']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get machine id matching instances.
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async miscellaneousControllerGetMachineInstanceByImageId(projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.miscellaneousControllerGetMachineInstanceByImageId(projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MiscellaneousApi.miscellaneousControllerGetMachineInstanceByImageId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Join project
         * @param {UpdateTeamMemberStatusRequestDTO} updateTeamMemberStatusRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async miscellaneousControllerUpdateTeamMemberStatus(updateTeamMemberStatusRequestDTO: UpdateTeamMemberStatusRequestDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddProjectMemberResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.miscellaneousControllerUpdateTeamMemberStatus(updateTeamMemberStatusRequestDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MiscellaneousApi.miscellaneousControllerUpdateTeamMemberStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MiscellaneousApi - factory interface
 */
export const MiscellaneousApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MiscellaneousApiFp(configuration)
    return {
        /**
         * 
         * @summary Get machine id matching instances.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        miscellaneousControllerGetData(options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.miscellaneousControllerGetData(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get machine id matching instances.
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        miscellaneousControllerGetMachineInstanceByImageId(projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.miscellaneousControllerGetMachineInstanceByImageId(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Join project
         * @param {UpdateTeamMemberStatusRequestDTO} updateTeamMemberStatusRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        miscellaneousControllerUpdateTeamMemberStatus(updateTeamMemberStatusRequestDTO: UpdateTeamMemberStatusRequestDTO, options?: RawAxiosRequestConfig): AxiosPromise<AddProjectMemberResponseDTO> {
            return localVarFp.miscellaneousControllerUpdateTeamMemberStatus(updateTeamMemberStatusRequestDTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MiscellaneousApi - object-oriented interface
 */
export class MiscellaneousApi extends BaseAPI {
    /**
     * 
     * @summary Get machine id matching instances.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public miscellaneousControllerGetData(options?: RawAxiosRequestConfig) {
        return MiscellaneousApiFp(this.configuration).miscellaneousControllerGetData(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get machine id matching instances.
     * @param {string} projectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public miscellaneousControllerGetMachineInstanceByImageId(projectId: string, options?: RawAxiosRequestConfig) {
        return MiscellaneousApiFp(this.configuration).miscellaneousControllerGetMachineInstanceByImageId(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Join project
     * @param {UpdateTeamMemberStatusRequestDTO} updateTeamMemberStatusRequestDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public miscellaneousControllerUpdateTeamMemberStatus(updateTeamMemberStatusRequestDTO: UpdateTeamMemberStatusRequestDTO, options?: RawAxiosRequestConfig) {
        return MiscellaneousApiFp(this.configuration).miscellaneousControllerUpdateTeamMemberStatus(updateTeamMemberStatusRequestDTO, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * NotificationsApi - axios parameter creator
 */
export const NotificationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Retrieve last notifications
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationsControllerGetLastFiveNotifications: async (projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('notificationsControllerGetLastFiveNotifications', 'projectId', projectId)
            const localVarPath = `/projects/{projectId}/notifications`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Mark notification as read
         * @param {string} projectId 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationsControllerMarkNotificationsAsRead: async (projectId: string, body: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('notificationsControllerMarkNotificationsAsRead', 'projectId', projectId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('notificationsControllerMarkNotificationsAsRead', 'body', body)
            const localVarPath = `/projects/{projectId}/notifications/status`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NotificationsApi - functional programming interface
 */
export const NotificationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NotificationsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Retrieve last notifications
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async notificationsControllerGetLastFiveNotifications(projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.notificationsControllerGetLastFiveNotifications(projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NotificationsApi.notificationsControllerGetLastFiveNotifications']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Mark notification as read
         * @param {string} projectId 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async notificationsControllerMarkNotificationsAsRead(projectId: string, body: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.notificationsControllerMarkNotificationsAsRead(projectId, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NotificationsApi.notificationsControllerMarkNotificationsAsRead']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * NotificationsApi - factory interface
 */
export const NotificationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NotificationsApiFp(configuration)
    return {
        /**
         * 
         * @summary Retrieve last notifications
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationsControllerGetLastFiveNotifications(projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.notificationsControllerGetLastFiveNotifications(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Mark notification as read
         * @param {string} projectId 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationsControllerMarkNotificationsAsRead(projectId: string, body: object, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.notificationsControllerMarkNotificationsAsRead(projectId, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * NotificationsApi - object-oriented interface
 */
export class NotificationsApi extends BaseAPI {
    /**
     * 
     * @summary Retrieve last notifications
     * @param {string} projectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public notificationsControllerGetLastFiveNotifications(projectId: string, options?: RawAxiosRequestConfig) {
        return NotificationsApiFp(this.configuration).notificationsControllerGetLastFiveNotifications(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Mark notification as read
     * @param {string} projectId 
     * @param {object} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public notificationsControllerMarkNotificationsAsRead(projectId: string, body: object, options?: RawAxiosRequestConfig) {
        return NotificationsApiFp(this.configuration).notificationsControllerMarkNotificationsAsRead(projectId, body, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProjectsApi - axios parameter creator
 */
export const ProjectsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create Project
         * @param {CreateProjectDTO} createProjectDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectControllerCreateProject: async (createProjectDTO: CreateProjectDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createProjectDTO' is not null or undefined
            assertParamExists('projectControllerCreateProject', 'createProjectDTO', createProjectDTO)
            const localVarPath = `/projects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createProjectDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete project by id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectControllerDeleteProjectById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('projectControllerDeleteProjectById', 'id', id)
            const localVarPath = `/projects/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all projects
         * @param {number} [page] 
         * @param {number} [limit] 
         * @param {string} [column] 
         * @param {ProjectControllerGetAllProjectsDirectionEnum} [direction] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectControllerGetAllProjects: async (page?: number, limit?: number, column?: string, direction?: ProjectControllerGetAllProjectsDirectionEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/projects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (column !== undefined) {
                localVarQueryParameter['column'] = column;
            }

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get project by id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectControllerGetProjectById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('projectControllerGetProjectById', 'id', id)
            const localVarPath = `/projects/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update project by id
         * @param {string} id 
         * @param {UpdateProjectByIdRequest} updateProjectByIdRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectControllerUpdateProjectById: async (id: string, updateProjectByIdRequest: UpdateProjectByIdRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('projectControllerUpdateProjectById', 'id', id)
            // verify required parameter 'updateProjectByIdRequest' is not null or undefined
            assertParamExists('projectControllerUpdateProjectById', 'updateProjectByIdRequest', updateProjectByIdRequest)
            const localVarPath = `/projects/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateProjectByIdRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProjectsApi - functional programming interface
 */
export const ProjectsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProjectsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create Project
         * @param {CreateProjectDTO} createProjectDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectControllerCreateProject(createProjectDTO: CreateProjectDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateProjectResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectControllerCreateProject(createProjectDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectsApi.projectControllerCreateProject']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete project by id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectControllerDeleteProjectById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteProjectResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectControllerDeleteProjectById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectsApi.projectControllerDeleteProjectById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all projects
         * @param {number} [page] 
         * @param {number} [limit] 
         * @param {string} [column] 
         * @param {ProjectControllerGetAllProjectsDirectionEnum} [direction] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectControllerGetAllProjects(page?: number, limit?: number, column?: string, direction?: ProjectControllerGetAllProjectsDirectionEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAllProjectsResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectControllerGetAllProjects(page, limit, column, direction, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectsApi.projectControllerGetAllProjects']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get project by id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectControllerGetProjectById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetProjectByIDResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectControllerGetProjectById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectsApi.projectControllerGetProjectById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update project by id
         * @param {string} id 
         * @param {UpdateProjectByIdRequest} updateProjectByIdRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectControllerUpdateProjectById(id: string, updateProjectByIdRequest: UpdateProjectByIdRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateProjectByIDResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectControllerUpdateProjectById(id, updateProjectByIdRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectsApi.projectControllerUpdateProjectById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProjectsApi - factory interface
 */
export const ProjectsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProjectsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create Project
         * @param {CreateProjectDTO} createProjectDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectControllerCreateProject(createProjectDTO: CreateProjectDTO, options?: RawAxiosRequestConfig): AxiosPromise<CreateProjectResponseDTO> {
            return localVarFp.projectControllerCreateProject(createProjectDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete project by id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectControllerDeleteProjectById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<DeleteProjectResponseDTO> {
            return localVarFp.projectControllerDeleteProjectById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all projects
         * @param {number} [page] 
         * @param {number} [limit] 
         * @param {string} [column] 
         * @param {ProjectControllerGetAllProjectsDirectionEnum} [direction] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectControllerGetAllProjects(page?: number, limit?: number, column?: string, direction?: ProjectControllerGetAllProjectsDirectionEnum, options?: RawAxiosRequestConfig): AxiosPromise<GetAllProjectsResponseDTO> {
            return localVarFp.projectControllerGetAllProjects(page, limit, column, direction, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get project by id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectControllerGetProjectById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<GetProjectByIDResponseDTO> {
            return localVarFp.projectControllerGetProjectById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update project by id
         * @param {string} id 
         * @param {UpdateProjectByIdRequest} updateProjectByIdRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectControllerUpdateProjectById(id: string, updateProjectByIdRequest: UpdateProjectByIdRequest, options?: RawAxiosRequestConfig): AxiosPromise<UpdateProjectByIDResponseDTO> {
            return localVarFp.projectControllerUpdateProjectById(id, updateProjectByIdRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProjectsApi - object-oriented interface
 */
export class ProjectsApi extends BaseAPI {
    /**
     * 
     * @summary Create Project
     * @param {CreateProjectDTO} createProjectDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public projectControllerCreateProject(createProjectDTO: CreateProjectDTO, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).projectControllerCreateProject(createProjectDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete project by id
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public projectControllerDeleteProjectById(id: string, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).projectControllerDeleteProjectById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all projects
     * @param {number} [page] 
     * @param {number} [limit] 
     * @param {string} [column] 
     * @param {ProjectControllerGetAllProjectsDirectionEnum} [direction] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public projectControllerGetAllProjects(page?: number, limit?: number, column?: string, direction?: ProjectControllerGetAllProjectsDirectionEnum, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).projectControllerGetAllProjects(page, limit, column, direction, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get project by id
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public projectControllerGetProjectById(id: string, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).projectControllerGetProjectById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update project by id
     * @param {string} id 
     * @param {UpdateProjectByIdRequest} updateProjectByIdRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public projectControllerUpdateProjectById(id: string, updateProjectByIdRequest: UpdateProjectByIdRequest, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).projectControllerUpdateProjectById(id, updateProjectByIdRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

export const ProjectControllerGetAllProjectsDirectionEnum = {
    Asc: 'ASC',
    Desc: 'DESC'
} as const;
export type ProjectControllerGetAllProjectsDirectionEnum = typeof ProjectControllerGetAllProjectsDirectionEnum[keyof typeof ProjectControllerGetAllProjectsDirectionEnum];


/**
 * QueriesAndDocumentationsApi - axios parameter creator
 */
export const QueriesAndDocumentationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Fetch Swagger JSON
         * @param {string} modelId 
         * @param {string} projectId 
         * @param {string} fieldName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queriesAndDocControllerFetchSwaggerJSON: async (modelId: string, projectId: string, fieldName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'modelId' is not null or undefined
            assertParamExists('queriesAndDocControllerFetchSwaggerJSON', 'modelId', modelId)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('queriesAndDocControllerFetchSwaggerJSON', 'projectId', projectId)
            // verify required parameter 'fieldName' is not null or undefined
            assertParamExists('queriesAndDocControllerFetchSwaggerJSON', 'fieldName', fieldName)
            const localVarPath = `/projects/{projectId}/{fieldName}/{modelId}/swagger`
                .replace(`{${"modelId"}}`, encodeURIComponent(String(modelId)))
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"fieldName"}}`, encodeURIComponent(String(fieldName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Run Query
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queriesAndDocControllerRunQuery: async (projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('queriesAndDocControllerRunQuery', 'projectId', projectId)
            const localVarPath = `/projects/{projectId}/queries`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * QueriesAndDocumentationsApi - functional programming interface
 */
export const QueriesAndDocumentationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = QueriesAndDocumentationsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Fetch Swagger JSON
         * @param {string} modelId 
         * @param {string} projectId 
         * @param {string} fieldName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async queriesAndDocControllerFetchSwaggerJSON(modelId: string, projectId: string, fieldName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.queriesAndDocControllerFetchSwaggerJSON(modelId, projectId, fieldName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['QueriesAndDocumentationsApi.queriesAndDocControllerFetchSwaggerJSON']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Run Query
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async queriesAndDocControllerRunQuery(projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateWebhookDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.queriesAndDocControllerRunQuery(projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['QueriesAndDocumentationsApi.queriesAndDocControllerRunQuery']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * QueriesAndDocumentationsApi - factory interface
 */
export const QueriesAndDocumentationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = QueriesAndDocumentationsApiFp(configuration)
    return {
        /**
         * 
         * @summary Fetch Swagger JSON
         * @param {string} modelId 
         * @param {string} projectId 
         * @param {string} fieldName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queriesAndDocControllerFetchSwaggerJSON(modelId: string, projectId: string, fieldName: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.queriesAndDocControllerFetchSwaggerJSON(modelId, projectId, fieldName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Run Query
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queriesAndDocControllerRunQuery(projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<CreateWebhookDto> {
            return localVarFp.queriesAndDocControllerRunQuery(projectId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * QueriesAndDocumentationsApi - object-oriented interface
 */
export class QueriesAndDocumentationsApi extends BaseAPI {
    /**
     * 
     * @summary Fetch Swagger JSON
     * @param {string} modelId 
     * @param {string} projectId 
     * @param {string} fieldName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public queriesAndDocControllerFetchSwaggerJSON(modelId: string, projectId: string, fieldName: string, options?: RawAxiosRequestConfig) {
        return QueriesAndDocumentationsApiFp(this.configuration).queriesAndDocControllerFetchSwaggerJSON(modelId, projectId, fieldName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Run Query
     * @param {string} projectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public queriesAndDocControllerRunQuery(projectId: string, options?: RawAxiosRequestConfig) {
        return QueriesAndDocumentationsApiFp(this.configuration).queriesAndDocControllerRunQuery(projectId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RolesApi - axios parameter creator
 */
export const RolesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new role
         * @param {string} projectId 
         * @param {CreateRoleDto} createRoleDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolesControllerCreateProjectRole: async (projectId: string, createRoleDto: CreateRoleDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('rolesControllerCreateProjectRole', 'projectId', projectId)
            // verify required parameter 'createRoleDto' is not null or undefined
            assertParamExists('rolesControllerCreateProjectRole', 'createRoleDto', createRoleDto)
            const localVarPath = `/projects/{projectId}/roles`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createRoleDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Project Role
         * @param {string} projectId 
         * @param {number} roleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolesControllerDeleteProjectRole: async (projectId: string, roleId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('rolesControllerDeleteProjectRole', 'projectId', projectId)
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('rolesControllerDeleteProjectRole', 'roleId', roleId)
            const localVarPath = `/projects/{projectId}/roles/{roleId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"roleId"}}`, encodeURIComponent(String(roleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve all roles
         * @param {string} projectId 
         * @param {number} [page] 
         * @param {number} [limit] 
         * @param {string} [column] 
         * @param {RolesControllerGetAllProjectRolesDirectionEnum} [direction] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolesControllerGetAllProjectRoles: async (projectId: string, page?: number, limit?: number, column?: string, direction?: RolesControllerGetAllProjectRolesDirectionEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('rolesControllerGetAllProjectRoles', 'projectId', projectId)
            const localVarPath = `/projects/{projectId}/roles`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (column !== undefined) {
                localVarQueryParameter['column'] = column;
            }

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a role by ID
         * @param {string} projectId 
         * @param {number} roleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolesControllerGetProjectRoleById: async (projectId: string, roleId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('rolesControllerGetProjectRoleById', 'projectId', projectId)
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('rolesControllerGetProjectRoleById', 'roleId', roleId)
            const localVarPath = `/projects/{projectId}/roles/{roleId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"roleId"}}`, encodeURIComponent(String(roleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve the role of a specific member
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolesControllerGetUserProjectRole: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('rolesControllerGetUserProjectRole', 'id', id)
            const localVarPath = `/projects/{id}/members/role`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a role
         * @param {string} projectId 
         * @param {number} roleId 
         * @param {UpdateRoleByIdDto} updateRoleByIdDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolesControllerUpdateProjectRoleById: async (projectId: string, roleId: number, updateRoleByIdDto: UpdateRoleByIdDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('rolesControllerUpdateProjectRoleById', 'projectId', projectId)
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('rolesControllerUpdateProjectRoleById', 'roleId', roleId)
            // verify required parameter 'updateRoleByIdDto' is not null or undefined
            assertParamExists('rolesControllerUpdateProjectRoleById', 'updateRoleByIdDto', updateRoleByIdDto)
            const localVarPath = `/projects/{projectId}/roles/{roleId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"roleId"}}`, encodeURIComponent(String(roleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateRoleByIdDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RolesApi - functional programming interface
 */
export const RolesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RolesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new role
         * @param {string} projectId 
         * @param {CreateRoleDto} createRoleDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rolesControllerCreateProjectRole(projectId: string, createRoleDto: CreateRoleDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateProjectRoleResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rolesControllerCreateProjectRole(projectId, createRoleDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RolesApi.rolesControllerCreateProjectRole']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete Project Role
         * @param {string} projectId 
         * @param {number} roleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rolesControllerDeleteProjectRole(projectId: string, roleId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteProjectRoleByIdResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rolesControllerDeleteProjectRole(projectId, roleId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RolesApi.rolesControllerDeleteProjectRole']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve all roles
         * @param {string} projectId 
         * @param {number} [page] 
         * @param {number} [limit] 
         * @param {string} [column] 
         * @param {RolesControllerGetAllProjectRolesDirectionEnum} [direction] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rolesControllerGetAllProjectRoles(projectId: string, page?: number, limit?: number, column?: string, direction?: RolesControllerGetAllProjectRolesDirectionEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAllProjectRoleResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rolesControllerGetAllProjectRoles(projectId, page, limit, column, direction, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RolesApi.rolesControllerGetAllProjectRoles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve a role by ID
         * @param {string} projectId 
         * @param {number} roleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rolesControllerGetProjectRoleById(projectId: string, roleId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetProjectRoleByIdResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rolesControllerGetProjectRoleById(projectId, roleId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RolesApi.rolesControllerGetProjectRoleById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve the role of a specific member
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rolesControllerGetUserProjectRole(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUserProjectRoleByRoleIdResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rolesControllerGetUserProjectRole(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RolesApi.rolesControllerGetUserProjectRole']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a role
         * @param {string} projectId 
         * @param {number} roleId 
         * @param {UpdateRoleByIdDto} updateRoleByIdDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rolesControllerUpdateProjectRoleById(projectId: string, roleId: number, updateRoleByIdDto: UpdateRoleByIdDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateProjectRoleResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rolesControllerUpdateProjectRoleById(projectId, roleId, updateRoleByIdDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RolesApi.rolesControllerUpdateProjectRoleById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RolesApi - factory interface
 */
export const RolesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RolesApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new role
         * @param {string} projectId 
         * @param {CreateRoleDto} createRoleDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolesControllerCreateProjectRole(projectId: string, createRoleDto: CreateRoleDto, options?: RawAxiosRequestConfig): AxiosPromise<CreateProjectRoleResponseDto> {
            return localVarFp.rolesControllerCreateProjectRole(projectId, createRoleDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Project Role
         * @param {string} projectId 
         * @param {number} roleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolesControllerDeleteProjectRole(projectId: string, roleId: number, options?: RawAxiosRequestConfig): AxiosPromise<DeleteProjectRoleByIdResponseDto> {
            return localVarFp.rolesControllerDeleteProjectRole(projectId, roleId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve all roles
         * @param {string} projectId 
         * @param {number} [page] 
         * @param {number} [limit] 
         * @param {string} [column] 
         * @param {RolesControllerGetAllProjectRolesDirectionEnum} [direction] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolesControllerGetAllProjectRoles(projectId: string, page?: number, limit?: number, column?: string, direction?: RolesControllerGetAllProjectRolesDirectionEnum, options?: RawAxiosRequestConfig): AxiosPromise<GetAllProjectRoleResponseDto> {
            return localVarFp.rolesControllerGetAllProjectRoles(projectId, page, limit, column, direction, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a role by ID
         * @param {string} projectId 
         * @param {number} roleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolesControllerGetProjectRoleById(projectId: string, roleId: number, options?: RawAxiosRequestConfig): AxiosPromise<GetProjectRoleByIdResponseDto> {
            return localVarFp.rolesControllerGetProjectRoleById(projectId, roleId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve the role of a specific member
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolesControllerGetUserProjectRole(id: string, options?: RawAxiosRequestConfig): AxiosPromise<GetUserProjectRoleByRoleIdResponseDto> {
            return localVarFp.rolesControllerGetUserProjectRole(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a role
         * @param {string} projectId 
         * @param {number} roleId 
         * @param {UpdateRoleByIdDto} updateRoleByIdDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolesControllerUpdateProjectRoleById(projectId: string, roleId: number, updateRoleByIdDto: UpdateRoleByIdDto, options?: RawAxiosRequestConfig): AxiosPromise<UpdateProjectRoleResponseDto> {
            return localVarFp.rolesControllerUpdateProjectRoleById(projectId, roleId, updateRoleByIdDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RolesApi - object-oriented interface
 */
export class RolesApi extends BaseAPI {
    /**
     * 
     * @summary Create a new role
     * @param {string} projectId 
     * @param {CreateRoleDto} createRoleDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public rolesControllerCreateProjectRole(projectId: string, createRoleDto: CreateRoleDto, options?: RawAxiosRequestConfig) {
        return RolesApiFp(this.configuration).rolesControllerCreateProjectRole(projectId, createRoleDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Project Role
     * @param {string} projectId 
     * @param {number} roleId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public rolesControllerDeleteProjectRole(projectId: string, roleId: number, options?: RawAxiosRequestConfig) {
        return RolesApiFp(this.configuration).rolesControllerDeleteProjectRole(projectId, roleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve all roles
     * @param {string} projectId 
     * @param {number} [page] 
     * @param {number} [limit] 
     * @param {string} [column] 
     * @param {RolesControllerGetAllProjectRolesDirectionEnum} [direction] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public rolesControllerGetAllProjectRoles(projectId: string, page?: number, limit?: number, column?: string, direction?: RolesControllerGetAllProjectRolesDirectionEnum, options?: RawAxiosRequestConfig) {
        return RolesApiFp(this.configuration).rolesControllerGetAllProjectRoles(projectId, page, limit, column, direction, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a role by ID
     * @param {string} projectId 
     * @param {number} roleId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public rolesControllerGetProjectRoleById(projectId: string, roleId: number, options?: RawAxiosRequestConfig) {
        return RolesApiFp(this.configuration).rolesControllerGetProjectRoleById(projectId, roleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve the role of a specific member
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public rolesControllerGetUserProjectRole(id: string, options?: RawAxiosRequestConfig) {
        return RolesApiFp(this.configuration).rolesControllerGetUserProjectRole(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a role
     * @param {string} projectId 
     * @param {number} roleId 
     * @param {UpdateRoleByIdDto} updateRoleByIdDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public rolesControllerUpdateProjectRoleById(projectId: string, roleId: number, updateRoleByIdDto: UpdateRoleByIdDto, options?: RawAxiosRequestConfig) {
        return RolesApiFp(this.configuration).rolesControllerUpdateProjectRoleById(projectId, roleId, updateRoleByIdDto, options).then((request) => request(this.axios, this.basePath));
    }
}

export const RolesControllerGetAllProjectRolesDirectionEnum = {
    Asc: 'ASC',
    Desc: 'DESC'
} as const;
export type RolesControllerGetAllProjectRolesDirectionEnum = typeof RolesControllerGetAllProjectRolesDirectionEnum[keyof typeof RolesControllerGetAllProjectRolesDirectionEnum];


/**
 * WebhookApi - axios parameter creator
 */
export const WebhookApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create webhook
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookControllerCreateWebhook: async (projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('webhookControllerCreateWebhook', 'projectId', projectId)
            const localVarPath = `/projects/{projectId}/webhooks`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete webhook
         * @param {string} projectId 
         * @param {string} modelId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookControllerDeleteWebhook: async (projectId: string, modelId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('webhookControllerDeleteWebhook', 'projectId', projectId)
            // verify required parameter 'modelId' is not null or undefined
            assertParamExists('webhookControllerDeleteWebhook', 'modelId', modelId)
            const localVarPath = `/projects/{projectId}/webhooks/{modelId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"modelId"}}`, encodeURIComponent(String(modelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Fetch webhook
         * @param {string} projectId 
         * @param {string} modelId 
         * @param {boolean} isAgentWebhook 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookControllerFetchWebhook: async (projectId: string, modelId: string, isAgentWebhook: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('webhookControllerFetchWebhook', 'projectId', projectId)
            // verify required parameter 'modelId' is not null or undefined
            assertParamExists('webhookControllerFetchWebhook', 'modelId', modelId)
            // verify required parameter 'isAgentWebhook' is not null or undefined
            assertParamExists('webhookControllerFetchWebhook', 'isAgentWebhook', isAgentWebhook)
            const localVarPath = `/projects/{projectId}/webhooks/{modelId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"modelId"}}`, encodeURIComponent(String(modelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (isAgentWebhook !== undefined) {
                localVarQueryParameter['isAgentWebhook'] = isAgentWebhook;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update webhook
         * @param {string} webhookId 
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookControllerUpdateWebhook: async (webhookId: string, projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'webhookId' is not null or undefined
            assertParamExists('webhookControllerUpdateWebhook', 'webhookId', webhookId)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('webhookControllerUpdateWebhook', 'projectId', projectId)
            const localVarPath = `/projects/{projectId}/webhooks/{webhookId}`
                .replace(`{${"webhookId"}}`, encodeURIComponent(String(webhookId)))
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WebhookApi - functional programming interface
 */
export const WebhookApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WebhookApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create webhook
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async webhookControllerCreateWebhook(projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateWebhookDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.webhookControllerCreateWebhook(projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhookApi.webhookControllerCreateWebhook']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete webhook
         * @param {string} projectId 
         * @param {string} modelId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async webhookControllerDeleteWebhook(projectId: string, modelId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateWebhookDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.webhookControllerDeleteWebhook(projectId, modelId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhookApi.webhookControllerDeleteWebhook']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Fetch webhook
         * @param {string} projectId 
         * @param {string} modelId 
         * @param {boolean} isAgentWebhook 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async webhookControllerFetchWebhook(projectId: string, modelId: string, isAgentWebhook: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateWebhookDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.webhookControllerFetchWebhook(projectId, modelId, isAgentWebhook, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhookApi.webhookControllerFetchWebhook']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update webhook
         * @param {string} webhookId 
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async webhookControllerUpdateWebhook(webhookId: string, projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateWebhookDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.webhookControllerUpdateWebhook(webhookId, projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhookApi.webhookControllerUpdateWebhook']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * WebhookApi - factory interface
 */
export const WebhookApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WebhookApiFp(configuration)
    return {
        /**
         * 
         * @summary Create webhook
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookControllerCreateWebhook(projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<CreateWebhookDto> {
            return localVarFp.webhookControllerCreateWebhook(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete webhook
         * @param {string} projectId 
         * @param {string} modelId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookControllerDeleteWebhook(projectId: string, modelId: string, options?: RawAxiosRequestConfig): AxiosPromise<CreateWebhookDto> {
            return localVarFp.webhookControllerDeleteWebhook(projectId, modelId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Fetch webhook
         * @param {string} projectId 
         * @param {string} modelId 
         * @param {boolean} isAgentWebhook 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookControllerFetchWebhook(projectId: string, modelId: string, isAgentWebhook: boolean, options?: RawAxiosRequestConfig): AxiosPromise<CreateWebhookDto> {
            return localVarFp.webhookControllerFetchWebhook(projectId, modelId, isAgentWebhook, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update webhook
         * @param {string} webhookId 
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookControllerUpdateWebhook(webhookId: string, projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<CreateWebhookDto> {
            return localVarFp.webhookControllerUpdateWebhook(webhookId, projectId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WebhookApi - object-oriented interface
 */
export class WebhookApi extends BaseAPI {
    /**
     * 
     * @summary Create webhook
     * @param {string} projectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public webhookControllerCreateWebhook(projectId: string, options?: RawAxiosRequestConfig) {
        return WebhookApiFp(this.configuration).webhookControllerCreateWebhook(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete webhook
     * @param {string} projectId 
     * @param {string} modelId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public webhookControllerDeleteWebhook(projectId: string, modelId: string, options?: RawAxiosRequestConfig) {
        return WebhookApiFp(this.configuration).webhookControllerDeleteWebhook(projectId, modelId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Fetch webhook
     * @param {string} projectId 
     * @param {string} modelId 
     * @param {boolean} isAgentWebhook 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public webhookControllerFetchWebhook(projectId: string, modelId: string, isAgentWebhook: boolean, options?: RawAxiosRequestConfig) {
        return WebhookApiFp(this.configuration).webhookControllerFetchWebhook(projectId, modelId, isAgentWebhook, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update webhook
     * @param {string} webhookId 
     * @param {string} projectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public webhookControllerUpdateWebhook(webhookId: string, projectId: string, options?: RawAxiosRequestConfig) {
        return WebhookApiFp(this.configuration).webhookControllerUpdateWebhook(webhookId, projectId, options).then((request) => request(this.axios, this.basePath));
    }
}



