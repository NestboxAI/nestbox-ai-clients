/* tslint:disable */
/* eslint-disable */
/**
 * Nestbox API Documents Processing API
 * API for Nestbox Documents Processing
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction, replaceWithSerializableTypeIfNeeded } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

export interface BatchQueryDto {
    /**
     * Batch query ID
     */
    'id': string;
    /**
     * Associated document ID
     */
    'documentId'?: string;
    /**
     * Batch query status
     */
    'status': BatchQueryDtoStatusEnum;
    /**
     * Batch query creation timestamp
     */
    'createdAt': string;
    /**
     * Batch query last update timestamp
     */
    'updatedAt'?: string;
    /**
     * Latest job ID associated with this batch query
     */
    'latestJobId'?: string;
    /**
     * YAML file name
     */
    'yamlFileName'?: string;
    /**
     * Optional stored results (if persisted)
     */
    'results'?: { [key: string]: any; };
}

export const BatchQueryDtoStatusEnum = {
    Queued: 'queued',
    Running: 'running',
    Completed: 'completed',
    Failed: 'failed'
} as const;

export type BatchQueryDtoStatusEnum = typeof BatchQueryDtoStatusEnum[keyof typeof BatchQueryDtoStatusEnum];

export interface CreateWebhookInputDto {
    /**
     * Webhook target URL
     */
    'url': string;
}
export interface DocumentCreateResponseDto {
    /**
     * Created document
     */
    'document': DocumentDto;
    /**
     * Processing job
     */
    'job': JobDto;
}
export interface DocumentDto {
    /**
     * Document ID
     */
    'id': string;
    /**
     * Associated profile ID
     */
    'profileId': string;
    /**
     * Document processing status
     */
    'status': DocumentDtoStatusEnum;
    /**
     * Original file name
     */
    'fileName'?: string;
    /**
     * MIME content type
     */
    'contentType'?: string;
    /**
     * File size in bytes
     */
    'sizeBytes'?: number;
    /**
     * Document creation timestamp
     */
    'createdAt': string;
    /**
     * Document last update timestamp
     */
    'updatedAt'?: string;
    /**
     * Latest job ID associated with this document
     */
    'latestJobId'?: string;
    /**
     * Optional processing metrics (pages, chunks, entities, etc.)
     */
    'metrics'?: { [key: string]: any; };
}

export const DocumentDtoStatusEnum = {
    Queued: 'queued',
    Processing: 'processing',
    Ready: 'ready',
    Failed: 'failed',
    Deleted: 'deleted'
} as const;

export type DocumentDtoStatusEnum = typeof DocumentDtoStatusEnum[keyof typeof DocumentDtoStatusEnum];

export interface DocumentSourcesResponseDto {
    /**
     * Source items
     */
    'data': Array<SourceItemDto>;
}
export interface ErrorDto {
    /**
     * Error type
     */
    'error': string;
    /**
     * Error message
     */
    'message': string;
    /**
     * Request ID for tracking
     */
    'requestId'?: string;
    /**
     * Additional error details
     */
    'details'?: { [key: string]: any; };
}
export interface EvalCreateResponseDto {
    /**
     * Created evaluation
     */
    'eval': EvalDto;
    /**
     * Processing job
     */
    'job': JobDto;
}
export interface EvalDto {
    /**
     * Evaluation ID
     */
    'id': string;
    /**
     * Associated document ID
     */
    'documentId': string;
    /**
     * Evaluation status
     */
    'status': EvalDtoStatusEnum;
    /**
     * Evaluation creation timestamp
     */
    'createdAt': string;
    /**
     * Evaluation last update timestamp
     */
    'updatedAt'?: string;
    /**
     * Latest job ID associated with this evaluation
     */
    'latestJobId'?: string;
    /**
     * YAML file name
     */
    'yamlFileName'?: string;
    /**
     * Optional aggregated metrics (e.g., similarity scores)
     */
    'summary'?: { [key: string]: any; };
    /**
     * Optional detailed report (if stored)
     */
    'report'?: { [key: string]: any; };
}

export const EvalDtoStatusEnum = {
    Queued: 'queued',
    Running: 'running',
    Completed: 'completed',
    Failed: 'failed'
} as const;

export type EvalDtoStatusEnum = typeof EvalDtoStatusEnum[keyof typeof EvalDtoStatusEnum];

export interface GpuDeviceDto {
    /**
     * GPU device index
     */
    'index': number;
    /**
     * GPU device name
     */
    'name': string;
    /**
     * Total GPU memory in MB
     */
    'memoryTotalMB': number;
    /**
     * Used GPU memory in MB
     */
    'memoryUsedMB'?: number;
    /**
     * GPU utilization percentage
     */
    'utilizationPct'?: number;
}
export interface GpuHealthCheckDto {
    /**
     * GPU health status
     */
    'status': GpuHealthCheckDtoStatusEnum;
    /**
     * Number of GPU devices
     */
    'deviceCount'?: number;
    /**
     * GPU devices information
     */
    'devices'?: Array<GpuDeviceDto>;
    /**
     * GPU status message
     */
    'message'?: string;
}

export const GpuHealthCheckDtoStatusEnum = {
    Ok: 'ok',
    Degraded: 'degraded',
    Down: 'down'
} as const;

export type GpuHealthCheckDtoStatusEnum = typeof GpuHealthCheckDtoStatusEnum[keyof typeof GpuHealthCheckDtoStatusEnum];

export interface HealthCheckItemDto {
    /**
     * Health check status
     */
    'status': HealthCheckItemDtoStatusEnum;
    /**
     * Latency in milliseconds
     */
    'latencyMs'?: number;
    /**
     * Status message
     */
    'message'?: string;
    /**
     * Additional details
     */
    'details'?: { [key: string]: any; };
}

export const HealthCheckItemDtoStatusEnum = {
    Ok: 'ok',
    Degraded: 'degraded',
    Down: 'down'
} as const;

export type HealthCheckItemDtoStatusEnum = typeof HealthCheckItemDtoStatusEnum[keyof typeof HealthCheckItemDtoStatusEnum];

export interface HealthChecksDto {
    /**
     * Redis health check
     */
    'redis': HealthCheckItemDto;
    /**
     * Database health check
     */
    'db': HealthCheckItemDto;
    /**
     * GPU health check
     */
    'gpu': GpuHealthCheckDto;
}
export interface HealthResponseDto {
    /**
     * Overall system health status
     */
    'status': HealthResponseDtoStatusEnum;
    /**
     * Health check timestamp
     */
    'timestamp': string;
    /**
     * Health check results
     */
    'checks': HealthChecksDto;
}

export const HealthResponseDtoStatusEnum = {
    Ok: 'ok',
    Degraded: 'degraded',
    Down: 'down'
} as const;

export type HealthResponseDtoStatusEnum = typeof HealthResponseDtoStatusEnum[keyof typeof HealthResponseDtoStatusEnum];

export interface JobDto {
    /**
     * Job ID
     */
    'id': string;
    /**
     * Job type
     */
    'type': JobDtoTypeEnum;
    /**
     * Job state
     */
    'state': JobDtoStateEnum;
    /**
     * Job creation timestamp
     */
    'createdAt': string;
    /**
     * Job last update timestamp
     */
    'updatedAt'?: string;
    /**
     * Associated profile ID
     */
    'profileId'?: string;
    /**
     * Associated document ID
     */
    'documentId'?: string;
    /**
     * Associated evaluation ID
     */
    'evalId'?: string;
    /**
     * Associated query ID
     */
    'queryId'?: string;
    /**
     * 0..1 progress fraction
     */
    'progress'?: number;
    /**
     * Current pipeline stage
     */
    'stage'?: string;
    /**
     * Current job message
     */
    'message'?: string;
    /**
     * Error message if failed
     */
    'error'?: string;
    /**
     * Job-related links
     */
    'links'?: JobLinksDto;
    /**
     * Additional job metadata
     */
    'metadata'?: { [key: string]: any; };
}

export const JobDtoTypeEnum = {
    DocumentProcessing: 'document_processing',
    Evaluation: 'evaluation',
    BatchQuery: 'batch_query',
    Other: 'other'
} as const;

export type JobDtoTypeEnum = typeof JobDtoTypeEnum[keyof typeof JobDtoTypeEnum];
export const JobDtoStateEnum = {
    Pending: 'pending',
    Processing: 'processing',
    Completed: 'completed',
    Failed: 'failed',
    Canceled: 'canceled'
} as const;

export type JobDtoStateEnum = typeof JobDtoStateEnum[keyof typeof JobDtoStateEnum];

export interface JobLinksDto {
    /**
     * Job status URI
     */
    'status'?: string;
    /**
     * Resource URI
     */
    'resource'?: string;
}
export interface JobStatusDto {
    /**
     * Job ID
     */
    'id': string;
    /**
     * Job state
     */
    'state': JobStatusDtoStateEnum;
    /**
     * Job last update timestamp
     */
    'updatedAt': string;
    /**
     * 0..1 progress fraction
     */
    'progress'?: number;
    /**
     * Current pipeline stage
     */
    'stage'?: string;
    /**
     * Current job message
     */
    'message'?: string;
    /**
     * Error message if failed
     */
    'error'?: string;
}

export const JobStatusDtoStateEnum = {
    Pending: 'pending',
    Processing: 'processing',
    Completed: 'completed',
    Failed: 'failed',
    Canceled: 'canceled'
} as const;

export type JobStatusDtoStateEnum = typeof JobStatusDtoStateEnum[keyof typeof JobStatusDtoStateEnum];

export interface PaginatedDocumentsDto {
    /**
     * Document data
     */
    'data': Array<DocumentDto>;
    /**
     * Pagination information
     */
    'pagination': PaginationDto;
}
export interface PaginatedEvalsDto {
    /**
     * Evaluation data
     */
    'data': Array<EvalDto>;
    /**
     * Pagination information
     */
    'pagination': PaginationDto;
}
export interface PaginatedJobsDto {
    /**
     * Job data
     */
    'data': Array<JobDto>;
    /**
     * Pagination information
     */
    'pagination': PaginationDto;
}
export interface PaginatedProfilesDto {
    /**
     * Profile data
     */
    'data': Array<ProfileDto>;
    /**
     * Pagination information
     */
    'pagination': PaginationDto;
}
export interface PaginatedQueriesDto {
    /**
     * Batch query data
     */
    'data': Array<BatchQueryDto>;
    /**
     * Pagination information
     */
    'pagination': PaginationDto;
}
export interface PaginatedWebhooksDto {
    /**
     * Webhook data
     */
    'data': Array<WebhookDto>;
    /**
     * Pagination information
     */
    'pagination': PaginationDto;
}
export interface PaginationDto {
    /**
     * Current page number
     */
    'page': number;
    /**
     * Page size limit
     */
    'limit': number;
    /**
     * Total number of items
     */
    'total': number;
}
export interface ProfileDto {
    /**
     * Profile ID
     */
    'id': string;
    /**
     * Profile name
     */
    'name': string;
    /**
     * Profile description
     */
    'description'?: string;
    /**
     * Profile creation timestamp
     */
    'createdAt': string;
    /**
     * Profile last update timestamp
     */
    'updatedAt'?: string;
    /**
     * YAML file name
     */
    'yamlFileName'?: string;
    /**
     * Optional checksum of the uploaded YAML file
     */
    'yamlSha256'?: string;
    /**
     * Content of the YAML file
     */
    'yamlFileContent'?: string;
}
export interface QueryCreateResponseDto {
    /**
     * Created batch query
     */
    'query': BatchQueryDto;
    /**
     * Processing job
     */
    'job': JobDto;
}
export interface SourceItemDto {
    /**
     * Source ID
     */
    'id': string;
    /**
     * Associated document ID
     */
    'documentId': string;
    /**
     * Associated job ID
     */
    'jobId'?: string;
    /**
     * Chunk ID
     */
    'chunkId'?: string;
    /**
     * Page number
     */
    'page'?: number;
    /**
     * Source text content
     */
    'text': string;
    /**
     * Additional metadata
     */
    'metadata'?: { [key: string]: any; };
}
export interface UpdateWebhookBodyInputDto {
    /**
     * Updated webhook target URL
     */
    'url': string;
}
export interface ValidationErrorDto {
    /**
     * Error type
     */
    'error': string;
    /**
     * Error message
     */
    'message': string;
    /**
     * Validation issues
     */
    'issues': Array<ValidationIssueDto>;
    /**
     * Request ID for tracking
     */
    'requestId'?: string;
}
export interface ValidationIssueDto {
    /**
     * JSON pointer-like path into the YAML document
     */
    'path': string;
    /**
     * Validation issue message
     */
    'message': string;
    /**
     * Issue severity
     */
    'severity'?: ValidationIssueDtoSeverityEnum;
}

export const ValidationIssueDtoSeverityEnum = {
    Error: 'error',
    Warning: 'warning'
} as const;

export type ValidationIssueDtoSeverityEnum = typeof ValidationIssueDtoSeverityEnum[keyof typeof ValidationIssueDtoSeverityEnum];

export interface ValidationResultDto {
    /**
     * Whether the validation passed
     */
    'valid': boolean;
    /**
     * Non-fatal issues
     */
    'warnings'?: Array<ValidationIssueDto>;
    /**
     * Optional normalized representation (if available)
     */
    'normalized'?: { [key: string]: any; };
}
export interface WebhookDto {
    /**
     * Webhook ID
     */
    'id': string;
    /**
     * Webhook target URL
     */
    'url': string;
    /**
     * Webhook creation timestamp
     */
    'createdAt': string;
    /**
     * Webhook last update timestamp
     */
    'updatedAt': string;
}

/**
 * ArtifactsApi - axios parameter creator
 */
export const ArtifactsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Downloads artifacts produced by the pipeline (e.g., GraphRAG outputs, DB snapshots, visualizations) as a single archive.
         * @summary Download document artifacts
         * @param {string} documentId Document ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        artifactsControllerDownloadDocumentArtifacts: async (documentId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('artifactsControllerDownloadDocumentArtifacts', 'documentId', documentId)
            const localVarPath = `/documents/{documentId}/artifacts`
                .replace(`{${"documentId"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ArtifactsApi - functional programming interface
 */
export const ArtifactsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ArtifactsApiAxiosParamCreator(configuration)
    return {
        /**
         * Downloads artifacts produced by the pipeline (e.g., GraphRAG outputs, DB snapshots, visualizations) as a single archive.
         * @summary Download document artifacts
         * @param {string} documentId Document ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async artifactsControllerDownloadDocumentArtifacts(documentId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.artifactsControllerDownloadDocumentArtifacts(documentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ArtifactsApi.artifactsControllerDownloadDocumentArtifacts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ArtifactsApi - factory interface
 */
export const ArtifactsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ArtifactsApiFp(configuration)
    return {
        /**
         * Downloads artifacts produced by the pipeline (e.g., GraphRAG outputs, DB snapshots, visualizations) as a single archive.
         * @summary Download document artifacts
         * @param {string} documentId Document ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        artifactsControllerDownloadDocumentArtifacts(documentId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.artifactsControllerDownloadDocumentArtifacts(documentId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ArtifactsApi - object-oriented interface
 */
export class ArtifactsApi extends BaseAPI {
    /**
     * Downloads artifacts produced by the pipeline (e.g., GraphRAG outputs, DB snapshots, visualizations) as a single archive.
     * @summary Download document artifacts
     * @param {string} documentId Document ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public artifactsControllerDownloadDocumentArtifacts(documentId: string, options?: RawAxiosRequestConfig) {
        return ArtifactsApiFp(this.configuration).artifactsControllerDownloadDocumentArtifacts(documentId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DocumentsApi - axios parameter creator
 */
export const DocumentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Upload a document file (pdf/md/html/docx/etc) via multipart form to start processing.
         * @summary Create document processing job
         * @param {string} profileId Profile/config ID to use for processing (maps to CLI --config).
         * @param {File} file Document file to process (pdf/md/html/docx/etc).
         * @param {string} [stages] Comma-separated stages to run (e.g., docling,chunking,graphrag). If omitted, auto-detected by server.
         * @param {DocumentsControllerCreateDocumentPriorityEnum} [priority] 
         * @param {boolean} [visualize] Whether to generate graph visualization artifacts.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsControllerCreateDocument: async (profileId: string, file: File, stages?: string, priority?: DocumentsControllerCreateDocumentPriorityEnum, visualize?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'profileId' is not null or undefined
            assertParamExists('documentsControllerCreateDocument', 'profileId', profileId)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('documentsControllerCreateDocument', 'file', file)
            const localVarPath = `/documents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


            if (profileId !== undefined) { 
                localVarFormParams.append('profileId', profileId as any);
            }

            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }

            if (stages !== undefined) { 
                localVarFormParams.append('stages', stages as any);
            }

            if (priority !== undefined) { 
                localVarFormParams.append('priority', priority as any);
            }

            if (visualize !== undefined) { 
                localVarFormParams.append('visualize', String(visualize) as any);
            }
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Read document
         * @param {string} documentId Document ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsControllerGetDocument: async (documentId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('documentsControllerGetDocument', 'documentId', documentId)
            const localVarPath = `/documents/{documentId}`
                .replace(`{${"documentId"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List processed documents. Supports filtering by profileId.
         * @summary List documents
         * @param {number} [page] 1-based page number.
         * @param {number} [limit] Page size.
         * @param {string} [profileId] Filter documents by profile/config ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsControllerListDocuments: async (page?: number, limit?: number, profileId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/documents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (profileId !== undefined) {
                localVarQueryParameter['profileId'] = profileId;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DocumentsApi - functional programming interface
 */
export const DocumentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DocumentsApiAxiosParamCreator(configuration)
    return {
        /**
         * Upload a document file (pdf/md/html/docx/etc) via multipart form to start processing.
         * @summary Create document processing job
         * @param {string} profileId Profile/config ID to use for processing (maps to CLI --config).
         * @param {File} file Document file to process (pdf/md/html/docx/etc).
         * @param {string} [stages] Comma-separated stages to run (e.g., docling,chunking,graphrag). If omitted, auto-detected by server.
         * @param {DocumentsControllerCreateDocumentPriorityEnum} [priority] 
         * @param {boolean} [visualize] Whether to generate graph visualization artifacts.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentsControllerCreateDocument(profileId: string, file: File, stages?: string, priority?: DocumentsControllerCreateDocumentPriorityEnum, visualize?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentCreateResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsControllerCreateDocument(profileId, file, stages, priority, visualize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.documentsControllerCreateDocument']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Read document
         * @param {string} documentId Document ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentsControllerGetDocument(documentId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsControllerGetDocument(documentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.documentsControllerGetDocument']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List processed documents. Supports filtering by profileId.
         * @summary List documents
         * @param {number} [page] 1-based page number.
         * @param {number} [limit] Page size.
         * @param {string} [profileId] Filter documents by profile/config ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentsControllerListDocuments(page?: number, limit?: number, profileId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedDocumentsDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsControllerListDocuments(page, limit, profileId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.documentsControllerListDocuments']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DocumentsApi - factory interface
 */
export const DocumentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DocumentsApiFp(configuration)
    return {
        /**
         * Upload a document file (pdf/md/html/docx/etc) via multipart form to start processing.
         * @summary Create document processing job
         * @param {string} profileId Profile/config ID to use for processing (maps to CLI --config).
         * @param {File} file Document file to process (pdf/md/html/docx/etc).
         * @param {string} [stages] Comma-separated stages to run (e.g., docling,chunking,graphrag). If omitted, auto-detected by server.
         * @param {DocumentsControllerCreateDocumentPriorityEnum} [priority] 
         * @param {boolean} [visualize] Whether to generate graph visualization artifacts.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsControllerCreateDocument(profileId: string, file: File, stages?: string, priority?: DocumentsControllerCreateDocumentPriorityEnum, visualize?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<DocumentCreateResponseDto> {
            return localVarFp.documentsControllerCreateDocument(profileId, file, stages, priority, visualize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Read document
         * @param {string} documentId Document ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsControllerGetDocument(documentId: string, options?: RawAxiosRequestConfig): AxiosPromise<DocumentDto> {
            return localVarFp.documentsControllerGetDocument(documentId, options).then((request) => request(axios, basePath));
        },
        /**
         * List processed documents. Supports filtering by profileId.
         * @summary List documents
         * @param {number} [page] 1-based page number.
         * @param {number} [limit] Page size.
         * @param {string} [profileId] Filter documents by profile/config ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsControllerListDocuments(page?: number, limit?: number, profileId?: string, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedDocumentsDto> {
            return localVarFp.documentsControllerListDocuments(page, limit, profileId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DocumentsApi - object-oriented interface
 */
export class DocumentsApi extends BaseAPI {
    /**
     * Upload a document file (pdf/md/html/docx/etc) via multipart form to start processing.
     * @summary Create document processing job
     * @param {string} profileId Profile/config ID to use for processing (maps to CLI --config).
     * @param {File} file Document file to process (pdf/md/html/docx/etc).
     * @param {string} [stages] Comma-separated stages to run (e.g., docling,chunking,graphrag). If omitted, auto-detected by server.
     * @param {DocumentsControllerCreateDocumentPriorityEnum} [priority] 
     * @param {boolean} [visualize] Whether to generate graph visualization artifacts.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public documentsControllerCreateDocument(profileId: string, file: File, stages?: string, priority?: DocumentsControllerCreateDocumentPriorityEnum, visualize?: boolean, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentsControllerCreateDocument(profileId, file, stages, priority, visualize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Read document
     * @param {string} documentId Document ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public documentsControllerGetDocument(documentId: string, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentsControllerGetDocument(documentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List processed documents. Supports filtering by profileId.
     * @summary List documents
     * @param {number} [page] 1-based page number.
     * @param {number} [limit] Page size.
     * @param {string} [profileId] Filter documents by profile/config ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public documentsControllerListDocuments(page?: number, limit?: number, profileId?: string, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentsControllerListDocuments(page, limit, profileId, options).then((request) => request(this.axios, this.basePath));
    }
}

export const DocumentsControllerCreateDocumentPriorityEnum = {
    Low: 'low',
    Normal: 'normal',
    High: 'high'
} as const;
export type DocumentsControllerCreateDocumentPriorityEnum = typeof DocumentsControllerCreateDocumentPriorityEnum[keyof typeof DocumentsControllerCreateDocumentPriorityEnum];


/**
 * EvalsApi - axios parameter creator
 */
export const EvalsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Uploads an eval YAML (test cases) to run against a document.
         * @summary Create an eval from YAML
         * @param {string} documentId Document ID.
         * @param {File} yaml Eval YAML file (test cases).
         * @param {boolean} [watch] If true, server may keep the request open longer (optional); most clients should poll job status instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        evalsControllerCreateEval: async (documentId: string, yaml: File, watch?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('evalsControllerCreateEval', 'documentId', documentId)
            // verify required parameter 'yaml' is not null or undefined
            assertParamExists('evalsControllerCreateEval', 'yaml', yaml)
            const localVarPath = `/documents/{documentId}/evals`
                .replace(`{${"documentId"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


            if (yaml !== undefined) { 
                localVarFormParams.append('yaml', yaml as any);
            }

            if (watch !== undefined) { 
                localVarFormParams.append('watch', String(watch) as any);
            }
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Read eval
         * @param {string} documentId Document ID.
         * @param {string} evalId Evaluation ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        evalsControllerGetEval: async (documentId: string, evalId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('evalsControllerGetEval', 'documentId', documentId)
            // verify required parameter 'evalId' is not null or undefined
            assertParamExists('evalsControllerGetEval', 'evalId', evalId)
            const localVarPath = `/documents/{documentId}/evals/{evalId}`
                .replace(`{${"documentId"}}`, encodeURIComponent(String(documentId)))
                .replace(`{${"evalId"}}`, encodeURIComponent(String(evalId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List evals for a document
         * @param {string} documentId Document ID.
         * @param {any} [limit] Page size.
         * @param {any} [page] 1-based page number.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        evalsControllerListEvals: async (documentId: string, limit?: any, page?: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('evalsControllerListEvals', 'documentId', documentId)
            const localVarPath = `/documents/{documentId}/evals`
                .replace(`{${"documentId"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                for (const [key, value] of Object.entries(limit)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (page !== undefined) {
                for (const [key, value] of Object.entries(page)) {
                    localVarQueryParameter[key] = value;
                }
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Validates an uploaded eval YAML without creating an eval.
         * @summary Validate eval YAML
         * @param {string} documentId Document ID.
         * @param {File} yaml YAML file to validate.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        evalsControllerValidateEvalYaml: async (documentId: string, yaml: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('evalsControllerValidateEvalYaml', 'documentId', documentId)
            // verify required parameter 'yaml' is not null or undefined
            assertParamExists('evalsControllerValidateEvalYaml', 'yaml', yaml)
            const localVarPath = `/documents/{documentId}/evals/validate`
                .replace(`{${"documentId"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


            if (yaml !== undefined) { 
                localVarFormParams.append('yaml', yaml as any);
            }
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EvalsApi - functional programming interface
 */
export const EvalsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EvalsApiAxiosParamCreator(configuration)
    return {
        /**
         * Uploads an eval YAML (test cases) to run against a document.
         * @summary Create an eval from YAML
         * @param {string} documentId Document ID.
         * @param {File} yaml Eval YAML file (test cases).
         * @param {boolean} [watch] If true, server may keep the request open longer (optional); most clients should poll job status instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async evalsControllerCreateEval(documentId: string, yaml: File, watch?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EvalCreateResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.evalsControllerCreateEval(documentId, yaml, watch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EvalsApi.evalsControllerCreateEval']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Read eval
         * @param {string} documentId Document ID.
         * @param {string} evalId Evaluation ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async evalsControllerGetEval(documentId: string, evalId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EvalDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.evalsControllerGetEval(documentId, evalId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EvalsApi.evalsControllerGetEval']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List evals for a document
         * @param {string} documentId Document ID.
         * @param {any} [limit] Page size.
         * @param {any} [page] 1-based page number.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async evalsControllerListEvals(documentId: string, limit?: any, page?: any, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedEvalsDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.evalsControllerListEvals(documentId, limit, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EvalsApi.evalsControllerListEvals']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Validates an uploaded eval YAML without creating an eval.
         * @summary Validate eval YAML
         * @param {string} documentId Document ID.
         * @param {File} yaml YAML file to validate.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async evalsControllerValidateEvalYaml(documentId: string, yaml: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValidationResultDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.evalsControllerValidateEvalYaml(documentId, yaml, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EvalsApi.evalsControllerValidateEvalYaml']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * EvalsApi - factory interface
 */
export const EvalsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EvalsApiFp(configuration)
    return {
        /**
         * Uploads an eval YAML (test cases) to run against a document.
         * @summary Create an eval from YAML
         * @param {string} documentId Document ID.
         * @param {File} yaml Eval YAML file (test cases).
         * @param {boolean} [watch] If true, server may keep the request open longer (optional); most clients should poll job status instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        evalsControllerCreateEval(documentId: string, yaml: File, watch?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<EvalCreateResponseDto> {
            return localVarFp.evalsControllerCreateEval(documentId, yaml, watch, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Read eval
         * @param {string} documentId Document ID.
         * @param {string} evalId Evaluation ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        evalsControllerGetEval(documentId: string, evalId: string, options?: RawAxiosRequestConfig): AxiosPromise<EvalDto> {
            return localVarFp.evalsControllerGetEval(documentId, evalId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List evals for a document
         * @param {string} documentId Document ID.
         * @param {any} [limit] Page size.
         * @param {any} [page] 1-based page number.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        evalsControllerListEvals(documentId: string, limit?: any, page?: any, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedEvalsDto> {
            return localVarFp.evalsControllerListEvals(documentId, limit, page, options).then((request) => request(axios, basePath));
        },
        /**
         * Validates an uploaded eval YAML without creating an eval.
         * @summary Validate eval YAML
         * @param {string} documentId Document ID.
         * @param {File} yaml YAML file to validate.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        evalsControllerValidateEvalYaml(documentId: string, yaml: File, options?: RawAxiosRequestConfig): AxiosPromise<ValidationResultDto> {
            return localVarFp.evalsControllerValidateEvalYaml(documentId, yaml, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EvalsApi - object-oriented interface
 */
export class EvalsApi extends BaseAPI {
    /**
     * Uploads an eval YAML (test cases) to run against a document.
     * @summary Create an eval from YAML
     * @param {string} documentId Document ID.
     * @param {File} yaml Eval YAML file (test cases).
     * @param {boolean} [watch] If true, server may keep the request open longer (optional); most clients should poll job status instead.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public evalsControllerCreateEval(documentId: string, yaml: File, watch?: boolean, options?: RawAxiosRequestConfig) {
        return EvalsApiFp(this.configuration).evalsControllerCreateEval(documentId, yaml, watch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Read eval
     * @param {string} documentId Document ID.
     * @param {string} evalId Evaluation ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public evalsControllerGetEval(documentId: string, evalId: string, options?: RawAxiosRequestConfig) {
        return EvalsApiFp(this.configuration).evalsControllerGetEval(documentId, evalId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List evals for a document
     * @param {string} documentId Document ID.
     * @param {any} [limit] Page size.
     * @param {any} [page] 1-based page number.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public evalsControllerListEvals(documentId: string, limit?: any, page?: any, options?: RawAxiosRequestConfig) {
        return EvalsApiFp(this.configuration).evalsControllerListEvals(documentId, limit, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Validates an uploaded eval YAML without creating an eval.
     * @summary Validate eval YAML
     * @param {string} documentId Document ID.
     * @param {File} yaml YAML file to validate.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public evalsControllerValidateEvalYaml(documentId: string, yaml: File, options?: RawAxiosRequestConfig) {
        return EvalsApiFp(this.configuration).evalsControllerValidateEvalYaml(documentId, yaml, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * HealthApi - axios parameter creator
 */
export const HealthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns service health including Redis, database, and GPU status.
         * @summary Get system health
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthControllerGetHealth: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/health`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HealthApi - functional programming interface
 */
export const HealthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HealthApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns service health including Redis, database, and GPU status.
         * @summary Get system health
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async healthControllerGetHealth(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HealthResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.healthControllerGetHealth(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HealthApi.healthControllerGetHealth']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * HealthApi - factory interface
 */
export const HealthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HealthApiFp(configuration)
    return {
        /**
         * Returns service health including Redis, database, and GPU status.
         * @summary Get system health
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthControllerGetHealth(options?: RawAxiosRequestConfig): AxiosPromise<HealthResponseDto> {
            return localVarFp.healthControllerGetHealth(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HealthApi - object-oriented interface
 */
export class HealthApi extends BaseAPI {
    /**
     * Returns service health including Redis, database, and GPU status.
     * @summary Get system health
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public healthControllerGetHealth(options?: RawAxiosRequestConfig) {
        return HealthApiFp(this.configuration).healthControllerGetHealth(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * JobsApi - axios parameter creator
 */
export const JobsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Read job
         * @param {string} jobId Job ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        jobsControllerGetJob: async (jobId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('jobsControllerGetJob', 'jobId', jobId)
            const localVarPath = `/jobs/{jobId}`
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a lightweight status payload suitable for polling.
         * @summary Get job status
         * @param {string} jobId Job ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        jobsControllerGetJobStatus: async (jobId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('jobsControllerGetJobStatus', 'jobId', jobId)
            const localVarPath = `/jobs/{jobId}/status`
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists jobs for document processing, evaluations, and query jobs.
         * @summary List jobs
         * @param {number} [page] 1-based page number.
         * @param {number} [limit] Page size.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        jobsControllerListJobs: async (page?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/jobs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * JobsApi - functional programming interface
 */
export const JobsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = JobsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Read job
         * @param {string} jobId Job ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async jobsControllerGetJob(jobId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JobDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.jobsControllerGetJob(jobId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['JobsApi.jobsControllerGetJob']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a lightweight status payload suitable for polling.
         * @summary Get job status
         * @param {string} jobId Job ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async jobsControllerGetJobStatus(jobId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JobStatusDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.jobsControllerGetJobStatus(jobId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['JobsApi.jobsControllerGetJobStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Lists jobs for document processing, evaluations, and query jobs.
         * @summary List jobs
         * @param {number} [page] 1-based page number.
         * @param {number} [limit] Page size.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async jobsControllerListJobs(page?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedJobsDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.jobsControllerListJobs(page, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['JobsApi.jobsControllerListJobs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * JobsApi - factory interface
 */
export const JobsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = JobsApiFp(configuration)
    return {
        /**
         * 
         * @summary Read job
         * @param {string} jobId Job ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        jobsControllerGetJob(jobId: string, options?: RawAxiosRequestConfig): AxiosPromise<JobDto> {
            return localVarFp.jobsControllerGetJob(jobId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a lightweight status payload suitable for polling.
         * @summary Get job status
         * @param {string} jobId Job ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        jobsControllerGetJobStatus(jobId: string, options?: RawAxiosRequestConfig): AxiosPromise<JobStatusDto> {
            return localVarFp.jobsControllerGetJobStatus(jobId, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists jobs for document processing, evaluations, and query jobs.
         * @summary List jobs
         * @param {number} [page] 1-based page number.
         * @param {number} [limit] Page size.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        jobsControllerListJobs(page?: number, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedJobsDto> {
            return localVarFp.jobsControllerListJobs(page, limit, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * JobsApi - object-oriented interface
 */
export class JobsApi extends BaseAPI {
    /**
     * 
     * @summary Read job
     * @param {string} jobId Job ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public jobsControllerGetJob(jobId: string, options?: RawAxiosRequestConfig) {
        return JobsApiFp(this.configuration).jobsControllerGetJob(jobId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a lightweight status payload suitable for polling.
     * @summary Get job status
     * @param {string} jobId Job ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public jobsControllerGetJobStatus(jobId: string, options?: RawAxiosRequestConfig) {
        return JobsApiFp(this.configuration).jobsControllerGetJobStatus(jobId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists jobs for document processing, evaluations, and query jobs.
     * @summary List jobs
     * @param {number} [page] 1-based page number.
     * @param {number} [limit] Page size.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public jobsControllerListJobs(page?: number, limit?: number, options?: RawAxiosRequestConfig) {
        return JobsApiFp(this.configuration).jobsControllerListJobs(page, limit, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProfilesApi - axios parameter creator
 */
export const ProfilesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Upload a YAML config file (multipart form). Do not inline YAML parameters in JSON.
         * @summary Create profile from YAML
         * @param {File} yaml YAML file containing the profile/config.
         * @param {string} [name] Optional override for profile name (otherwise derived from YAML).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profilesControllerCreateProfile: async (yaml: File, name?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'yaml' is not null or undefined
            assertParamExists('profilesControllerCreateProfile', 'yaml', yaml)
            const localVarPath = `/profiles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


            if (yaml !== undefined) { 
                localVarFormParams.append('yaml', yaml as any);
            }

            if (name !== undefined) { 
                localVarFormParams.append('name', name as any);
            }
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Read profile
         * @param {string} profileId Profile/config ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profilesControllerGetProfile: async (profileId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'profileId' is not null or undefined
            assertParamExists('profilesControllerGetProfile', 'profileId', profileId)
            const localVarPath = `/profiles/{profileId}`
                .replace(`{${"profileId"}}`, encodeURIComponent(String(profileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the JSON schema for profile YAML configuration files.
         * @summary Get profile schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profilesControllerGetProfileSchema: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/profiles/schema`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List profiles
         * @param {number} [page] 1-based page number.
         * @param {number} [limit] Page size.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profilesControllerListProfiles: async (page?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/profiles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProfilesApi - functional programming interface
 */
export const ProfilesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProfilesApiAxiosParamCreator(configuration)
    return {
        /**
         * Upload a YAML config file (multipart form). Do not inline YAML parameters in JSON.
         * @summary Create profile from YAML
         * @param {File} yaml YAML file containing the profile/config.
         * @param {string} [name] Optional override for profile name (otherwise derived from YAML).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async profilesControllerCreateProfile(yaml: File, name?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProfileDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.profilesControllerCreateProfile(yaml, name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProfilesApi.profilesControllerCreateProfile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Read profile
         * @param {string} profileId Profile/config ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async profilesControllerGetProfile(profileId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProfileDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.profilesControllerGetProfile(profileId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProfilesApi.profilesControllerGetProfile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the JSON schema for profile YAML configuration files.
         * @summary Get profile schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async profilesControllerGetProfileSchema(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.profilesControllerGetProfileSchema(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProfilesApi.profilesControllerGetProfileSchema']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List profiles
         * @param {number} [page] 1-based page number.
         * @param {number} [limit] Page size.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async profilesControllerListProfiles(page?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedProfilesDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.profilesControllerListProfiles(page, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProfilesApi.profilesControllerListProfiles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProfilesApi - factory interface
 */
export const ProfilesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProfilesApiFp(configuration)
    return {
        /**
         * Upload a YAML config file (multipart form). Do not inline YAML parameters in JSON.
         * @summary Create profile from YAML
         * @param {File} yaml YAML file containing the profile/config.
         * @param {string} [name] Optional override for profile name (otherwise derived from YAML).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profilesControllerCreateProfile(yaml: File, name?: string, options?: RawAxiosRequestConfig): AxiosPromise<ProfileDto> {
            return localVarFp.profilesControllerCreateProfile(yaml, name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Read profile
         * @param {string} profileId Profile/config ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profilesControllerGetProfile(profileId: string, options?: RawAxiosRequestConfig): AxiosPromise<ProfileDto> {
            return localVarFp.profilesControllerGetProfile(profileId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the JSON schema for profile YAML configuration files.
         * @summary Get profile schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profilesControllerGetProfileSchema(options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.profilesControllerGetProfileSchema(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List profiles
         * @param {number} [page] 1-based page number.
         * @param {number} [limit] Page size.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profilesControllerListProfiles(page?: number, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedProfilesDto> {
            return localVarFp.profilesControllerListProfiles(page, limit, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProfilesApi - object-oriented interface
 */
export class ProfilesApi extends BaseAPI {
    /**
     * Upload a YAML config file (multipart form). Do not inline YAML parameters in JSON.
     * @summary Create profile from YAML
     * @param {File} yaml YAML file containing the profile/config.
     * @param {string} [name] Optional override for profile name (otherwise derived from YAML).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public profilesControllerCreateProfile(yaml: File, name?: string, options?: RawAxiosRequestConfig) {
        return ProfilesApiFp(this.configuration).profilesControllerCreateProfile(yaml, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Read profile
     * @param {string} profileId Profile/config ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public profilesControllerGetProfile(profileId: string, options?: RawAxiosRequestConfig) {
        return ProfilesApiFp(this.configuration).profilesControllerGetProfile(profileId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the JSON schema for profile YAML configuration files.
     * @summary Get profile schema
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public profilesControllerGetProfileSchema(options?: RawAxiosRequestConfig) {
        return ProfilesApiFp(this.configuration).profilesControllerGetProfileSchema(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List profiles
     * @param {number} [page] 1-based page number.
     * @param {number} [limit] Page size.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public profilesControllerListProfiles(page?: number, limit?: number, options?: RawAxiosRequestConfig) {
        return ProfilesApiFp(this.configuration).profilesControllerListProfiles(page, limit, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * QueriesApi - axios parameter creator
 */
export const QueriesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Uploads a batch queries YAML (multipart form). Typically schedules a job.
         * @summary Create batch query from YAML
         * @param {File} yaml Batch queries YAML file.
         * @param {boolean} [watch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queriesControllerCreateQuery: async (yaml: File, watch?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'yaml' is not null or undefined
            assertParamExists('queriesControllerCreateQuery', 'yaml', yaml)
            const localVarPath = `/query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


            if (yaml !== undefined) { 
                localVarFormParams.append('yaml', yaml as any);
            }

            if (watch !== undefined) { 
                localVarFormParams.append('watch', String(watch) as any);
            }
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Read batch query
         * @param {string} queryId Batch query ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queriesControllerGetQuery: async (queryId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'queryId' is not null or undefined
            assertParamExists('queriesControllerGetQuery', 'queryId', queryId)
            const localVarPath = `/query/{queryId}`
                .replace(`{${"queryId"}}`, encodeURIComponent(String(queryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists batch query runs (submitted via YAML).
         * @summary List batch queries
         * @param {number} [page] 1-based page number.
         * @param {number} [limit] Page size.
         * @param {string} [documentId] Filter by document ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queriesControllerListQueries: async (page?: number, limit?: number, documentId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (documentId !== undefined) {
                localVarQueryParameter['documentId'] = documentId;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Validates an uploaded batch queries YAML without creating a query.
         * @summary Validate batch query YAML
         * @param {File} yaml YAML file to validate.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queriesControllerValidateQueryYaml: async (yaml: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'yaml' is not null or undefined
            assertParamExists('queriesControllerValidateQueryYaml', 'yaml', yaml)
            const localVarPath = `/query/validate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


            if (yaml !== undefined) { 
                localVarFormParams.append('yaml', yaml as any);
            }
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * QueriesApi - functional programming interface
 */
export const QueriesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = QueriesApiAxiosParamCreator(configuration)
    return {
        /**
         * Uploads a batch queries YAML (multipart form). Typically schedules a job.
         * @summary Create batch query from YAML
         * @param {File} yaml Batch queries YAML file.
         * @param {boolean} [watch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async queriesControllerCreateQuery(yaml: File, watch?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryCreateResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.queriesControllerCreateQuery(yaml, watch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['QueriesApi.queriesControllerCreateQuery']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Read batch query
         * @param {string} queryId Batch query ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async queriesControllerGetQuery(queryId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BatchQueryDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.queriesControllerGetQuery(queryId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['QueriesApi.queriesControllerGetQuery']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Lists batch query runs (submitted via YAML).
         * @summary List batch queries
         * @param {number} [page] 1-based page number.
         * @param {number} [limit] Page size.
         * @param {string} [documentId] Filter by document ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async queriesControllerListQueries(page?: number, limit?: number, documentId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedQueriesDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.queriesControllerListQueries(page, limit, documentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['QueriesApi.queriesControllerListQueries']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Validates an uploaded batch queries YAML without creating a query.
         * @summary Validate batch query YAML
         * @param {File} yaml YAML file to validate.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async queriesControllerValidateQueryYaml(yaml: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValidationResultDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.queriesControllerValidateQueryYaml(yaml, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['QueriesApi.queriesControllerValidateQueryYaml']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * QueriesApi - factory interface
 */
export const QueriesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = QueriesApiFp(configuration)
    return {
        /**
         * Uploads a batch queries YAML (multipart form). Typically schedules a job.
         * @summary Create batch query from YAML
         * @param {File} yaml Batch queries YAML file.
         * @param {boolean} [watch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queriesControllerCreateQuery(yaml: File, watch?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<QueryCreateResponseDto> {
            return localVarFp.queriesControllerCreateQuery(yaml, watch, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Read batch query
         * @param {string} queryId Batch query ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queriesControllerGetQuery(queryId: string, options?: RawAxiosRequestConfig): AxiosPromise<BatchQueryDto> {
            return localVarFp.queriesControllerGetQuery(queryId, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists batch query runs (submitted via YAML).
         * @summary List batch queries
         * @param {number} [page] 1-based page number.
         * @param {number} [limit] Page size.
         * @param {string} [documentId] Filter by document ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queriesControllerListQueries(page?: number, limit?: number, documentId?: string, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedQueriesDto> {
            return localVarFp.queriesControllerListQueries(page, limit, documentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Validates an uploaded batch queries YAML without creating a query.
         * @summary Validate batch query YAML
         * @param {File} yaml YAML file to validate.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queriesControllerValidateQueryYaml(yaml: File, options?: RawAxiosRequestConfig): AxiosPromise<ValidationResultDto> {
            return localVarFp.queriesControllerValidateQueryYaml(yaml, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * QueriesApi - object-oriented interface
 */
export class QueriesApi extends BaseAPI {
    /**
     * Uploads a batch queries YAML (multipart form). Typically schedules a job.
     * @summary Create batch query from YAML
     * @param {File} yaml Batch queries YAML file.
     * @param {boolean} [watch] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public queriesControllerCreateQuery(yaml: File, watch?: boolean, options?: RawAxiosRequestConfig) {
        return QueriesApiFp(this.configuration).queriesControllerCreateQuery(yaml, watch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Read batch query
     * @param {string} queryId Batch query ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public queriesControllerGetQuery(queryId: string, options?: RawAxiosRequestConfig) {
        return QueriesApiFp(this.configuration).queriesControllerGetQuery(queryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists batch query runs (submitted via YAML).
     * @summary List batch queries
     * @param {number} [page] 1-based page number.
     * @param {number} [limit] Page size.
     * @param {string} [documentId] Filter by document ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public queriesControllerListQueries(page?: number, limit?: number, documentId?: string, options?: RawAxiosRequestConfig) {
        return QueriesApiFp(this.configuration).queriesControllerListQueries(page, limit, documentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Validates an uploaded batch queries YAML without creating a query.
     * @summary Validate batch query YAML
     * @param {File} yaml YAML file to validate.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public queriesControllerValidateQueryYaml(yaml: File, options?: RawAxiosRequestConfig) {
        return QueriesApiFp(this.configuration).queriesControllerValidateQueryYaml(yaml, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SourcesApi - axios parameter creator
 */
export const SourcesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns source data used to produce answers/results. If sourceId is provided, returns the matching source. Otherwise returns a list.
         * @summary Read document sources
         * @param {string} documentId Document ID.
         * @param {any} [jobId] Optional job ID to scope sources to a specific query job.
         * @param {any} [sourceId] Optional source ID (full or partial) to retrieve a specific source.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sourcesControllerGetDocumentSources: async (documentId: string, jobId?: any, sourceId?: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('sourcesControllerGetDocumentSources', 'documentId', documentId)
            const localVarPath = `/documents/{documentId}/sources`
                .replace(`{${"documentId"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (jobId !== undefined) {
                for (const [key, value] of Object.entries(jobId)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (sourceId !== undefined) {
                for (const [key, value] of Object.entries(sourceId)) {
                    localVarQueryParameter[key] = value;
                }
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SourcesApi - functional programming interface
 */
export const SourcesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SourcesApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns source data used to produce answers/results. If sourceId is provided, returns the matching source. Otherwise returns a list.
         * @summary Read document sources
         * @param {string} documentId Document ID.
         * @param {any} [jobId] Optional job ID to scope sources to a specific query job.
         * @param {any} [sourceId] Optional source ID (full or partial) to retrieve a specific source.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sourcesControllerGetDocumentSources(documentId: string, jobId?: any, sourceId?: any, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentSourcesResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sourcesControllerGetDocumentSources(documentId, jobId, sourceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SourcesApi.sourcesControllerGetDocumentSources']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SourcesApi - factory interface
 */
export const SourcesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SourcesApiFp(configuration)
    return {
        /**
         * Returns source data used to produce answers/results. If sourceId is provided, returns the matching source. Otherwise returns a list.
         * @summary Read document sources
         * @param {string} documentId Document ID.
         * @param {any} [jobId] Optional job ID to scope sources to a specific query job.
         * @param {any} [sourceId] Optional source ID (full or partial) to retrieve a specific source.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sourcesControllerGetDocumentSources(documentId: string, jobId?: any, sourceId?: any, options?: RawAxiosRequestConfig): AxiosPromise<DocumentSourcesResponseDto> {
            return localVarFp.sourcesControllerGetDocumentSources(documentId, jobId, sourceId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SourcesApi - object-oriented interface
 */
export class SourcesApi extends BaseAPI {
    /**
     * Returns source data used to produce answers/results. If sourceId is provided, returns the matching source. Otherwise returns a list.
     * @summary Read document sources
     * @param {string} documentId Document ID.
     * @param {any} [jobId] Optional job ID to scope sources to a specific query job.
     * @param {any} [sourceId] Optional source ID (full or partial) to retrieve a specific source.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public sourcesControllerGetDocumentSources(documentId: string, jobId?: any, sourceId?: any, options?: RawAxiosRequestConfig) {
        return SourcesApiFp(this.configuration).sourcesControllerGetDocumentSources(documentId, jobId, sourceId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * WebhooksApi - axios parameter creator
 */
export const WebhooksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create webhook
         * @param {CreateWebhookInputDto} createWebhookInputDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksControllerCreateWebhook: async (createWebhookInputDto: CreateWebhookInputDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createWebhookInputDto' is not null or undefined
            assertParamExists('webhooksControllerCreateWebhook', 'createWebhookInputDto', createWebhookInputDto)
            const localVarPath = `/webhooks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createWebhookInputDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete webhook
         * @param {string} webhookId Webhook ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksControllerDeleteWebhook: async (webhookId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'webhookId' is not null or undefined
            assertParamExists('webhooksControllerDeleteWebhook', 'webhookId', webhookId)
            const localVarPath = `/webhooks/{webhookId}`
                .replace(`{${"webhookId"}}`, encodeURIComponent(String(webhookId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Read webhook
         * @param {string} webhookId Webhook ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksControllerGetWebhook: async (webhookId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'webhookId' is not null or undefined
            assertParamExists('webhooksControllerGetWebhook', 'webhookId', webhookId)
            const localVarPath = `/webhooks/{webhookId}`
                .replace(`{${"webhookId"}}`, encodeURIComponent(String(webhookId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List webhooks
         * @param {number} [page] 1-based page number.
         * @param {number} [limit] Page size.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksControllerListWebhooks: async (page?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/webhooks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update webhook
         * @param {string} webhookId Webhook ID.
         * @param {UpdateWebhookBodyInputDto} updateWebhookBodyInputDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksControllerUpdateWebhook: async (webhookId: string, updateWebhookBodyInputDto: UpdateWebhookBodyInputDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'webhookId' is not null or undefined
            assertParamExists('webhooksControllerUpdateWebhook', 'webhookId', webhookId)
            // verify required parameter 'updateWebhookBodyInputDto' is not null or undefined
            assertParamExists('webhooksControllerUpdateWebhook', 'updateWebhookBodyInputDto', updateWebhookBodyInputDto)
            const localVarPath = `/webhooks/{webhookId}`
                .replace(`{${"webhookId"}}`, encodeURIComponent(String(webhookId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateWebhookBodyInputDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WebhooksApi - functional programming interface
 */
export const WebhooksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WebhooksApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create webhook
         * @param {CreateWebhookInputDto} createWebhookInputDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async webhooksControllerCreateWebhook(createWebhookInputDto: CreateWebhookInputDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.webhooksControllerCreateWebhook(createWebhookInputDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhooksApi.webhooksControllerCreateWebhook']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete webhook
         * @param {string} webhookId Webhook ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async webhooksControllerDeleteWebhook(webhookId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.webhooksControllerDeleteWebhook(webhookId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhooksApi.webhooksControllerDeleteWebhook']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Read webhook
         * @param {string} webhookId Webhook ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async webhooksControllerGetWebhook(webhookId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.webhooksControllerGetWebhook(webhookId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhooksApi.webhooksControllerGetWebhook']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List webhooks
         * @param {number} [page] 1-based page number.
         * @param {number} [limit] Page size.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async webhooksControllerListWebhooks(page?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedWebhooksDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.webhooksControllerListWebhooks(page, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhooksApi.webhooksControllerListWebhooks']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update webhook
         * @param {string} webhookId Webhook ID.
         * @param {UpdateWebhookBodyInputDto} updateWebhookBodyInputDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async webhooksControllerUpdateWebhook(webhookId: string, updateWebhookBodyInputDto: UpdateWebhookBodyInputDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.webhooksControllerUpdateWebhook(webhookId, updateWebhookBodyInputDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhooksApi.webhooksControllerUpdateWebhook']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * WebhooksApi - factory interface
 */
export const WebhooksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WebhooksApiFp(configuration)
    return {
        /**
         * 
         * @summary Create webhook
         * @param {CreateWebhookInputDto} createWebhookInputDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksControllerCreateWebhook(createWebhookInputDto: CreateWebhookInputDto, options?: RawAxiosRequestConfig): AxiosPromise<WebhookDto> {
            return localVarFp.webhooksControllerCreateWebhook(createWebhookInputDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete webhook
         * @param {string} webhookId Webhook ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksControllerDeleteWebhook(webhookId: string, options?: RawAxiosRequestConfig): AxiosPromise<WebhookDto> {
            return localVarFp.webhooksControllerDeleteWebhook(webhookId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Read webhook
         * @param {string} webhookId Webhook ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksControllerGetWebhook(webhookId: string, options?: RawAxiosRequestConfig): AxiosPromise<WebhookDto> {
            return localVarFp.webhooksControllerGetWebhook(webhookId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List webhooks
         * @param {number} [page] 1-based page number.
         * @param {number} [limit] Page size.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksControllerListWebhooks(page?: number, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedWebhooksDto> {
            return localVarFp.webhooksControllerListWebhooks(page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update webhook
         * @param {string} webhookId Webhook ID.
         * @param {UpdateWebhookBodyInputDto} updateWebhookBodyInputDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksControllerUpdateWebhook(webhookId: string, updateWebhookBodyInputDto: UpdateWebhookBodyInputDto, options?: RawAxiosRequestConfig): AxiosPromise<WebhookDto> {
            return localVarFp.webhooksControllerUpdateWebhook(webhookId, updateWebhookBodyInputDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WebhooksApi - object-oriented interface
 */
export class WebhooksApi extends BaseAPI {
    /**
     * 
     * @summary Create webhook
     * @param {CreateWebhookInputDto} createWebhookInputDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public webhooksControllerCreateWebhook(createWebhookInputDto: CreateWebhookInputDto, options?: RawAxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).webhooksControllerCreateWebhook(createWebhookInputDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete webhook
     * @param {string} webhookId Webhook ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public webhooksControllerDeleteWebhook(webhookId: string, options?: RawAxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).webhooksControllerDeleteWebhook(webhookId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Read webhook
     * @param {string} webhookId Webhook ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public webhooksControllerGetWebhook(webhookId: string, options?: RawAxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).webhooksControllerGetWebhook(webhookId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List webhooks
     * @param {number} [page] 1-based page number.
     * @param {number} [limit] Page size.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public webhooksControllerListWebhooks(page?: number, limit?: number, options?: RawAxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).webhooksControllerListWebhooks(page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update webhook
     * @param {string} webhookId Webhook ID.
     * @param {UpdateWebhookBodyInputDto} updateWebhookBodyInputDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public webhooksControllerUpdateWebhook(webhookId: string, updateWebhookBodyInputDto: UpdateWebhookBodyInputDto, options?: RawAxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).webhooksControllerUpdateWebhook(webhookId, updateWebhookBodyInputDto, options).then((request) => request(this.axios, this.basePath));
    }
}



